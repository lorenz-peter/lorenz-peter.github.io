<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Recommender Systems | Peter Lorenz </title> <meta name="author" content="Peter Lorenz"> <meta name="description" content="Personal Website "> <meta name="keywords" content="peter, lorenz, security, deep, learning"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%A7%91%E2%80%8D%F0%9F%92%BB&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://lorenz-peter.github.io/blog/2025/recommender-systems/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Peter</span> Lorenz </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Recommender Systems</h1> <p class="post-meta"> Created in March 28, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/mlsd"> <i class="fa-solid fa-hashtag fa-sm"></i> MLSD</a>   ·   <a href="/blog/category/recommender"> <i class="fa-solid fa-tag fa-sm"></i> Recommender</a>   <a href="/blog/category/system"> <i class="fa-solid fa-tag fa-sm"></i> System</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p><a href="https://aman.ai/recsys/architectures/#deep-factorization-machine--deepfm-2017" rel="external nofollow noopener" target="_blank">Source</a></p> <ul> <li><a href="https://aman.ai/recsys/architectures/#overview" rel="external nofollow noopener" target="_blank">Overview</a></li> <li> <a href="https://aman.ai/recsys/architectures/#deep-neural-network-models-for-recommender-systems" rel="external nofollow noopener" target="_blank">Deep Neural Network Models for Recommender Systems</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#advantages-of-dnn-models-for-recommender-systems" rel="external nofollow noopener" target="_blank">Advantages of DNN Models for Recommender Systems</a></li> <li><a href="https://aman.ai/recsys/architectures/#scenarios-where-deep-learning-may-not-be-effective" rel="external nofollow noopener" target="_blank">Scenarios Where Deep Learning May Not be Effective</a></li> <li><a href="https://aman.ai/recsys/architectures/#common-variations-of-neural-building-blocks" rel="external nofollow noopener" target="_blank">Common Variations of Neural Building Blocks</a></li> <li><a href="https://aman.ai/recsys/architectures/#applications-in-recommendation-systems" rel="external nofollow noopener" target="_blank">Applications in Recommendation Systems</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#wide-and-deep-2016" rel="external nofollow noopener" target="_blank">Wide and Deep (2016)</a> <ul> <li> <a href="https://aman.ai/recsys/architectures/#background-cross-features" rel="external nofollow noopener" target="_blank">Background: Cross Features</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#what-are-feature-crosses-and-why-are-they-important" rel="external nofollow noopener" target="_blank">What are Feature Crosses and Why are They Important?</a></li> <li><a href="https://aman.ai/recsys/architectures/#what-are-the-challenges-in-learning-feature-crosses" rel="external nofollow noopener" target="_blank">What are the Challenges in Learning Feature Crosses?</a></li> </ul> </li> <li><a href="https://aman.ai/recsys/architectures/#motivation" rel="external nofollow noopener" target="_blank">Motivation</a></li> <li><a href="https://aman.ai/recsys/architectures/#architecture" rel="external nofollow noopener" target="_blank">Architecture</a></li> <li> <a href="https://aman.ai/recsys/architectures/#example" rel="external nofollow noopener" target="_blank">Example</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#input-to-the-wide-component" rel="external nofollow noopener" target="_blank">Input to the Wide Component</a></li> <li><a href="https://aman.ai/recsys/architectures/#input-to-the-deep-component" rel="external nofollow noopener" target="_blank">Input to the Deep Component</a></li> </ul> </li> <li><a href="https://aman.ai/recsys/architectures/#combining-inputs-in-wide--deep-model" rel="external nofollow noopener" target="_blank">Combining Inputs in Wide &amp; Deep Model</a></li> <li><a href="https://aman.ai/recsys/architectures/#results" rel="external nofollow noopener" target="_blank">Results</a></li> <li><a href="https://aman.ai/recsys/architectures/#summary" rel="external nofollow noopener" target="_blank">Summary</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#factorization-machines--fm-2010" rel="external nofollow noopener" target="_blank">Factorization Machines / FM (2010)</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#summary-1" rel="external nofollow noopener" target="_blank">Summary</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#deep-factorization-machine--deepfm-2017" rel="external nofollow noopener" target="_blank">Deep Factorization Machine / DeepFM (2017)</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#summary-2" rel="external nofollow noopener" target="_blank">Summary</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#neural-collaborative-filtering--ncf-2017" rel="external nofollow noopener" target="_blank">Neural Collaborative Filtering / NCF (2017)</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#summary-3" rel="external nofollow noopener" target="_blank">Summary</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#deep-and-cross-networks--dcn-2017" rel="external nofollow noopener" target="_blank">Deep and Cross Networks / DCN (2017)</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#forming-higher-order-feature-interactions" rel="external nofollow noopener" target="_blank">Forming Higher-Order Feature Interactions</a></li> <li><a href="https://aman.ai/recsys/architectures/#handling-sparse-features-through-embedding-layers" rel="external nofollow noopener" target="_blank">Handling Sparse Features Through Embedding Layers</a></li> <li><a href="https://aman.ai/recsys/architectures/#explicit-feature-crossing-and-polynomial-degree" rel="external nofollow noopener" target="_blank">Explicit Feature Crossing and Polynomial Degree</a></li> <li><a href="https://aman.ai/recsys/architectures/#input-and-output-to-each-component" rel="external nofollow noopener" target="_blank">Input and Output to Each Component</a></li> <li><a href="https://aman.ai/recsys/architectures/#cross-network-layers" rel="external nofollow noopener" target="_blank">Cross Network Layers</a></li> <li><a href="https://aman.ai/recsys/architectures/#deep-network-layers" rel="external nofollow noopener" target="_blank">Deep Network Layers</a></li> <li><a href="https://aman.ai/recsys/architectures/#results-1" rel="external nofollow noopener" target="_blank">Results</a></li> <li><a href="https://aman.ai/recsys/architectures/#summary-4" rel="external nofollow noopener" target="_blank">Summary</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#autoint-2019" rel="external nofollow noopener" target="_blank">AutoInt (2019)</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#summary-5" rel="external nofollow noopener" target="_blank">Summary</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#dlrm-2019" rel="external nofollow noopener" target="_blank">DLRM (2019)</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#summary-6" rel="external nofollow noopener" target="_blank">Summary</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#dcn-v2-2020" rel="external nofollow noopener" target="_blank">DCN V2 (2020)</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#dcn-vs-dcn-v2" rel="external nofollow noopener" target="_blank">DCN vs. DCN V2</a></li> <li> <a href="https://aman.ai/recsys/architectures/#low-rank-techniques-in-dcn-v2" rel="external nofollow noopener" target="_blank">Low-Rank Techniques in DCN V2</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#dcn-limitations-in-scalability" rel="external nofollow noopener" target="_blank">DCN Limitations in Scalability</a></li> <li><a href="https://aman.ai/recsys/architectures/#low-rank-approximations" rel="external nofollow noopener" target="_blank">Low-Rank Approximations</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#mixture-of-experts-architecture" rel="external nofollow noopener" target="_blank">Mixture-of-Experts Architecture</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#enhancing-expressiveness-with-mixture-of-experts" rel="external nofollow noopener" target="_blank">Enhancing Expressiveness with Mixture-of-Experts</a></li> <li><a href="https://aman.ai/recsys/architectures/#advantages-of-mixture-of-experts" rel="external nofollow noopener" target="_blank">Advantages of Mixture-of-Experts</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#model-structure-parallel-dcn-vs-stacked-and-parallel-dcn-v2" rel="external nofollow noopener" target="_blank">Model Structure: Parallel (DCN) vs. Stacked and Parallel (DCN V2)</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#dcn" rel="external nofollow noopener" target="_blank">DCN</a></li> <li><a href="https://aman.ai/recsys/architectures/#dcn-v2" rel="external nofollow noopener" target="_blank">DCN V2</a></li> </ul> </li> <li><a href="https://aman.ai/recsys/architectures/#summary-of-key-differences" rel="external nofollow noopener" target="_blank">Summary of Key Differences</a></li> <li><a href="https://aman.ai/recsys/architectures/#summary-7" rel="external nofollow noopener" target="_blank">Summary</a></li> </ul> </li> <li> <a href="https://aman.ai/recsys/architectures/#dhen-2022" rel="external nofollow noopener" target="_blank">DHEN (2022)</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#summary-8" rel="external nofollow noopener" target="_blank">Summary</a></li> </ul> </li> <li><a href="https://aman.ai/recsys/architectures/#gdcn-2023" rel="external nofollow noopener" target="_blank">GDCN (2023)</a></li> <li><a href="https://aman.ai/recsys/architectures/#graph-neural-networks-based-recsys-architectures" rel="external nofollow noopener" target="_blank">Graph Neural Networks-based RecSys Architectures</a></li> <li> <a href="https://aman.ai/recsys/architectures/#two-towers-in-recsys" rel="external nofollow noopener" target="_blank">Two Towers in RecSys</a> <ul> <li><a href="https://aman.ai/recsys/architectures/#split-network" rel="external nofollow noopener" target="_blank">Split Network</a></li> </ul> </li> <li><a href="https://aman.ai/recsys/architectures/#summary-9" rel="external nofollow noopener" target="_blank">Summary</a></li> <li><a href="https://aman.ai/recsys/architectures/#comparative-analysis" rel="external nofollow noopener" target="_blank">Comparative Analysis</a></li> <li><a href="https://aman.ai/recsys/architectures/#references" rel="external nofollow noopener" target="_blank">References</a></li> </ul> <h2 id="overview">Overview</h2> <ul> <li>This primer explores some of the most popular architectures used in recommender systems, focusing on how these systems process and utilize different types of features for generating recommendations.</li> <li>The plot below <a href="https://paperswithcode.com/sota/click-through-rate-prediction-on-criteo" rel="external nofollow noopener" target="_blank">(source)</a> is a visual representation of the models and architectures for the task of Click-Through Rate Prediction on the Criteo dataset. With this use-case as our poster child, we will discuss the inner workings of some of the major model architectures listed in the plot.</li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/CTR.jpg" alt=""></p> <h2 id="deep-neural-network-models-for-recommender-systems">Deep Neural Network Models for Recommender Systems</h2> <ul> <li>Deep neural network (DNN) models have become a cornerstone in modern recommendation systems due to their ability to capture complex patterns and deliver highly personalized and accurate recommendations.</li> <li>Leveraging variations of artificial neural networks (ANNs), DNNs excel in modeling intricate, non-linear relationships and generalizing beyond traditional linear approaches. Their strength lies in integrating diverse data types—such as image, audio, or textual content—and capturing sequential behaviors, such as user interactions over time, to provide contextually relevant recommendations.</li> <li>While computationally expensive and requiring significant data and expertise, the transformative capabilities of DNNs, especially when applied to large-scale datasets, make them indispensable for building state-of-the-art recommendation systems.</li> </ul> <h3 id="advantages-of-dnn-models-for-recommender-systems">Advantages of DNN Models for Recommender Systems</h3> <ol> <li> <strong>Better Generalization Beyond Linear Models</strong>: <ul> <li>DNN models excel in learning non-linear relationships, which enables them to model user-item interactions with greater complexity than traditional linear approaches.</li> </ul> </li> <li> <strong>Unified Representation of Heterogeneous Signals</strong>: <ul> <li>DNNs can integrate various forms of data into a unified representation by modeling different facets of users and items. For example, convolutional neural networks (CNNs) can process image, audio, or textual content as side information to enrich item embeddings, leading to more personalized and accurate recommendations.</li> </ul> </li> <li> <strong>Scalability with Large-Scale Data</strong>: <ul> <li>DNN models are particularly effective when applied to large-scale datasets. They leverage the volume and variety of data to learn richer, more nuanced representations and interactions.</li> </ul> </li> <li> <strong>Exploitation of Sequential Information</strong>: <ul> <li>Sequential patterns in user behavior, such as viewing, purchasing, or search history, can be captured using models like Long Short-Term Memory (LSTM) networks. These models predict the next action by analyzing sequences of past actions, improving the contextual relevance of recommendations.</li> </ul> </li> </ol> <h3 id="scenarios-where-deep-learning-may-not-be-effective">Scenarios Where Deep Learning May Not be Effective</h3> <ul> <li> <p>Despite their advantages, DNN models are not always the optimal choice, especially in scenarios where well-tuned machine learning (ML) baselines can outperform them:</p> <ol> <li> <strong>Sparse Data</strong>: <ul> <li>In situations where user-item interactions are sparse or there is limited data available for training, DNNs struggle to learn meaningful patterns. Traditional techniques like matrix factorization or simpler ML algorithms can be more effective and less prone to overfitting.</li> </ul> </li> <li> <strong>Low-Volume Data</strong>: <ul> <li>DNNs require large amounts of data to train effectively. When datasets are small, models like gradient-boosted trees or logistic regression, which require less data and are less computationally intensive, can outperform DNNs. Additionally, DNNs are more prone to overfitting in low-volume data scenarios, leading to poor generalization on unseen data.</li> </ul> </li> <li> <strong>Homogeneous Data</strong>: <ul> <li>When the data is relatively uniform or lacks diverse signals (e.g., only numerical features without contextual data like images or text), the added complexity of DNNs is often unnecessary. Well-tuned linear models or tree-based methods can achieve comparable performance with lower computational overhead.</li> </ul> </li> </ol> </li> </ul> <h3 id="common-variations-of-neural-building-blocks">Common Variations of Neural Building Blocks</h3> <ol> <li> <strong>Feedforward Neural Networks (FFNNs):</strong> <ul> <li>FNNs are a type of ANN where information flows in a unidirectional manner from one layer to the next.</li> <li>Multilayer perceptrons (MLPs) are specific types of FNNs that consist of at least three layers: an input layer, one or more hidden layers, and an output layer.</li> <li>MLPs are versatile and can be applied to a wide range of scenarios.</li> </ul> </li> <li> <strong>Convolutional Neural Networks (CNNs):</strong> <ul> <li>CNNs, known for their prowess in image processing tasks, employ convolutional operations to extract meaningful features from input data.</li> <li>In recommendation systems, CNNs can be used to process side information such as item images, audio previews, or text descriptions.</li> </ul> </li> <li> <strong>Recurrent Neural Networks (RNNs):</strong> <ul> <li>Designed for sequential data, RNNs capture temporal dependencies and are used for tasks such as predicting user behavior based on past actions.</li> <li>Variants like LSTMs are particularly adept at handling longer-term dependencies in sequences, and model sequential recommendations.</li> </ul> </li> </ol> <h3 id="applications-in-recommendation-systems">Applications in Recommendation Systems</h3> <ul> <li>Deep learning models build upon traditional recommendation techniques, such as collaborative filtering, by employing embeddings to represent categorical variables like users or items. These embeddings place similar users or items closer together in a vector space, facilitating better predictions. For instance, a deep learning approach to collaborative filtering can learn user and item embeddings from their interaction history using neural networks.</li> <li>These models benefit from advanced network architectures and optimization algorithms, which enable efficient training on large datasets.</li> </ul> <h2 id="wide-and-deep-2016">Wide and Deep (2016)</h2> <p><img src="https://aman.ai/recsys/assets/architectures/wd.webp" alt=""></p> <ul> <li>While <a href="https://aman.ai/recsys/architectures/#neural-collaborative-filtering--ncf-2017" rel="external nofollow noopener" target="_blank">neural collaborative filtering (NCF)</a> revolutionized the domain of recommender systems, it lacks an important ingredient that turned out to be extremely important for the success of recommenders: cross features. The idea of cross features was first popularized in Google’s 2016 paper <a href="https://arxiv.org/abs/1606.07792" rel="external nofollow noopener" target="_blank">Wide &amp; Deep Learning for Recommender Systems</a> by Cheng et al.</li> <li> <strong>Wide and Deep model architectures</strong> in recommender systems combine a linear model for the “wide” part, which captures <a href="https://aman.ai/recsys/architectures/#what-are-feature-crosses-and-why-are-they-important" rel="external nofollow noopener" target="_blank">cross-feature interactions</a> that models nonlinear interactions between the original features, with a NCF model for the “deep” part, which learns complex feature relationships and interactions. This hybrid approach balances memorization and generalization by capturing both specific feature combinations and broader patterns in the data.</li> </ul> <h3 id="background-cross-features">Background: Cross Features</h3> <h4 id="what-are-feature-crosses-and-why-are-they-important">What are Feature Crosses and Why are They Important?</h4> <ul> <li>A cross feature is a second-order feature (i.e., a cross-product transformation) that is created by “crossing” two sparse/categorical features (using the multiplication operation), thus modeling the interactive effects between the two features. Cross features capture nonlinear interactions between the original features, allowing the model to account for relationships that linear models would miss. In real-world problems, features often interact, meaning the effect of one feature on the output depends on the value of another feature.</li> <li>By modeling these interactions, cross features allow recommender systems to capture more complex relationships in the data, improving recommendations and ultimately, user engagement.</li> <li>For example, in an ad-click prediction system, consider the device type and time of day as two features. Their interaction could significantly affect the likelihood of a user clicking on an ad. For instance, users may be more likely to click on ads from their mobile device during evening hours when they are casually browsing, compared to when they are at work on a computer during the day. Such nonlinear interactions between these original features can be effectively modeled and captured through cross features, enabling the system to make more accurate predictions.</li> <li> <p>As another example, in the Google Play Store, first-order features include the impressed app, or the list of user-installed apps. These two can be combined to create powerful cross features, such as:</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> &lt;span&gt;AND&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;user_installed_app&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'netflix'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;impression_app&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'hulu'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
</code></pre></div> </div> <ul> <li>which is 1 if the user has Netflix installed <em>and</em> the impressed app is Hulu.</li> </ul> </li> <li> <p>Cross features can also be more coarse-grained, such as:</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> &lt;span&gt;AND&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;user_installed_category&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'video'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;impression_category&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'video'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
</code></pre></div> </div> <ul> <li>which is 1 if the user installed video apps before <em>and</em> the impressed app is a video app as well. The authors argue that adding cross features of different granularities enables both memorization (from more granular crosses) and generalization (from less granular crosses).</li> </ul> </li> <li>As another example (<a href="https://www.tensorflow.org/recommenders/examples/dcn" rel="external nofollow noopener" target="_blank">source</a>), imagine we are building a recommender system to sell a “blender” to customers. A customer’s past purchase history, such as <code class="language-plaintext highlighter-rouge">purchased_bananas</code> and <code class="language-plaintext highlighter-rouge">purchased_cooking_books</code>, or geographic features, are single features. If a customer has purchased both bananas and cooking books, then this customer will more likely click on the recommended blender. The combination of <code class="language-plaintext highlighter-rouge">purchased_bananas</code> and <code class="language-plaintext highlighter-rouge">purchased_cooking_books</code> is referred to as a feature cross, which provides additional interaction information beyond the individual features.</li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/Cross.gif" alt=""></p> <h4 id="what-are-the-challenges-in-learning-feature-crosses">What are the Challenges in Learning Feature Crosses?</h4> <ul> <li>In web-scale applications, data is mostly categorical, leading to a large and sparse feature space. Identifying effective feature crosses in this setting often requires manual feature engineering or exhaustive search.</li> <li>Traditional feed-forward multilayer perceptron (MLP) models are universal function approximators; however, they cannot efficiently approximate even 2nd or 3rd-order feature crosses (<a href="https://arxiv.org/pdf/2008.13535.pdf" rel="external nofollow noopener" target="_blank">Wang et al. (2020)</a>, <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/18fa88ad519f25dc4860567e19ab00beff3f01cb.pdf" rel="external nofollow noopener" target="_blank">Beutel et al. (2018)</a>).</li> </ul> <h3 id="motivation">Motivation</h3> <ul> <li>Generalized linear models with nonlinear feature transformations are widely used for large-scale regression and classification problems with sparse inputs. Memorization of feature interactions through a wide set of cross-product feature transformations are effective and interpretable, while generalization requires more feature engineering effort. However, memorization and generalization are both important for recommender systems. With less feature engineering, deep neural networks can generalize better to unseen feature combinations through low-dimensional dense embeddings learned for the sparse features. However, deep neural networks with embeddings can over-generalize and recommend less relevant items when the user-item interactions are sparse and high-rank.</li> </ul> <blockquote> <p>The Wide and Deep architecture demonstrated the critical importance of cross features, that is, second-order features that are created by crossing two of the original features. It combines a wide (and shallow) module for cross features with a deep (and narrow) module much like <a href="https://aman.ai/recsys/architectures/#neural-collaborative-filtering-2017" rel="external nofollow noopener" target="_blank">NCF</a>. It seeks to obtain the best of both worlds by combining the unique strengths of wide and deep models, i.e., memorization and generalization respectively, thus enabling better recommendations.</p> </blockquote> <ul> <li>Wide and Deep learning jointly train wide linear models and deep neural networks – to combine the benefits of memorization and generalization for recommender systems. Wide linear models can effectively memorize sparse feature interactions using cross-product feature transformations, while deep neural networks can generalize to previously unseen feature interactions through low dimensional embeddings.</li> </ul> <h3 id="architecture">Architecture</h3> <blockquote> <p><strong>Wide part:</strong> The wide part of the model is a generalized linear model that takes into account cross-product feature transformations, in addition to the original features. The cross-product transformations capture interactions between categorical features. For example, if you were building a real estate recommendation system, you might include a cross-product transformation of <code class="language-plaintext highlighter-rouge">city=San Francisco</code> AND <code class="language-plaintext highlighter-rouge">type=condo</code>. These cross-product transformations can effectively capture specific, niche rules, offering the model the benefit of <strong>memorization</strong>.</p> </blockquote> <blockquote> <p><strong>Deep part:</strong> The deep part of the model is a feed-forward neural network that takes all features as input, both categorical and continuous. However, categorical features are typically transformed into embeddings first, as neural networks work with continuous data. The deep part of the model excels at generalizing patterns from the data to unseen examples, offering the model the benefit of <strong>generalization</strong>.</p> </blockquote> <ul> <li>As a recap, a Generalized Linear Model (GLM) is a flexible generalization of ordinary linear regression that allows for response/outcome variables to have error distribution models other than a normal distribution. GLMs are used to model relationships between a response/outcome variable and one or more predictor variables. Examples of GLMs include logistic regression (used for binary outcomes like pass/fail), Poisson regression (for count data), and linear regression (for continuous data with a normal distribution).</li> <li>As an example <a href="https://blog.research.google/2016/06/wide-deep-learning-better-together-with.html" rel="external nofollow noopener" target="_blank">(source)</a>, say you’re trying to offer food/beverage recommendations based on an input query. People looking for specific items like “iced decaf latte with nonfat milk” really mean it. Just because it’s pretty close to “hot latte with whole milk” in the embedding space doesn’t mean it’s an acceptable alternative. Similarly, there are millions of these rules where the transitivity (a relation between three elements such that if it holds between the first and second and it also holds between the second and third, it must necessarily hold between the first and third) of embeddings may actually do more harm than good.</li> <li>On the other hand, queries that are more exploratory like “seafood” or “italian food” may be open to more generalization and discovering a diverse set of related items.</li> </ul> <blockquote> <p>Building upon the food recommendation example earlier, as shown in the graph below <a href="https://blog.research.google/2016/06/wide-deep-learning-better-together-with.html" rel="external nofollow noopener" target="_blank">(source)</a>, sparse features like <code class="language-plaintext highlighter-rouge">query="fried chicken"</code> and <code class="language-plaintext highlighter-rouge">item="chicken fried rice"</code> are used in both the wide part (left) and the deep part (right) of the model.</p> </blockquote> <p><img src="https://aman.ai/images/papers/Wide&amp;Deep2.jpg" alt=""></p> <ul> <li>For the wide component utilizing a generalized linear model, cross-product transformations are carried out on the binary features (e.g., <code class="language-plaintext highlighter-rouge">AND(gender=female, language=en)</code>) is 1 if and only if the constituent features (<code class="language-plaintext highlighter-rouge">gender=female</code> and <code class="language-plaintext highlighter-rouge">language=en</code>) are all 1, and 0 otherwise. This captures the interactions between the binary features, and adds non-linearity to the generalized linear model.</li> <li>For the deep component utilizing a feed-forward neural network, each of the sparse, high-dimensional categorical features are first converted into a low-dimensional, dense real-valued vector, often referred to as an embedding vector. The dimensionality of the embeddings are usually on the order of O(10) to O(100). The embedding vectors are initialized randomly and then the values are trained to minimize the final loss function during model training.</li> <li>During training, the prediction errors are backpropagated to both sides to train the model parameters, i.e., the two models function as one “cohesive” architecture and are trained jointly with the same loss function.</li> <li>The figure below from the paper shows how Wide and Deep models form a sweet middle compared to just Wide and just Deep models:</li> </ul> <p><img src="https://aman.ai/images/papers/Wide&amp;Deep.jpg" alt=""></p> <ul> <li>Thus, the key architectural choice in Wide and Deep is to have both a wide module, which is a linear model that takes all cross features directly as inputs, and a deep module, which is essentially an <a href="https://aman.ai/recsys/architectures/#neural-collaborative-filtering-2017" rel="external nofollow noopener" target="_blank">NCF</a>, and then combine both modules into a single output task head that learns from user/app engagements. The architectural diagram below <a href="https://medium.com/better-ml/recsys-model-serving-model-architectures-serving-1b5f038848bd" rel="external nofollow noopener" target="_blank">(source)</a> showcases this structure.</li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/4.jpg" alt=""></p> <ul> <li>By combining these two components, Wide and Deep models aim to achieve a balance between memorization and generalization, which can be particularly useful in recommendation systems, where both aspects can be important. The wide part can capture specific item combinations that a particular user might like (based on historical data), while the deep part can generalize from user behavior to recommend items that the user hasn’t interacted with yet but might find appealing based on their broader preferences. Put simply, Wide and Deep architectures combine a deep neural network component for capturing complex patterns and a wide component using a generalized linear model that models feature interactions explicitly. This allows the model to learn both deep representations and exploit feature interactions, providing a balance between memorization and generalization.</li> <li> <p>In the Wide &amp; Deep Learning model, both the wide and deep components handle sparse features, but in different ways:</p> <ol> <li> <strong>Wide Component</strong>: <ul> <li>The wide component is a generalized linear model that uses raw input features and transformed features.</li> <li>An important transformation in the wide component is the cross-product transformation. This is particularly useful for binary features, where a cross-product transformation like <code class="language-plaintext highlighter-rouge">AND(gender=female language=en)</code> is 1 if and only if both constituent features are 1, and 0 otherwise.</li> <li>Such transformations capture the interactions between binary features and add non-linearity to the generalized linear model.</li> </ul> </li> <li> <strong>Deep Component</strong>: <ul> <li>The deep component is a feed-forward neural network.</li> <li>For handling categorical features, which are often sparse and high-dimensional, the deep component first converts these features into low-dimensional, dense real-valued vectors, commonly referred to as embedding vectors. The dimensionality of these embeddings usually ranges from 10 to 100.</li> <li>These dense embedding vectors are then fed into the hidden layers of the neural network. The embeddings are initialized randomly and trained to minimize the final loss function during model training.</li> </ul> </li> <li> <strong>Combined Model</strong>: <ul> <li>The wide and deep components are combined using a weighted sum of their output log odds, which is then fed to a common logistic loss function for joint training.</li> <li>In this combined model, the wide part focuses on memorization (exploiting explicit feature interactions), while the deep part focuses on generalization (learning implicit feature representations).</li> <li>The combined model ensures that both sparse and dense features are effectively utilized, with sparse features often transformed into dense representations for efficient processing in the deep neural network.</li> </ul> </li> </ol> </li> </ul> <h3 id="example">Example</h3> <ul> <li>As an example, let’s consider a music recommendation app using the Wide and Deep Learning model, the input features for both the wide and deep components would be tailored to capture different aspects of user preferences and characteristics of the music items. Let’s consider what these inputs might look like.</li> </ul> <h4 id="input-to-the-wide-component">Input to the Wide Component</h4> <ul> <li> <p>The wide component would primarily use sparse, categorical features, possibly transformed to capture specific interactions:</p> <ol> <li> <strong>User Features</strong>: Demographics (age, gender, location), user ID, historical user behavior (e.g., genres listened to frequently, favorite artists).</li> <li> <strong>Music Item Features</strong>: Music genre, artist ID, album ID, release year.</li> <li> <strong>Cross-Product Transformations</strong>: Combinations of categorical features that are believed to interact in meaningful ways. For instance, “user’s favorite genre = pop” AND “music genre = pop”, or “user’s location = USA” AND “artist’s origin = USA”. These cross-products help capture interaction effects that are specifically relevant to music recommendations.</li> </ol> </li> </ul> <h4 id="input-to-the-deep-component">Input to the Deep Component</h4> <ul> <li> <p>The deep component would use both dense and sparse features, with sparse features transformed into dense embeddings:</p> <ol> <li> <strong>User Features (as Embeddings)</strong>: Embeddings for user ID, embedding vectors for historical preferences (like a vector summarizing genres listened to), demographics if treated as categorical.</li> <li> <strong>Music Item Features (as Embeddings)</strong>: Embeddings for music genre, artist ID, album ID. These embeddings capture the nuanced relationships in the music domain.</li> <li> <strong>Additional Dense Features</strong>: If available, numerical features like the number of times a song has been played, user’s average listening duration, or ratings given by the user.</li> </ol> </li> <li> <p>The embeddings created to serve as the input to the Dense component are “learned embeddings” or “trainable embeddings,” as they are learned directly from the data during the training process of the model.</p> </li> <li> <p>Here’s a Python code snippet using TensorFlow to illustrate how a categorical feature (like user IDs) is embedded:</p> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;span&gt;import&lt;/span&gt; &lt;span&gt;tensorflow&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;tf&lt;/span&gt;

&lt;span&gt;# Assuming we have 10,000 unique users and we want to embed them into a 64-dimensional space
&lt;/span&gt;&lt;span&gt;num_unique_users&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;
&lt;span&gt;embedding_dimension&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;64&lt;/span&gt;

&lt;span&gt;# Create an input layer for user IDs (assuming user IDs are integers ranging from 0 to 9999)
&lt;/span&gt;&lt;span&gt;user_id_input&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;tf&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;keras&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Input&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;shape&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,),&lt;/span&gt; &lt;span&gt;dtype&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'int32'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Create an embedding layer
&lt;/span&gt;&lt;span&gt;user_embedding_layer&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;tf&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;keras&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;layers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Embedding&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;input_dim&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;num_unique_users&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; 
                                                 &lt;span&gt;output_dim&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;embedding_dimension&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; 
                                                 &lt;span&gt;input_length&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; 
                                                 &lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'user_embedding'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Apply the embedding layer to the user ID input
&lt;/span&gt;&lt;span&gt;user_embedding&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;user_embedding_layer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;user_id_input&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Flatten the embedding output to feed into a dense layer
&lt;/span&gt;&lt;span&gt;user_embedding_flattened&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;tf&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;keras&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;layers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Flatten&lt;/span&gt;&lt;span&gt;()(&lt;/span&gt;&lt;span&gt;user_embedding&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Add a dense layer (more layers can be added as needed)
&lt;/span&gt;&lt;span&gt;dense_layer&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;tf&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;keras&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;layers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Dense&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;activation&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'relu'&lt;/span&gt;&lt;span&gt;)(&lt;/span&gt;&lt;span&gt;user_embedding_flattened&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Create a model
&lt;/span&gt;&lt;span&gt;model&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;tf&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;keras&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Model&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;inputs&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;user_id_input&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;outputs&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;dense_layer&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Compile the model
&lt;/span&gt;&lt;span&gt;model&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;compile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;optimizer&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'adam'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;loss&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'mse'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# Adjust the loss based on your specific task
&lt;/span&gt;
&lt;span&gt;# Model summary
&lt;/span&gt;&lt;span&gt;model&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;
</code></pre></div></div> <p>In this code:</p> <ul> <li>We first define the number of unique users (<code class="language-plaintext highlighter-rouge">num_unique_users</code>) and the dimensionality of the embedding space (<code class="language-plaintext highlighter-rouge">embedding_dimension</code>).</li> <li>An input layer is created to accept user IDs.</li> <li>An embedding layer (<code class="language-plaintext highlighter-rouge">tf.keras.layers.Embedding</code>) is added to transform each user ID into a 64-dimensional vector. This layer is set to be trainable, meaning its weights (the embeddings) are learned during training.</li> <li>The embedding layer’s output is then flattened and passed through a dense layer for further processing.</li> <li> <p>The model is compiled with an optimizer and loss function, which should be chosen based on the specific task (e.g., classification, regression).</p> </li> <li>This code example demonstrates how to create trainable embeddings for a categorical feature within a neural network using TensorFlow. These embeddings are specifically tailored to the data and task at hand, learning to represent each category (in this case, user IDs) in a way that is useful for the model’s predictive task.</li> </ul> <h3 id="combining-inputs-in-wide--deep-model">Combining Inputs in Wide &amp; Deep Model</h3> <ul> <li> <strong>Joint Model</strong>: The wide and deep components are joined in a unified model. The wide component helps with memorization of explicit feature interactions (especially useful for categorical data), while the deep component contributes to generalization by learning implicit patterns and relationships in the data.</li> <li> <strong>Feature Transformation</strong>: Sparse features are more straightforwardly handled in the wide part through cross-product transformations, while in the deep part, they are typically converted into dense embeddings.</li> <li> <p><strong>Model Training</strong>: Both parts are trained jointly, allowing the model to leverage the strengths of both memorization and generalization.</p> </li> <li>As an example, in a music recommendation app, this combination allows the model to not only consider obvious interactions (like a user’s past preferences for certain genres or artists) but also to uncover more subtle patterns and relationships within the data, which might not be immediately apparent but are influential in determining a user’s music preferences.</li> </ul> <h3 id="results">Results</h3> <ul> <li>They productionized and evaluated the system on Google Play Store, a massive-scale commercial mobile app store with over one billion active users and over one million apps. Online experiment results show that Wide and Deep significantly increased app acquisitions compared with wide-only and deep-only models.</li> <li>Compared to a deep-only model, Wide and Deep improved acquisitions in the Google Play store by 1%. Consider that Google makes tens of billions in revenue each year from its Play Store, and it’s easy to see how impactful Wide and Deep was.</li> </ul> <h3 id="summary">Summary</h3> <ul> <li> <strong>Architecture</strong>: The Wide and Deep model in recommendation systems incorporates cross features, particularly in the “wide” component of the model. The wide part is designed for memorization and uses linear models with cross-product feature transformations, effectively capturing interactions between categorical features. This is crucial for learning specific, rule-based information, which complements the “deep” part of the model that focuses on generalization through deep neural networks. By combining these approaches, Wide and Deep models effectively capture both simple, rule-based patterns and complex, non-linear relationships within the data.</li> <li> <strong>Pros:</strong> Balances memorization (wide component) and generalization (deep component), capturing both complex patterns and explicit feature interactions.</li> <li> <strong>Cons:</strong> Increased model complexity and potential challenges in training and optimization.</li> <li> <strong>Advantages:</strong> Improved performance by leveraging both deep representations and explicit feature interactions.</li> <li> <strong>Example Use Case:</strong> E-commerce platforms where a combination of user behavior and item features plays a crucial role in recommendations.</li> <li> <strong>Phase:</strong> Ranking.</li> <li> <strong>Recommendation Workflow:</strong> Given it’s complexity, the deep and wide architecture is suitable for the ranking phase. The wide component can capture explicit feature interactions and enhance the candidate generation process. The deep component allows for learning complex patterns and interactions, improving the ranking of candidate items based on user-item preferences.</li> </ul> <h2 id="factorization-machines--fm-2010">Factorization Machines / FM (2010)</h2> <ul> <li>Factorization Machines (FM), introduced in <a href="https://analyticsconsultores.com.mx/wp-content/uploads/2019/03/Factorization-Machines-Steffen-Rendle-Osaka-University-2010.pdf" rel="external nofollow noopener" target="_blank">Rendle (2010)</a>, extend the traditional matrix factorization (MF) model to handle high-dimensional sparse input data and model pairwise interactions between features.</li> </ul> <blockquote> <p>Unlike MF, which is limited to user-item interaction matrices, the FM architecture is particularly effective for incorporating high-dimensional side information/contextual features, (such as user demographics, item attributes, or temporal context) along with sparse user-item interactions.</p> </blockquote> <ul> <li> <p>The key innovation of FM lies in its ability to generalize matrix factorization by learning pairwise feature interactions across any set of features, not just users and items. It achieves this through a latent factorization of feature interactions, representing each feature as a low-dimensional embedding. For example, in a movie recommendation system, FM can model interactions like <code class="language-plaintext highlighter-rouge">user-movie</code>, <code class="language-plaintext highlighter-rouge">user-genre</code>, or <code class="language-plaintext highlighter-rouge">user-age</code> in a unified framework.</p> </li> <li> <p>FM models second-order interactions between features in a latent space, making it more expressive than linear models while being computationally efficient. It computes these interactions efficiently using factorized parameters, avoiding the computational cost of explicitly enumerating all feature pairs, which would otherwise be infeasible in large-scale systems.</p> </li> <li> <p>FM works exceptionally well with sparse, high-dimensional data, a common trait in recommendation systems and click-through rate prediction tasks. Its design allows it to handle such data effectively, ensuring scalability without sacrificing predictive accuracy.</p> </li> <li> <p>Unlike traditional matrix factorization, FM can incorporate arbitrary features beyond user and item IDs, including metadata or contextual signals. This flexibility makes it suitable for a wide range of applications where additional information can enhance predictions.</p> </li> <li> <p>The FM model predicts the interaction score y^ for a given feature vector x as:</p> <p>y^=w0+∑i=1nwixi+∑i=1n∑j=i+1n⟨vi,vj⟩xixj</p> <ul> <li>where, <ul> <li>w0: Global bias term.</li> <li>wi: Weight for each feature xi.</li> <li>⟨vi,vj⟩: Dot product of latent vectors vi and vj, representing the interaction between features xi and xj.</li> </ul> </li> </ul> </li> <li> <p>The following figure from the paper shows an example of sparse, real-valued feature vectors x, created from transactions in a recommendation system. Each row represents a feature vector x(i) with its corresponding target y(i) (e.g., a user’s rating of a movie):</p> <ul> <li> <strong>Blue Columns:</strong> Indicator variables for the active user.</li> <li> <strong>Red Columns:</strong> Indicator variables for the active item (e.g., the movie being rated).</li> <li> <strong>Yellow Columns:</strong> Implicit indicators for other items the user has rated (e.g., related movies).</li> <li> <strong>Green Column:</strong> A real-valued feature representing the time (e.g., in months).</li> <li> <strong>Brown Columns:</strong> Indicator variables for the last item the user rated before the active one.</li> <li> <strong>Rightmost Column:</strong> The target variable (e.g., the user’s rating).</li> <li>This example demonstrates FM’s ability to process diverse types of contextual and historical information, enabling it to learn complex patterns and relationships from these interactions.</li> </ul> </li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/FM.jpg" alt=""></p> <ul> <li>FM’s structure makes it ideal for handling datasets where feature interactions are critical but the data is sparse, such as in recommender systems, advertising, and search.</li> </ul> <h3 id="summary-1">Summary</h3> <ul> <li> <strong>Pros:</strong> <ul> <li>Handles both structured and unstructured features.</li> <li>Scalable for high-dimensional sparse datasets.</li> <li>Provides a unified framework for incorporating contextual information.</li> </ul> </li> <li> <strong>Cons:</strong> <ul> <li>Limited to modeling pairwise interactions; higher-order interactions require extensions or integration with deep learning models.</li> <li>May not capture non-linear interactions as effectively as deep learning-based approaches.</li> </ul> </li> <li> <strong>Example Use Case:</strong> CTR prediction, recommendation systems, and search ranking.</li> <li> <strong>Phase:</strong> Candidate Generation, Ranking.</li> <li> <strong>Recommendation Workflow:</strong> FM is commonly used in the ranking phase, where it effectively models pairwise feature interactions for personalized recommendations or ad targeting.</li> </ul> <h2 id="deep-factorization-machine--deepfm-2017">Deep Factorization Machine / DeepFM (2017)</h2> <ul> <li>Similar to Google’s <a href="https://aman.ai/recsys/architectures/#deep-and-cross-networks--dcn-2017" rel="external nofollow noopener" target="_blank">DCN</a>, Huawei’s DeepFM, as introduced in <a href="https://arxiv.org/abs/1703.04247" rel="external nofollow noopener" target="_blank">Guo et al. (2017)</a>, also replaces manual feature engineering in the wide component of the Wide and Deep model with a specialized neural network that learns cross features. However, unlike DCN, the wide component in DeepFM is not a cross neural network but instead utilizes a factorization machine (FM) layer.</li> </ul> <blockquote> <p>What is the role of the FM layer? It computes the dot products of all pairs of embeddings. For example, in a movie recommender system with four id-features as inputs, such as user id, movie id, actor ids, and director id, the FM layer calculates six dot products. These correspond to the combinations <code class="language-plaintext highlighter-rouge">user-movie</code>, <code class="language-plaintext highlighter-rouge">user-actor</code>, <code class="language-plaintext highlighter-rouge">user-director</code>, <code class="language-plaintext highlighter-rouge">movie-actor</code>, <code class="language-plaintext highlighter-rouge">movie-director</code>, and <code class="language-plaintext highlighter-rouge">actor-director</code>. The output from the FM layer is concatenated with the output from the deep component and passed through a sigmoid layer to generate the model’s predictions.</p> </blockquote> <blockquote> <p>It is important to note that DeepFM, much like <a href="https://aman.ai/recsys/architectures/#deep-and-cross-networks--dcn-2017" rel="external nofollow noopener" target="_blank">DCN</a>, employs a brute-force method by considering all possible feature combinations uniformly (i.e., calculating all pairwise interactions). In contrast, more recent approaches such as <a href="https://aman.ai/recsys/architectures/#autoint-2019" rel="external nofollow noopener" target="_blank">AutoInt</a> utilize self-attention mechanisms to automatically determine the most relevant feature interactions, effectively identifying which interactions are most significant (and ignoring others by setting their attention weights to zero).</p> </blockquote> <ul> <li>The figure below, taken from the paper, illustrates the architecture of DeepFM. Both the wide and deep components share the same raw feature vector as input, allowing DeepFM to simultaneously learn both low- and high-order feature interactions from the input data. Notably, in the figure, there is a circle labeled “+” in the FM layer alongside the inner products. This functions as a skip connection, directly passing the concatenated inputs to the output unit.</li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/dfm.webp" alt=""></p> <ul> <li> <p>The authors demonstrate that DeepFM outperforms several competitors, including Google’s Wide and Deep model, by more than 0.42% in Logloss on internal company data.</p> </li> <li> <p>DeepFM replaces the cross neural network in DCN with factorization machines, specifically employing dot products for feature interactions.</p> </li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/5.webp" alt=""></p> <ul> <li>DeepFM integrates FM with deep neural networks. The FM component models pairwise feature interactions, while the deep neural network captures higher-order feature interactions. This combined architecture effectively exploits both linear and non-linear relationships between features.</li> </ul> <h3 id="summary-2">Summary</h3> <ul> <li> <strong>Pros:</strong> Combines the benefits of FM and deep neural networks, capturing both pairwise and higher-order feature interactions. In other words, accurate modeling of both linear and non-linear relationships between features, providing a comprehensive understanding of feature interactions.</li> <li> <strong>Cons:</strong> <ul> <li>DeepFM creates feature crosses in a brute-force way, simply by considering all possible combinations. This is not only inefficient, it could also create feature crosses that aren’t helpful at all, and just make the model overfit.</li> <li>Increased model complexity and potential challenges in training and optimization.</li> </ul> </li> <li> <strong>Example Use Case:</strong> Click-through rate prediction in online advertising or personalized recommendation systems.</li> <li> <strong>Phase:</strong> Candidate Generation, Ranking.</li> <li> <strong>Recommendation Workflow:</strong> DeepFM is commonly utilized in both the candidate generation and ranking phases. It combines the strengths of factorization machines and deep neural networks. In the candidate generation phase, DeepFM can capture pairwise feature interactions efficiently. In the ranking phase, it can leverage deep neural networks to model higher-order feature interactions and improve the ranking of candidate items.</li> </ul> <h2 id="neural-collaborative-filtering--ncf-2017">Neural Collaborative Filtering / NCF (2017)</h2> <ul> <li>The integration of deep learning into recommender systems witnessed a significant breakthrough with the introduction of Neural Collaborative Filtering (NCF), introduced in <a href="https://arxiv.org/abs/1708.05031" rel="external nofollow noopener" target="_blank">He et. al (2017)</a> from NUS Singapore, Columbia University, Shandong University, and Texas A&amp;M University.</li> <li>This innovative approach marked a departure from the (then standard) matrix factorization method. Prior to NCF, the gold standard in recommender systems was matrix factorization, which relied on learning latent vectors (a.k.a. embeddings) for both users and items, and then generate recommendations for a user by taking the dot product between the user vector and the item vectors. The closer the dot product is to 1, the better the match. As such, matrix factorization can be simply viewed as a linear model of latent factors.</li> </ul> <blockquote> <p>The key idea behind NCF is to substitute the inner product in matrix factorization with a neural network architecture to that can learn an arbitrary non-linear function from data. To supercharge the learning process of the user-item interaction function with non-linearities, they concatenated user and item embeddings, and then fed them into a multi-layer perceptron (MLP) with a single task head predicting user engagement, like clicks. Both MLP weights and embedding weights (which user/item IDs are mapped to) were learned through backpropagation of loss gradients during model training.</p> </blockquote> <ul> <li>The hypothesis underpinning NCF posits that user-item interactions are non-linear, contrary to the linear assumption in matrix factorization.</li> <li>The figure below from the paper illustrates the neural collaborative filtering framework.</li> </ul> <p><img src="https://aman.ai/images/papers/NCF.jpg" alt=""></p> <ul> <li>NCF proved the value of replacing (then standard) linear matrix factorization algorithms with a neural network. With a relatively simply 4-layer neural network, NCF proved that there’s immense value of applying deep neural networks in recommender systems, marking the pivotal transition away from matrix factorization and towards deep recommenders. They were able to beat the best matrix factorization algorithms at the time by 5% hit rate on the Movielens and Pinterest benchmark datasets. Empirical evidence showed that using deeper layers of neural networks offers better recommendation performance.</li> <li>Despite its revolutionary impact, NCF lacked an important ingredient that turned out to be extremely important for the success of recommenders: cross features, a concept popularized by the <a href="https://aman.ai/recsys/architectures/#wide-and-deep-2016" rel="external nofollow noopener" target="_blank">Wide &amp; Deep</a> paper described above.</li> </ul> <h3 id="summary-3">Summary</h3> <ul> <li>NCF proved the value of replacing (then standard) linear matrix factorization algorithms with a neural network.</li> <li>The NCF framework, which is both generic and capable of expressing and generalizing matrix factorization, utilized a multi-layer perceptron to imbue the model with non-linear capabilities.</li> <li>With a relatively simple 4-layer neural network, they were able to beat the best matrix factorization algorithms at the time by 5% hit rate on the Movielens and Pinterest benchmark datasets.</li> </ul> <h2 id="deep-and-cross-networks--dcn-2017">Deep and Cross Networks / DCN (2017)</h2> <ul> <li>Wide and Deep has proven the significance of cross features, however it has a huge downside: the cross features need to be manually engineered, which is a tedious process that requires engineering resources, infrastructure, and domain expertise. Cross features à la Wide and Deep are expensive. They don’t scale.</li> <li>The key idea of Deep and Cross Networks (DCN), introduced in a <a href="https://arxiv.org/abs/1708.05123" rel="external nofollow noopener" target="_blank">Wang et al. (2017)</a> by Google is to replace the wide component in Wide and Deep with a “cross neural network,” a neural network dedicated to learning cross features of arbitrarily high order (as opposed to second-order/pairwise features in Wide and Deep Networks). However, note that DCN (similar to <a href="https://aman.ai/recsys/architectures/#deep-factorization-machine--deepfm-2017" rel="external nofollow noopener" target="_blank">DeepFM</a>) learns this in a brute-force manner simply by considering all possible combinations uniformly (i.e., it calculates all pair-wise interactions), while newer implementations such as <a href="https://aman.ai/recsys/architectures/#autoint-2019" rel="external nofollow noopener" target="_blank">AutoInt</a> leverage self-attention to automatically determine the most informative feature interactions, i.e., which feature interactions to pay the most attention to (and which to ignore by setting the attention weights to zero).</li> <li>Similar to Huawei’s <a href="https://aman.ai/recsys/architectures/#deep-factorization-machine--deepfm-2017" rel="external nofollow noopener" target="_blank">DeepFM</a>, introduced in <a href="https://arxiv.org/abs/1703.04247" rel="external nofollow noopener" target="_blank">Guo et al. (2017)</a>, DCN also replaces manual feature engineering in the wide component of Wide and Deep with a dedicated cross neural network that learns cross features. However, unlike DeepFM, the wide component is a cross neural network, instead of a so-called factorization machine layer.</li> <li> <p>DCN was designed to learn explicit and bounded-degree cross features more effectively. It starts with an input layer (typically an embedding layer), followed by a cross network containing multiple cross layers that models explicit feature interactions, and then combines with a deep network that models implicit feature interactions.</p> <ul> <li> <strong>Cross Network</strong>: This is the core of DCN, explicitly applying feature crossing at each layer, where the highest polynomial degree increases with layer depth. The cross network layers efficiently capture feature interactions by combining linear transformations, feature interactions, and residual connections. The following figure shows the (i+1)th cross layer.</li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/i1cross.png" alt=""></p> <ul> <li> <p><strong>Deep Network</strong>: A traditional deep feed-forward network, consisting of fully-connected layers that use weights, biases, and non-linear activation functions to learn abstract representations and complex patterns in the data.</p> </li> <li> <p><strong>DCN Combination</strong>: The deep and cross networks are combined to form DCN. This can be done either by placing them in parallel, as shown in the figure below.</p> </li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/dc.webp" alt=""></p> </li> <li>What makes a cross neural network different from a standard MLP? As a reminder, in an MLP, each neuron in the next layer is a linear combination of all neurons in the previous layer, plus a bias term:</li> </ul> <p>xl+1=bl+1+W⋅xl</p> <ul> <li> <p>The Cross Network helps in better generalizing on sparse features by learning explicit bounded-degree feature interactions. This is particularly useful for sparse data, where traditional deep learning models might struggle due to the high dimensionality and lack of explicit feature interaction modeling.</p> </li> <li> <p>By contrast, in the cross neural network the next layer is constructed by forming second-order (i.e., pairwise) combinations of the previous layer’s features:</p> </li> </ul> <p>xl+1=bl+1+xl+xl⋅W⋅xlT</p> <ul> <li>At the input, sparse features are transformed into dense vectors through an embedding layer while dense features are normalized. These processed features are then combined into a single vector x0, which includes the stacked embedding vectors for the sparse features and the normalized dense features. This combined vector is then fed into the network.</li> <li>Hence, a cross neural network of depth L will learn cross features in the form of polynomials of degrees up to L.</li> </ul> <blockquote> <p>The deeper the neural network, the higher the order of interactions that are learned.</p> </blockquote> <ul> <li>The unified wide and cross model architecture is training jointly with mean squared error (MSE) as it’s loss function.</li> <li> <p>For model evaluation, the Root Mean Squared Error (RMSE, the lower the better) is reported per <a href="https://www.tensorflow.org/recommenders/examples/dcn" rel="external nofollow noopener" target="_blank">TensorFlow: Deep &amp; Cross Network (DCN)</a>.</p> </li> <li>The Deep and Cross Network (DCN) introduces a novel approach to handling feature interactions and dealing with sparse features. Let’s break down how DCN accomplishes these tasks:</li> </ul> <h3 id="forming-higher-order-feature-interactions">Forming Higher-Order Feature Interactions</h3> <ul> <li> <strong>Mechanism of the Cross Network</strong>: <ul> <li> <p>In a standard MLP, each neuron in a layer is a linear combination of all neurons from the previous layer. As delineated above, this is mathematically expressed as,</p> <p>xl+1=bl+1+W⋅xl</p> <ul> <li>where xl is the input from the previous layer, W is the weight matrix, and bl+1 is the bias.</li> </ul> </li> <li> <p>However, in the Cross Network of DCN, the idea is to explicitly form higher-order interactions of features.</p> </li> </ul> </li> <li> <strong>Second-Order Combinations</strong>: <ul> <li> <p>In the Cross Network, the next layer is created by incorporating second-order (i.e., pairwise) combinations of the previous layer’s features. As delineated above, this is mathematically expressed as,</p> <p>xl+1=bl+1+xl+xl⋅W⋅xlT</p> </li> <li>This approach allows the network to automatically learn complex feature interactions (cross features) that are higher than first-order, which would be impossible in a standard MLP without manual feature engineering. Specifically, in a standard MLP, feature interactions aren’t explicitly learned unless they’re manually engineered, meaning that the model would rely on domain experts to create new features that represent interactions between the original inputs. This is both labor-intensive and non-scalable.</li> <li>However, in DCN’s Cross Network, these feature interactions—specifically higher-order ones—are learned automatically by the model itself. This removes the need for manual feature engineering, allowing the model to capture complex relationships between features more effectively and without human intervention, especially in high-dimensional or sparse data scenarios.</li> </ul> </li> </ul> <h3 id="handling-sparse-features-through-embedding-layers">Handling Sparse Features Through Embedding Layers</h3> <ul> <li> <p><strong>Sparse to Dense Transformation</strong>: Neural networks generally work better with dense input data. However, in many real-world applications, features are often sparse (like categorical data). DCN addresses this challenge by transforming sparse features into dense vectors through an embedding layer for dense embedding generation.</p> </li> <li> <p><strong>Embedding Process</strong>: Dense embedding generation enables sparse, high-dimensional data (like one-hot encoded vectors) are converted into a lower-dimensional, continuous, and dense vector. Each unique category in the sparse feature is mapped to a dense vector, and these vectors are learned during the training process. This transformation is crucial because it enables the network to work with a dense representation of the data, which is more efficient and effective for learning complex patterns.</p> </li> </ul> <h3 id="explicit-feature-crossing-and-polynomial-degree">Explicit Feature Crossing and Polynomial Degree</h3> <ul> <li> <p><strong>Explicit Feature Crossing</strong>: The Cross Network in DCN explicitly handles feature crossing at each layer, directly modeling interactions between different features instead of relying on the deep network to implicitly capture these interactions.</p> </li> <li> <p><strong>Increasing Polynomial Degree with Depth</strong>: As the Cross Network’s depth increases, the polynomial degree of feature interactions grows, allowing the model to capture more complex interactions (higher-order feature combinations).</p> </li> </ul> <blockquote> <p>Essentially, DCN learns polynomials of features (i.e., higher order features), where the degree increases with the network’s depth.</p> </blockquote> <ul> <li> <p><strong>Bounded-Degree Cross Features</strong>: The design of the Cross Network controls the degree of these polynomials through the network depth. This helps prevent excessive complexity, avoiding overfitting and ensuring computational efficiency.</p> </li> <li> <p><strong>Handling Sparse Features</strong>: DCN’s Cross Network forms higher-order feature interactions by explicitly crossing features at each layer while embedding sparse features into dense vectors, making them suitable for neural network processing. This enables automatic and efficient learning of complex feature interactions without manual feature engineering.</p> </li> <li> <p><strong>Integrating Outputs</strong>: The outputs from the Cross Network and the Deep Network are concatenated to combine their strengths.</p> </li> <li> <p><strong>Final Prediction</strong>: The concatenated vector is fed into a logits layer, which combines explicit feature interactions and deep learned representations to make the final prediction (e.g., for classification tasks).</p> </li> </ul> <h3 id="input-and-output-to-each-component">Input and Output to Each Component</h3> <ul> <li> <strong>Input to Cross and Deep Networks:</strong> Both networks take the same input vector, which is a combination of dense embeddings (from sparse features) and normalized dense features. Put siomply, embedded sparse features are concatenated with dense features and offered as input to both networks.</li> <li> <p><strong>Output:</strong> The outputs of both networks are combined in the Combination Layer for the final model output.</p> </li> <li>Based on the paper, the architecture and composition of each layer in the Cross and Deep Networks of the DCN are as follows:</li> </ul> <h3 id="cross-network-layers">Cross Network Layers</h3> <ul> <li>Each layer in the Cross Network is defined by the following formula: xl+1=x0xlTwl+bl+xl <ul> <li> <strong>Inputs and Outputs</strong>: xl and xl+1 are the outputs from the lth and (l+1)th cross layers respectively, represented as column vectors.</li> <li> <strong>Weight and Bias Parameters</strong>: Each layer has its own weight (wl) and bias (bl) parameters, which are learned during training.</li> <li> <strong>Feature Crossing Function</strong>: The feature crossing function is represented by f(xl,wl,bl), and it is designed to fit the residual of xl+1−xl. This function captures interactions between the features.</li> <li> <strong>Residual Connection</strong>: Each layer adds back its input after the feature crossing, which helps in preserving the information and building upon the previous layer’s output.</li> </ul> </li> </ul> <h3 id="deep-network-layers">Deep Network Layers</h3> <ul> <li>Each layer in the Deep Network is structured as a standard fully-connected layer and is defined by the following formula: hl+1=f(wlhl+bl) <ul> <li> <strong>Inputs and Outputs</strong>: hl and hl+1 are the lth and (l+1)th hidden layers’ outputs respectively.</li> <li> <strong>Weight and Bias Parameters</strong>: Similar to the cross layer, each deep layer has its own weight matrix (wl) and bias vector (bl).</li> <li> <strong>Activation Function</strong>: The function f(⋅) is typically a non-linear activation function, such as ReLU (Rectified Linear Unit), which introduces non-linearity into the model, allowing it to learn complex patterns in the data.</li> </ul> </li> </ul> <h3 id="results-1">Results</h3> <ul> <li>Compared to a model with just the deep component, DCN has a 0.1% statistically significant lower logloss on the Criteo display ads benchmark dataset. And that’s without any manual feature engineering, as in Wide and Deep! (It would have been nice to see a comparison between DCN and Wide and Deep. However, the authors of DCN did not have a good method to manually create cross features for the Criteo dataset, and hence skipped this comparison.)</li> <li>The DCN architecture includes a cross network component that captures cross-feature interactions. It combines a deep network with cross layers, allowing the model to learn explicit feature interactions and capture non-linear relationships between features.</li> </ul> <h3 id="summary-4">Summary</h3> <ul> <li>DCN showed that we can get even more performance gains by replacing manual engineering of cross features with an algorithmic approach that automatically creates all possible feature crosses up to any arbitrary order. Compared to Wide &amp; Deep, DCN achieved 0.1% lower logloss on the Criteo display ads benchmark dataset.</li> <li> <strong>Pros:</strong> Captures explicit high-order feature interactions and non-linear relationships through cross layers, allowing for improved modeling of complex patterns.</li> <li> <strong>Cons:</strong> <ul> <li>DCN creates feature crosses in a brute-force way, simply by considering all possible combinations. This is not only inefficient, it could also create feature crosses that aren’t helpful at all, and just make the model overfit.</li> <li>More complex than simple feed-forward networks.</li> <li>May not perform well on tasks where feature interactions aren’t important.</li> <li>Increased model complexity, potential overfitting on sparse data.</li> </ul> </li> <li> <strong>Use case:</strong> Useful for tasks where high-order feature interactions are critical, such as CTR prediction and ranking tasks.</li> <li> <strong>Example Use Case:</strong> Advertising platforms where understanding the interactions between user characteristics and ad features is essential for personalized ad targeting.</li> <li> <strong>Phase:</strong> Ranking, Final Ranking.</li> <li> <strong>Recommendation Workflow:</strong> The deep and cross architecture is typically applied in the ranking phase and the final ranking phase. The deep and cross network captures explicit feature interactions and non-linear relationships, enabling accurate ranking of candidate items based on user preferences. It contributes to the final ranking of candidate items, leveraging its ability to model complex patterns and interactions.</li> </ul> <h2 id="autoint-2019">AutoInt (2019)</h2> <ul> <li>Proposed in <a href="https://arxiv.org/abs/1810.11921" rel="external nofollow noopener" target="_blank">AutoInt: Automatic Feature Interaction Learning via Self-Attentive Neural Networks</a> by Song et al. from from Peking University and Mila-Quebec AI Institute, and HEC Montreal in CIKM 2019.</li> <li>The paper introduces AutoInt (short for “automated feature interaction learning”), a novel method for efficiently learning high-order feature interactions in an automated way. Developed to address the inefficiencies and overfitting problems in existing models like DCN and DeepFM, which create feature crosses in a brute-force manner, AutoInt leverages self-attention to determine the most informative feature interactions.</li> <li>AutoInt employs a multi-head self-attentive neural network with residual connections, designed to explicitly model feature interactions in a 16-dimensional embedding space. It overcomes the limitations of prior models by focusing on relevant feature combinations, avoiding unnecessary and unhelpful feature crosses.</li> <li> <strong>Processing Steps</strong>: <ol> <li> <strong>Input Layer</strong>: Represents user profiles and item attributes as sparse vectors.</li> <li> <strong>Embedding Layer</strong>: Projects each feature into a 16-dimensional space.</li> <li> <strong>Interacting Layer</strong>: Utilizes several multi-head self-attention layers to automatically identify the most informative feature interactions. The attention mechanism is based on dot product for its effectiveness in capturing feature interactions.</li> <li> <strong>Output Layer</strong>: Uses the learned feature interactions for CTR estimation.</li> </ol> </li> <li>The goal of AutoInt is to map the original sparse and high-dimensional feature vector into low-dimensional spaces and meanwhile model the high-order feature interactions. As shown in the below figure, AutoInt takes the sparse feature vector x as input, followed by an embedding layer that projects all features (i.e., both categorical and numerical features) into the same low-dimensional space. Next, embeddings of all fields are fed into a novel interacting layer, which is implemented as a multi-head self-attentive neural network. For each interacting layer, high-order features are combined through the attention mechanism, and different kinds of combinations can be evaluated with the multi-head mechanisms, which map the features into different subspaces. By stacking multiple interacting layers, different orders of combinatorial features can be modeled. The output of the final interacting layer is the low-dimensional representation of the input feature, which models the high-order combinatorial features and is further used for estimating the clickthrough rate through a sigmoid function. The figure below from the paper shows an overview of AutoInt.</li> </ul> <p><img src="https://aman.ai/images/papers/autoint.png" alt=""></p> <ul> <li>The figure below from the paper illustrates the input and embedding layer, where both categorical and numerical fields are represented by low-dimensional dense vectors.</li> </ul> <p><img src="https://aman.ai/images/papers/autoint2.jpg" alt=""></p> <ul> <li>AutoInt demonstrates superior performance over competitors like Wide and Deep and DeepFM on benchmark datasets like MovieLens and Criteo, thanks to its efficient handling of feature interactions.</li> <li>The technical innovations in AutoInt consist of: (i) introduction of multi-head self-attention to learn which cross features really matter, replacing the brute-force generation of all possible feature crosses, and (ii) the model’s ability to learn important feature crosses such as <code class="language-plaintext highlighter-rouge">Genre-Gender</code>, <code class="language-plaintext highlighter-rouge">Genre-Age</code>, and <code class="language-plaintext highlighter-rouge">RequestTime-ReleaseTime</code>, which are crucial for accurate CTR prediction.</li> <li>AutoInt showcases efficiency in processing large-scale, sparse, high-dimensional data, with a stack of 3 attention layers, each having 2 heads. The attention mechanism improves model explainability by highlighting relevant feature interactions, as exemplified in the attention matrix learned on the MovieLens dataset.</li> <li>AutoInt addresses the need for a model that is both powerful in capturing complex interactions and interpretable in its recommendations, without the inefficiency and overfitting issues seen in models that generate feature crosses in a brute-force manner.</li> </ul> <h3 id="summary-5">Summary</h3> <ul> <li>The primary concept in DCN and DeepFM involved generating feature crosses through brute-force methods by considering all possible combinations. This approach is not only inefficient but also risks creating feature crosses that offer no meaningful value, leading to model overfitting.</li> <li>What is required, therefore, is a method to automatically identify which feature interactions are significant and which can be disregarded. The solution, as you might expect, is self-attention.</li> </ul> <blockquote> <p>AutoInt introduces the concept of multi-head self-attention within recommender systems: instead of generating all possible pairwise feature crosses through brute force, attention mechanisms are employed to discern which feature crosses are truly relevant.</p> </blockquote> <ul> <li>This was the key innovation behind AutoInt, short for “automated feature interaction learning,” as proposed by <a href="https://arxiv.org/abs/1810.11921" rel="external nofollow noopener" target="_blank">Song et al. (2019)</a> from Peking University, China. Specifically, the authors first project each feature into a 16-dimensional embedding space, and then pass these embeddings through a stack of multi-head self-attention layers, which automatically identify the most informative feature interactions. The inputs to the key, query, and value matrices are simply the list of all feature embeddings, and the attention function is a dot product, chosen for its simplicity and effectiveness in capturing feature interactions.</li> <li>Although this may sound complex, there is no real mystery—just a series of matrix multiplications. For instance, the attention matrix learned by one of the attention heads in AutoInt for the MovieLens benchmark dataset is shown below:</li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/aint2.webp" alt=""></p> <ul> <li>The model learns that feature crosses such as <code class="language-plaintext highlighter-rouge">Genre-Gender</code>, <code class="language-plaintext highlighter-rouge">Genre-Age</code>, and <code class="language-plaintext highlighter-rouge">RequestTime-ReleaseTime</code> are important, highlighted in green. This makes sense, as men and women typically have different movie preferences, and children often prefer different films compared to adults. The <code class="language-plaintext highlighter-rouge">RequestTime-ReleaseTime</code> feature cross captures the movie’s freshness at the time of the training instance.</li> <li>By utilizing a stack of three attention layers, each with two heads, the authors of AutoInt were able to outperform several competitors, including Wide and Deep and DeepFM, on the MovieLens and Criteo benchmark datasets.</li> </ul> <h2 id="dlrm-2019">DLRM (2019)</h2> <ul> <li>Let’s fast-forward by a year to Meta’s DLRM (“deep learning for recommender systems”) architecture, proposed in <a href="https://aman.ai/recsys/architectures/](https://arxiv.org/abs/1906.00091)" rel="external nofollow noopener" target="_blank">Naumov et al. (2019)</a>, another important milestone in recommender system modeling.</li> <li>This paper by Naumov et al. from Facebook in 2019 introduces the DLRM (deep learning for recommender systems) architecture, a significant development in recommender system modeling, which was open-sourced in both PyTorch and Caffe2 frameworks.</li> <li>Contrary to the “deep learning” part in it’s name, DLRM represents a progression from the DeepFM architecture, maintaining the FM (factorization machine) component while discarding the deep neural network part. The fundamental hypothesis of DLRM is that interactions are paramount in recommender systems, which can be modeled using shallow MLPs (and complex deep learning components are thus not essential).</li> <li>The DLRM model handles continuous (dense) and categorical (sparse) features that describe users and products. DLRM exercises a wide range of hardware and system components, such as memory capacity and bandwidth, as well as communication and compute resources as shown in the figure below from the paper.</li> </ul> <p><img src="https://aman.ai/images/papers/dlrm.jpg" alt=""></p> <ul> <li>The figure below from the paper shows the overall structure of DLRM.</li> </ul> <p><img src="https://aman.ai/images/papers/dlrm2.jpg" alt=""></p> <ul> <li>DLRM uniquely handles both continuous (dense) and categorical (sparse) features that describe users and products, projecting them into a shared embedding space. These features are then passed through MLPs before and after computing pairwise feature interactions (dot products). This method significantly differs from other neural network-based recommendation models in its explicit computation of feature interactions and treatment of each embedded feature vector as a single unit, contrasting with approaches like Deep and Cross which consider each element in the feature vector separately.</li> </ul> <blockquote> <p>DLRM shows that interactions are all you need: it’s akin to using just the FM component of DeepFM but with MLPs added before and after the interactions to increase modeling capacity.</p> </blockquote> <ul> <li>The architecture of DLRM includes multiple MLPs, which are added to increase the model’s capacity and expressiveness, enabling it to model more complex interactions. This aspect is critical as it allows for fitting data with higher precision, given adequate parameters and depth in the MLPs.</li> <li>Compared to other DL-based approaches to recommendation, DLRM differs in two ways. First, it computes the feature interactions explicitly while limiting the order of interaction to pairwise interactions. Second, DLRM treats each embedded feature vector (corresponding to categorical features) as a single unit, whereas other methods (such as Deep and Cross) treat each element in the feature vector as a new unit that should yield different cross terms. These design choices help reduce computational/memory cost while maintaining competitive accuracy.</li> <li>A key contribution of DLRM is its specialized parallelization scheme, which utilizes model parallelism on the embedding tables to manage memory constraints and exploits data parallelism in the fully-connected layers for computational scalability. This approach is particularly effective for systems with diverse hardware and system components, like memory capacity and bandwidth, as well as communication and compute resources.</li> <li>The paper demonstrates that DLRM surpasses the performance of the DCN model on the Criteo dataset, validating the authors’ hypothesis about the predominance of feature interactions. Moreover, DLRM has been characterized for its performance on the Big Basin AI platform, proving its utility as a benchmark for future algorithmic experimentation, system co-design, and benchmarking in the field of deep learning-based recommendation models.</li> <li> <a href="https://ai.facebook.com/blog/dlrm-an-advanced-open-source-deep-learning-recommendation-model/" rel="external nofollow noopener" target="_blank">Facebook AI</a> post.</li> </ul> <h3 id="summary-6">Summary</h3> <ul> <li>The key idea behind DLRM is to take the approach from DeepFM but only keep the FM part, not the Deep part, and expand on top of that. The underlying hypothesis is that the interactions of features are really all that matter in recommender systems. “Interactions are all you need!”, you may say.</li> <li>The deep component is not really needed. DLRM uses a bunch of MLPs to model feature interactions. Under the hood, DLRM projects all sparse and dense features into the same embedding space, passes them through MLPs (blue triangles in the above figure), computes all pairs of feature interactions (the cloud), and finally passes this interaction signal through another MLP (the top blue triangle). The interactions here are simply dot products, just like in DeepFM.</li> <li>The key difference to the DeepFM’s “FM” though is the addition of all these MLPs, the blue triangles. Why do we need those? Because they’re adding modeling capacity and expressiveness, allowing us to model more complex interactions. After all, one of the most important rules in neural networks is that given enough parameters, MLPs with sufficient depth and width can fit data to arbitrary precision!</li> <li>In the paper, the authors show that DLRM beats DCN on the Criteo dataset. The authors’ hypothesis proved to be true. Interactions, it seems, may really be all you need.</li> </ul> <h2 id="dcn-v2-2020">DCN V2 (2020)</h2> <ul> <li>Proposed in <a href="https://arxiv.org/abs/2008.13535" rel="external nofollow noopener" target="_blank">DCN V2: Improved Deep &amp; Cross Network and Practical Lessons for Web-scale Learning to Rank Systems</a> by Wang et al. from Google, DCN V2 is an enhanced version of the Deep &amp; Cross Network (DCN), designed to effectively learn feature interactions in large-scale learning to rank (LTR) systems.</li> <li>The paper addresses DCN’s limited expressiveness in learning predictive feature interactions, especially in web-scale systems with extensive training data.</li> <li>DCN V2 is focused on the efficient and effective learning of predictive feature interactions, a crucial aspect of applications like search recommendation systems and computational advertising. It tackles the inefficiency of traditional methods, including manual identification of feature crosses and reliance on deep neural networks (DNNs) for higher-order feature crosses.</li> <li>The embedding layer in DCN V2 processes both categorical (sparse) and dense features, supporting various embedding sizes, essential for industrial-scale applications with diverse vocabulary sizes.</li> <li>The core of DCN V2 is its cross layers, which explicitly create feature crosses. These layers are based on a base layer with original features, utilizing learned weight matrices and bias vectors for each cross layer.</li> <li>The figure below from the paper visualizes a cross layer.</li> </ul> <p><img src="https://aman.ai/images/papers/DCNV2_2.jpg" alt=""></p> <ul> <li>As shown in the figure below, DCN V2 employs a novel architecture that combines a cross network with a deep network. This combination is realized through two architectures: a stacked structure where the cross network output feeds into the deep network, and a parallel structure where outputs from both networks are concatenated. The cross operation in these layers is represented as xl+1=x0⊙(Wlxl+bl)+xl.</li> </ul> <p><img src="https://aman.ai/images/papers/DCNV2_1.jpg" alt=""></p> <blockquote> <p>A key feature of DCN V2 is the use of low-rank techniques to approximate feature crosses in a subspace, improving performance and reducing latency. This is further enhanced by a Mixture-of-Experts architecture, which decomposes the matrix into multiple smaller sub-spaces aggregated through a gating mechanism.</p> </blockquote> <ul> <li>DCN V2 demonstrates superior performance in extensive studies and comparisons with state-of-the-art algorithms on benchmark datasets like Criteo and MovieLens-1M. It offers significant gains in offline accuracy and online business metrics in Google’s web-scale LTR systems.</li> <li>The paper also delves into polynomial approximation from both bitwise and feature-wise perspectives, illustrating how DCN V2 creates feature interactions up to a certain order with a given number of cross layers, thus being more expressive than the original DCN.</li> </ul> <h3 id="dcn-vs-dcn-v2">DCN vs. DCN V2</h3> <ul> <li>DCN focuses on explicit low-order feature interaction modeling through cross networks but faces limitations in scalability and memory efficiency as interaction complexity increases.</li> <li>DCN V2 overcomes the limitations of DCN by enhancing the scalability and efficiency by incorporating low-rank techniques and Mixture-of-Experts architectures. These enhancements make DCN V2 suitable for large-scale, real-time applications with significant memory and computational optimizations.</li> </ul> <h3 id="low-rank-techniques-in-dcn-v2">Low-Rank Techniques in DCN V2</h3> <h4 id="dcn-limitations-in-scalability">DCN Limitations in Scalability</h4> <ul> <li>DCN captures nonlinear interactions using a Cross Network, where interaction complexity is tied to the number of cross layers. As the network depth increases, the number of parameters grows significantly, leading to inefficiencies in handling higher-order feature interactions, especially in large-scale systems.</li> <li> <p>The Cross Network formula in DCN is as follows:</p> <p>xl+1=x0⋅(Wl⋅xl+bl)+xl</p> <ul> <li>Here, Wl and bl represent the weight matrix and bias vector for layer l, while x0 is the original input, and xl is the input to the current cross layer.</li> </ul> </li> <li>While this structure allows DCN to model nonlinear interactions between features, its scalability is constrained by the computational cost of increasing parameters, making it less efficient for modeling arbitrary high-order interactions.</li> </ul> <h4 id="low-rank-approximations">Low-Rank Approximations</h4> <ul> <li> <p>DCN V2 addresses these scalability issues with low-rank approximations in the Cross Network. The weight matrix Wl is factorized to reduce computational complexity:</p> <p>Wl≈Ul⋅VlT</p> <ul> <li>where Ul and Vl are lower-dimensional matrices.</li> </ul> </li> <li> <p>This factorization reduces computational overhead from O(d2) to O(d×r), where r is the rank, significantly improving efficiency for large datasets.</p> </li> <li> <p>Low-rank approximations enable DCN V2 to model higher-order feature interactions with lower memory and computational requirements, making it better suited for web-scale, real-time systems.</p> </li> </ul> <h3 id="mixture-of-experts-architecture">Mixture-of-Experts Architecture</h3> <h4 id="enhancing-expressiveness-with-mixture-of-experts">Enhancing Expressiveness with Mixture-of-Experts</h4> <ul> <li> <p>DCN V2 introduces a Mixture-of-Experts architecture to enhance its expressiveness. This approach dynamically selects which “expert” network to activate based on input, allowing different subspaces to specialize in capturing specific feature interactions.</p> <p>xl+1=∑i=1KGi(xl)⋅Ei(xl)+xl</p> <ul> <li>where, Gi(xl) is a gating function that determines which expert Ei(xl) to activate.</li> </ul> </li> <li> <p>By assigning specific feature interactions to dedicated experts, the Mixture-of-Experts framework allows DCN V2 to model complex, higher-order interactions without significantly increasing computational cost.</p> </li> </ul> <h4 id="advantages-of-mixture-of-experts">Advantages of Mixture-of-Experts</h4> <ul> <li>The architecture ensures that feature crosses are handled flexibly and efficiently. Unlike DCN, where feature interactions are bounded by the fixed structure of the Cross Network, DCN V2 leverages the gating mechanism to adaptively allocate computational resources to relevant subspaces.</li> <li>This dynamic expert selection enables DCN V2 to scale effectively for industrial applications, where both accuracy and speed are critical.</li> </ul> <h3 id="model-structure-parallel-dcn-vs-stacked-and-parallel-dcn-v2">Model Structure: Parallel (DCN) vs. Stacked and Parallel (DCN V2)</h3> <ul> <li>DCN V2 builds on the strengths of DCN by making the cross network more expressive and scalable, particularly through low-rank techniques and flexible model architectures. This makes DCN V2 better suited for large-scale, web-based recommendation systems while maintaining efficiency.</li> </ul> <h4 id="dcn">DCN</h4> <ul> <li>The model structure in DCN consists of two parallel networks: <ul> <li> <strong>Deep Network (DNN)</strong>: The DNN is responsible for capturing implicit feature interactions, which are complex and nonlinear. The deep network uses multiple fully connected layers, allowing the model to learn intricate relationships between features that are not easily captured by simple feature crossing.</li> <li> <strong>Cross Network</strong>: This part of the model is designed to capture explicit feature interactions up to a fixed degree (bounded by the number of layers in the cross network). The cross layers systematically apply feature crosses at each level, combining the original features with the output of the previous cross layer to form higher-degree feature interactions. The cross network is particularly efficient in modeling lower-order feature crosses without the need for manual feature engineering.</li> <li> <strong>Parallel Structure</strong>: In DCN, both the DNN and cross network operate in parallel. The input features are passed through both networks, and their respective outputs are concatenated in the final logits layer for prediction. This parallel approach is effective at capturing both implicit and explicit interactions in the data, allowing DCN to perform well without requiring exhaustive feature engineering.</li> <li> <strong>Drawback</strong>: However, this structure might be limiting in cases where the sequential dependency between explicit and implicit features is important. The model does not allow for deep interactions between the cross network’s explicit crosses and the deep network’s implicit learning, as both networks run independently.</li> </ul> </li> </ul> <h4 id="dcn-v2">DCN V2</h4> <ul> <li>DCN V2 enhances the flexibility of the model by introducing two ways of combining the deep network and cross network: stacked and parallel structures. <ul> <li> <strong>Stacked Structure</strong>: In the stacked architecture, the cross network is applied first to generate explicit feature crosses, and the output of the cross network is then fed into the deep network to learn higher-order implicit interactions. This stacked approach allows the deep network to build upon the explicitly crossed features, enabling a richer, more nuanced learning process. The stacked structure is especially useful in situations where the interactions between explicit feature crosses and deeper, more implicit interactions need to be modeled sequentially. By first capturing simpler, bounded-degree feature crosses in the cross network, the deep network can then focus on learning more complex, high-order interactions that depend on these explicit crosses.</li> <li> <strong>Parallel Structure</strong>: Similar to the original DCN, DCN V2 also supports a parallel structure where both the deep network and cross network operate simultaneously. In this approach, the features are processed by both networks concurrently, and their outputs are concatenated for final prediction. This structure is particularly useful for datasets where implicit and explicit interactions are relatively independent, and combining them at the end provides a comprehensive understanding of the data.</li> <li> <strong>Combination Layer</strong>: In both the stacked and parallel setups, DCN V2 uses a combination layer to aggregate the outputs of the cross network and deep network before passing them to the final output layer (often a logits layer). Depending on the architecture chosen, the combination can take the form of either a sequential concatenation (in the stacked case) or a direct concatenation of both network outputs (in the parallel case).</li> <li> <strong>Flexibility and Adaptation</strong>: This added flexibility enables DCN V2 to better adapt to different types of datasets and tasks. For instance, if the dataset contains feature interactions that are primarily simple and can be captured by bounded-degree crosses, the stacked structure allows the model to first handle these simpler interactions and then apply deep learning for more complex patterns. Alternatively, if the dataset benefits from learning both types of interactions concurrently, the parallel structure can be used. This versatility makes DCN V2 highly customizable and better suited for diverse real-world applications.</li> <li> <strong>Efficiency</strong>: Although the stacked structure adds more depth and complexity to the model, DCN V2 remains computationally efficient by leveraging low-rank techniques and Mixture-of-Experts in the cross layers, ensuring that the additional depth does not significantly increase computational cost or inference time.</li> </ul> </li> <li> <strong>Stacked vs. Parallel</strong>: The choice between stacked and parallel structures in DCN V2 depends on the specific requirements of the task at hand: <ul> <li>The stacked structure is more suited for tasks where feature crosses learned by the cross network can directly inform and enrich the implicit interactions learned by the deep network. This sequential dependency enhances the ability to capture more complex feature relationships that depend on simpler interactions.</li> <li>The parallel structure works better for tasks where the explicit and implicit interactions are more independent and do not require one to build on the other. This allows for concurrent learning of different types of interactions, potentially improving the speed and efficiency of learning.</li> </ul> </li> </ul> <h3 id="summary-of-key-differences">Summary of Key Differences</h3> <ul> <li>Here’s a table that provides a detailed comparison, incorporating the technical aspects of both models, and highlights how DCN V2 overcomes the limitations of DCN to provide a more scalable, efficient, and production-ready solution.</li> </ul> <table> <thead> <tr> <th><strong>Metric</strong></th> <th><strong>DCN</strong></th> <th><strong>DCN V2</strong></th> </tr> </thead> <tbody> <tr> <td>Cross Features’ Expressiveness</td> <td>Captures nonlinear interactions through cross layers, with expressiveness limited by network depth.</td> <td>Enhanced expressiveness with low-rank techniques and Mixture-of-Experts for higher-order interactions.</td> </tr> <tr> <td>Scalability</td> <td>Limited scalability as parameter complexity increases with deeper layers.</td> <td>Improved scalability using low-rank factorization, optimizing for large-scale datasets.</td> </tr> <tr> <td>Efficiency</td> <td>Efficiency decreases with growing interaction complexity due to higher computational cost.</td> <td>Reduces complexity from O(d2) to O(d×r) using low-rank approximations, improving efficiency.</td> </tr> <tr> <td>Model Structure</td> <td>Parallel structure where Cross Network and DNN run independently.</td> <td>Offers both stacked and parallel structures, enabling richer interaction modeling with flexibility.</td> </tr> <tr> <td>Handling Higher-Order Interactions</td> <td>Limited by the depth of the Cross Network, with increasing computational overhead.</td> <td>Capable of modeling complex, higher-order interactions efficiently through Mixture-of-Experts.</td> </tr> <tr> <td>Flexibility</td> <td>Fixed structure with limited adaptability to different tasks or datasets.</td> <td>Flexible with stacked and parallel setups, adaptable to various datasets and interaction complexities.</td> </tr> <tr> <td>Suitable Applications</td> <td>Best suited for smaller systems with limited interaction complexities.</td> <td>Optimized for large-scale, real-time systems, with memory and computational efficiency.</td> </tr> </tbody> </table> <h3 id="summary-7">Summary</h3> <ul> <li>Proposed in <a href="https://arxiv.org/abs/2008.13535" rel="external nofollow noopener" target="_blank">DCN V2: Improved Deep &amp; Cross Network and Practical Lessons for Web-scale Learning to Rank Systems</a> by Wang et al. from Google. An enhanced version of the Deep &amp; Cross Network (DCN), DCN V2, effectively learns feature interactions in large-scale learning to rank (LTR) systems.</li> <li>DCN V2 addresses the limitations of the original DCN, particularly in web-scale systems with vast amounts of training data, where DCN exhibited limited expressiveness in its cross network for learning predictive feature interactions.</li> <li>The paper focuses on efficient and effective learning of predictive feature interactions, crucial in applications like search recommendation systems and computational advertising. Traditional approaches often involve manual identification of feature crosses or rely on deep neural networks (DNNs), which can be inefficient for higher-order feature crosses.</li> <li>DCN V2 includes an embedding layer that processes both categorical (sparse) and dense features. It supports different embedding sizes, crucial for industrial-scale applications with varying vocabulary sizes.</li> <li>The core of DCN V2 is its cross layers, which create explicit feature crosses. These layers are built upon a base layer containing original features and use learned weight matrices and bias vectors for each cross layer.</li> <li>DCN V2’s effectiveness is demonstrated through extensive studies and comparisons with state-of-the-art algorithms on benchmark datasets like Criteo and MovieLens-1M. It outperforms these algorithms and offers significant offline accuracy and online business metrics gains in Google’s web-scale LTR systems.</li> <li>In summary, the key change in DCN V2’s cross network that enhances its expressiveness is the incorporation of low-rank matrices in the cross layers. This approach optimizes the computation of feature interactions, making the network more efficient and scalable, especially for complex, high-dimensional datasets. The use of low-rank matrices allows the network to capture complex feature interactions (including higher-order interactions) more effectively without the computational burden of full-rank operations.</li> </ul> <h2 id="dhen-2022">DHEN (2022)</h2> <ul> <li>Learning feature interactions is important to the model performance of online advertising services. As a result, extensive efforts have been devoted to designing effective architectures to learn feature interactions. However, they observe that the practical performance of those designs can vary from dataset to dataset, even when the order of interactions claimed to be captured is the same. That indicates different designs may have different advantages and the interactions captured by them have non-overlapping information.</li> <li>Proposed in <a href="https://arxiv.org/abs/2203.11014" rel="external nofollow noopener" target="_blank">DHEN: A Deep and Hierarchical Ensemble Network for Large-Scale Click-Through Rate Prediction</a>, this paper by Zhang et al. from Meta introduces DHEN (Deep and Hierarchical Ensemble Network), a novel architecture designed for large-scale Click-Through Rate (CTR) prediction. The significance of DHEN lies in its ability to learn feature interactions effectively, a crucial aspect in the performance of online advertising services. Recognizing that different interaction models offer varying advantages and capture non-overlapping information, DHEN integrates a hierarchical ensemble framework with diverse interaction modules, including AdvancedDLRM, self-attention, Linear, Deep Cross Net, and Convolution. These modules enable DHEN to learn a hierarchy of interactions across different orders, addressing the limitations and variable performance of previous models on different datasets.</li> <li>The following figure from the paper shows a two-layer two-module hierarchical ensemble (left) and its expanded details (right). A general DHEN can be expressed as a mixture of multiple high-order interactions. Dense feature input for the interaction modules are omitted in this figure for clarity.</li> </ul> <p><img src="https://aman.ai/images/papers/DHEN.jpg" alt=""></p> <ul> <li>In CTR prediction tasks, the feature inputs usually contain discrete categorical terms (sparse features) and numerical values (dense features). DHEN uses the same feature processing layer in DLRM, which is shown in the figure below. The sparse lookup tables map the categorical terms to a list of “static” numerical embeddings. Specifically, each categorical term is assigned a trainable d-dimensional vector as its feature representation. On the other hand, the numerical values are processed by dense layers. Dense layers compose of several Multi-layer Perceptions (MLPs) from which an output of a d-dimensional vector is computed. After a concatenation of the output from sparse lookup table and dense layer, the final output of the feature processing layer X0∈Rd×m can be expressed as X0=(x01,x02,…,x0m), where m is the number of the output embeddings and d is the embedding dimension.</li> </ul> <p><img src="https://aman.ai/images/papers/DHEN2.jpg" alt=""></p> <ul> <li>A key technical advancement in this work is the development of a co-designed training system tailored for DHEN’s complex, multi-layer structure. This system introduces the Hybrid Sharded Data Parallel, a novel distributed training paradigm. This approach not only caters to the deeper structure of DHEN but also significantly enhances training efficiency, achieving up to 1.2x better throughput compared to existing models.</li> <li>Empirical evaluations on large-scale datasets for CTR prediction tasks have demonstrated the effectiveness of DHEN. The model showed an improvement of 0.27% in Normalized Entropy (NE) gain over state-of-the-art models, underlining its practical effectiveness. The paper also discusses improvements in training throughput and scaling efficiency, highlighting the system-level optimizations that make DHEN particularly adept at handling large and complex datasets in the realm of online advertising.n the Normalized Entropy (NE) of prediction and 1.2x better training throughput than state-of-the-art baseline, demonstrating their effectiveness in practice.</li> </ul> <h3 id="summary-8">Summary</h3> <ul> <li>In contrast to DCN, the feature interactions in DLRM are restricted to second-order (i.e., pairwise) interactions only: they are simply dot products of all pairs of embeddings. Referring back to the movie example (with features such as user, movie, actors, director), second-order interactions would include user-movie, user-actor, user-director, movie-actor, movie-director, and actor-director. A third-order interaction would involve combinations like user-movie-director, actor-actor-user, director-actor-user, and so forth.</li> <li>For instance, certain users may favor movies directed by Steven Spielberg that feature Tom Hanks, necessitating a cross feature to account for such preferences. Unfortunately, standard DLRM does not accommodate such interactions, representing a significant limitation.</li> <li>This is where DHEN, short for “Deep Hierarchical Ensemble Network”, comes in. Proposed in <a href="https://arxiv.org/abs/2203.11014" rel="external nofollow noopener" target="_blank">Zhang et al. (2022)</a>, the core concept of DHEN is to establish a “hierarchy” of cross features that deepens with the number of DHEN layers, allowing for third, fourth, and even higher-order interactions.</li> <li>At a high level, DHEN operates as follows: suppose we have two input features entering DHEN, which we denote as A and B. A 1-layer DHEN module would generate an entire hierarchy of cross features, incorporating both the features themselves and second-order interactions, such as:</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;span&gt;A&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AxA&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AxB&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;BxA&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;B&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;BxB&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
</code></pre></div></div> <ul> <li>where, “x” does not signify a singular interaction but represents a combination of the following five interactions: <ul> <li>dot product,</li> <li>self-attention (similar to AutoInt),</li> <li>convolution,</li> <li>linear: y=Wx, or</li> <li>the cross module from DCN.</li> </ul> </li> <li>Adding another layer introduces further complexity:</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;span&gt;A&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AxA&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AxB&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AxAxA&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AxAxB&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AxBxA&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AxBxB&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;B&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;BxB&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;BxA&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;BxBxB&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;BxBxA&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;BxAxB&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;BxAxA&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
</code></pre></div></div> <ul> <li>In this case, “x” represents one of five interactions, culminating in 62 distinct signals. DHEN is indeed formidable, and its computational complexity, due to its recursive nature, is quite challenging. To manage this complexity, the authors of the DHEN paper developed a new distributed training approach called “Hybrid Sharded Data Parallel”, which delivers a 1.2X increase in throughput compared to the then state-of-the-art distributed learning algorithm.</li> <li>Most notably, DHEN proves effective: in their experiments on internal click-through rate data, the authors report a 0.27% improvement in NE compared to DLRM when using a stack of 8 DHEN layers. While such a seemingly small improvement in NE might raise questions about whether it justifies the significant increase in complexity, at Meta’s scale, it likely does.</li> <li>DHEN does not merely represent an incremental improvement over DLRM; it introduces a comprehensive hierarchy of feature interactions, comprising dot products, AutoInt-like self-attention, convolution, linear processing, and DCN-like crossing, replacing DLRM’s simpler dot product approach.</li> </ul> <h2 id="gdcn-2023">GDCN (2023)</h2> <ul> <li>Proposed in the paper <a href="https://arxiv.org/abs/2311.04635" rel="external nofollow noopener" target="_blank">Towards Deeper, Lighter, and Interpretable Cross Network for CTR Prediction</a> by Wang et al. (2023) from Fudan University and Microsoft Research Asia in CIKM ‘23. The paper introduces the Gated Deep Cross Network (GDCN) and the Field-level Dimension Optimization (FDO) approach. GDCN aims to address significant challenges in Click-Through Rate (CTR) prediction for recommender systems and online advertising, specifically the automatic capture of high-order feature interactions, interpretability issues, and the redundancy of parameters in existing methods.</li> <li>GDCN is inspired by DCN V2 and consists of an embedding layer, a Gated Cross Network (GCN), and a Deep Neural Network (DNN). The GCN forms its core structure, which captures explicit bounded-degree high-order feature crosses/interactions. The GCN employs an information gate in each cross layer (representing a higher order interaction) to dynamically filter and amplify important interactions. This gate controls the information flow, ensuring that the model focuses on relevant interactions. This approach not only allows for deeper feature crossing but also adds a layer of interpretability by identifying crucial interactions, thus modelling implicit feature crosses.</li> <li>GDCN is a generalization of DCN V2, offering dynamic instance-based interpretability and the ability to utilize deeper cross features without a loss in performance.</li> </ul> <blockquote> <p>The unique selling point of DCN V2 is that it treats all cross features equally, while GDCN uses information gates for fine-grained control over feature importance.</p> </blockquote> <ul> <li>GDCN transforms high-dimensional, sparse input into low-dimensional, dense representations. Unlike most CTR models, GDCN allows arbitrary embedding dimensions.</li> <li>Two structures are proposed: GDCN-S (stacked) and GDCN-P (parallel). GDCN-S feeds the output of GCN into a DNN, while GDCN-P feeds the input vector in parallel into GCN and DNN, concatenating their outputs.</li> <li>Alongside GDCN, the FDO approach focuses on optimizing the dimensions of each field in the embedding layer based on their importance. FDO addresses the issue of redundant parameters by learning independent dimensions for each field based on its intrinsic importance. This approach allows for a more efficient allocation of embedding dimensions, reducing unnecessary parameters and enhancing enhancing efficiency without compromising performance. FDO uses methods like PCA to determine optimal dimensions and only needs to be done once, with the dimensions applicable to subsequent model updates.</li> <li>The following figure shows the architecture of the GDCN-S and GDCN-P. ⊗ is the cross operation (a.k.a, the gated cross layer).</li> </ul> <p><img src="https://aman.ai/images/papers/GDCN1.jpg" alt=""></p> <ul> <li>The following figure visualizes the gated cross layer. ⊙ is elementwise/Hadamard product, and × is matrix multiplication.</li> </ul> <p><img src="https://aman.ai/images/papers/GDCN2.jpg" alt=""></p> <ul> <li>Results indicate that GDCN, especially when paired with the FDO approach, outperforms state-of-the-art methods in terms of prediction performance, interpretability, and efficiency. GDCN was evaluated on five datasets (Criteo, Avazu, Malware, Frappe, ML-tag) using metrics like AUC and Logloss, showcasing the effectiveness and superiority of GDCN in capturing deeper high-order interactions. These experiments also demonstrate the interpretability of the GCN model and the successful parameter reduction achieved by the FDO approach. The datasets underwent preprocessing like feature removal for infrequent items and normalization. The comparison included various classes of CTR models and demonstrated GDCN’s effectiveness in handling high-order feature interactions without the drawbacks of overfitting or performance degradation observed in other models. GDCN achieves comparable or better performance with only a fraction (about 23%) of the original model parameters.</li> <li>In summary, GDCN addresses the limitations of existing CTR prediction models by offering a more interpretable, efficient, and effective approach to handling high-order feature interactions, supported by the innovative use of information gates and dimension optimization techniques.</li> </ul> <h2 id="graph-neural-networks-based-recsys-architectures">Graph Neural Networks-based RecSys Architectures</h2> <ul> <li>Graph Neural Networks (GNN) architectures utilize graph structures to capture relationships between users, items, and their interactions. GNNs propagate information through the user-item interaction graph, enabling the model to learn user and item representations that incorporate relational dependencies. This is particularly useful in scenarios with rich graph-based data. <ul> <li> <strong>Pros:</strong> Captures relational dependencies and propagates information through graph structures, enabling better modeling of complex relationships. <ul> <li> <strong>Cons:</strong> Requires graph-based data and potentially higher computational resources for training and inference.</li> <li> <strong>Advantages:</strong> Improved recommendations by incorporating the rich relational information among users, items, and their interactions.</li> <li> <strong>Example Use Case:</strong> Social recommendation systems, where user-user connections or item-item relationships play a significant role in personalized recommendations.</li> </ul> </li> <li> <strong>Phase:</strong> Candidate Generation, Ranking, Retrieval.</li> <li> <strong>Recommendation Workflow:</strong> GNN architectures are suitable for multiple phases of the recommendation workflow. In the candidate generation phase, GNNs can leverage graph structures to capture relational dependencies and generate potential candidate items. In the ranking phase, GNNs can learn user and item embeddings that incorporate relational information, leading to improved ranking. In the retrieval phase, GNNs can assist in efficient retrieval of relevant items based on their graph-based representations.</li> </ul> </li> <li>For a detailed overview of GNNs in RecSys, please refer to the <a href="https://aman.ai/recsys/GNN" rel="external nofollow noopener" target="_blank">GNN primer</a>.</li> </ul> <h2 id="two-towers-in-recsys">Two Towers in RecSys</h2> <ul> <li>One of the most prevalent architectures in personalization and recommendation systems (RecSys) is the two-tower network. This network architecture typically comprises two towers: the user tower (U) and the candidate tower (C). These towers generate dense vector representations (embeddings) of the user and the candidate, respectively. The final layer of the network combines these embeddings using either a dot product or cosine similarity function.</li> <li>Consider the computational costs involved: if the cost of executing the user tower is u, the candidate tower is c, and the dot product is d, then the total cost of ranking N candidates for a single user is N∗(u+c+d). Since the user representation is fixed and computed once, the cost reduces to u+N∗(c+d). Moreover, caching the embeddings can further reduce the cost to u+N∗d+k, where k represents additional fixed overheads. <a href="https://medium.com/better-ml/recsys-model-serving-model-architectures-serving-1b5f038848bd" rel="external nofollow noopener" target="_blank">(source)</a> </li> <li>The following image illustrates this concept <a href="https://medium.com/better-ml/recsys-model-serving-model-architectures-serving-1b5f038848bd" rel="external nofollow noopener" target="_blank">(source)</a>:</li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/2.webp" alt=""></p> <ul> <li>The two-tower architecture consists of two distinct branches: a query tower (user tower) and a candidate tower (item tower). The query tower learns the user’s representation based on their history, while the candidate tower learns item representations from item features. The two towers are combined at the final stage to produce recommendations. <ul> <li> <strong>Pros:</strong> This approach explicitly models user and item representations separately, facilitating a better understanding of user preferences and item features.</li> <li> <strong>Cons:</strong> It requires additional computation to learn and combine the representations from both the query and candidate towers.</li> <li> <strong>Advantages:</strong> This method enhances personalization by learning user and item representations separately, allowing for more granular preference capture.</li> <li> <strong>Example Use Case:</strong> This architecture is particularly effective in personalized recommendation systems where understanding both the user’s past behavior and item characteristics is crucial.</li> <li> <strong>Phase:</strong> Candidate Generation, Ranking.</li> <li> <strong>Recommendation Workflow:</strong> The two-tower architecture is commonly used in the candidate generation and ranking phases. During candidate generation, it allows for the independent processing of user and item features, generating separate representations. In the ranking phase, these representations are merged to assess the relevance of candidate items to the user’s preferences.</li> </ul> </li> <li>The two-tower model gained formal recognition in the machine learning community through Huawei’s 2019 <a href="https://www.researchgate.net/publication/335771749_PAL_a_position-bias_aware_learning_framework_for_CTR_prediction_in_live_recommender_systems" rel="external nofollow noopener" target="_blank">PAL</a> paper. This model was designed to address biases in ranking models, particularly position bias in recommendation systems.</li> <li>The two-tower architecture typically includes one tower for learning relevance (user/item interactions) and another for learning biases (such as position bias). These towers are combined, either multiplicatively or additively, to generate the final output.</li> <li> <strong>Examples of notable two-tower implementations:</strong> <ul> <li>Huawei’s PAL model employs a multiplicative approach to combine the outputs of the two towers, addressing position bias within their app store.</li> <li>YouTube’s “Watch Next” paper introduced an additive two-tower model, which not only mitigates position bias but also considers other selection biases by incorporating features like device type.</li> </ul> </li> <li>The two-tower model has demonstrated significant improvements in recommendation systems. For instance, Huawei’s PAL model improved click-through and conversion rates by approximately 25%. YouTube’s model, by integrating a shallow tower for bias learning, also showed increased engagement metrics.</li> <li> <strong>Challenges and considerations:</strong> <ul> <li>A primary challenge in two-tower models is ensuring that both towers learn independently during training, as relevance can interfere with the learning of position bias.</li> <li>Techniques such as Dropout have been employed to reduce over-reliance on certain features, such as position, and to enhance generalization.-</li> </ul> </li> <li>Overall, the two-tower model is recognized as an effective approach for building unbiased ranking models in recommender systems. It remains a promising area of research, with significant potential for further development.</li> </ul> <h3 id="split-network">Split Network</h3> <ul> <li>A split network is a generalized version of a two tower network. The same optimization of embedding lookup holds here as well. Instead of a dot product, a simple neural network could be used to produce output.</li> <li>The image below <a href="https://medium.com/better-ml/recsys-model-serving-model-architectures-serving-1b5f038848bd" rel="external nofollow noopener" target="_blank">(source)</a> showcases this.</li> </ul> <p><img src="https://aman.ai/recsys/assets/architectures/3.webp" alt=""></p> <ul> <li>In a split network architecture, different components of the recommendation model are split and processed separately. For example, the user and item features may be processed independently and combined in a later stage. This allows for parallel processing and efficient handling of large-scale recommender systems. <ul> <li> <strong>Pros:</strong> Enables parallel processing, efficient handling of large-scale systems, and flexibility in designing and optimizing different components separately.</li> <li> <strong>Cons:</strong> Requires additional coordination and synchronization between the split components, potentially increasing complexity.</li> <li> <strong>Advantages:</strong> Scalability, flexibility, and improved performance in handling large-scale recommender systems.</li> <li> <strong>Example Use Case:</strong> Recommendation systems with a massive number of users and items, where parallel processing is crucial for efficient computation.</li> <li> <strong>Phase:</strong> Candidate Generation, Ranking, Final Ranking.</li> <li> <strong>Recommendation Workflow:</strong> The split network architecture can be utilized in various phases. During the candidate generation phase, the split network can be used to process user and item features independently, allowing efficient retrieval of potential candidate items. In the ranking phase, the split network can be employed to learn representations and capture interactions between the user and candidate items. Finally, in the final ranking phase, the split network can contribute to the overall ranking of the candidate items based on learned representations.</li> </ul> </li> </ul> <h2 id="summary-9">Summary</h2> <ul> <li>Neural Collaborative Filtering (NCF) represents a pioneering approach in recommender systems. It was one of the initial studies to replace the then-standard linear matrix factorization algorithms with neural networks, thus facilitating the integration of deep learning into recommender systems.</li> <li>The Wide &amp; Deep model underscored the significance of cross features—specifically, second-order features formed by intersecting two original features. This model effectively combines a broad, shallow module for handling cross features with a deep module, paralleling the approach of NCF.</li> <li>Deep and Cross Neural Network (DCN) was among the first to transition from manually engineered cross features to an algorithmic method capable of autonomously generating all potential feature crosses to any desired order.</li> <li>Deep Factorization Machine (DeepFM) shares conceptual similarities with DCN. However, it distinctively substitutes the cross layers in DCN with factorization machines, or more specifically, dot products.</li> <li>Automatic Interactions (AutoInt) brought multi-head self-attention mechanisms, previously known in Large Language Models (LLMs), into the domain of feature interaction. This technique moves away from brute-force generation of all possible feature interactions, which can lead to model overfitting on noisy feature crosses. Instead, it employs attention mechanisms to enable the model to selectively focus on the most relevant feature interactions.</li> <li>Deep Learning Recommendation Model (DLRM) marked a departure from previous models by discarding the deep module. It relies solely on an interaction layer that computes dot products, akin to the factorization machine component in DeepFM, followed by a Multi-Layer Perceptron (MLP). This model emphasizes the sufficiency of interaction layers alone.</li> <li>Deep Hierarchical Embedding Network (DHEN) builds upon the DLRM framework by replacing the conventional dot product with a sophisticated hierarchy of feature interactions, including dot product, convolution, self-attention akin to AutoInt, and crossing features similar to those in DCN.</li> <li>Gated Deep Cross Network (GDCN) enhances Click-Through Rate (CTR) prediction in recommender systems by improving interpretability, efficiency, and handling of high-order feature interactions.</li> <li>The Two Tower model in recommender systems, known for its separate user and candidate towers, optimizes personalized recommendations and addresses biases like position bias, representing an evolving and powerful approach in building unbiased ranking models.</li> </ul> <h2 id="comparative-analysis">Comparative Analysis</h2> <ul> <li>This table offers a detailed comparative analysis table summarizing the key characteristics of various recommender system architectures in terms of features, advantages, limitations, use cases, and applicable phases in recommendation workflows.</li> </ul> <table> <thead> <tr> <th><strong>Technique</strong></th> <th><strong>Key Features</strong></th> <th><strong>Advantages</strong></th> <th><strong>Limitations</strong></th> <th><strong>Example Use Cases</strong></th> <th><strong>Phase</strong></th> </tr> </thead> <tbody> <tr> <td>Wide and Deep (2016)</td> <td>Combines a wide linear model for memorization with a deep neural network for generalization. Cross features essential.</td> <td>Balances memorization and generalization. Captures both specific rules and complex patterns.</td> <td>Requires manual engineering of cross features, increasing complexity.</td> <td>E-commerce, app recommendations</td> <td>Ranking</td> </tr> <tr> <td>Factorization Machines (FM, 2010)</td> <td>Models pairwise feature interactions using embeddings.</td> <td>Handles sparse data effectively. Efficient computation of pairwise interactions.</td> <td>Limited to pairwise interactions. Struggles with non-linear, higher-order interactions.</td> <td>CTR prediction, basic recommendations</td> <td>Ranking, Candidate Generation</td> </tr> <tr> <td>DeepFM (2017)</td> <td>Integrates FM with deep networks for higher-order feature interactions.</td> <td>Combines FM’s efficiency with deep learning’s capability to model non-linear interactions.</td> <td>Brute-force feature cross generation increases complexity and potential overfitting.</td> <td>Online advertising, CTR prediction</td> <td>Ranking, Candidate Generation</td> </tr> <tr> <td>NCF (2017)</td> <td>Substitutes matrix factorization’s dot product with neural networks for modeling user-item interactions.</td> <td>Adds non-linearity, beating matrix factorization in benchmarks.</td> <td>Lacks explicit cross-feature modeling (critical for some domains).</td> <td>Personalized recommendations</td> <td>Ranking</td> </tr> <tr> <td>DCN (2017)</td> <td>Introduces Cross Network for explicit feature interactions of bounded order.</td> <td>Automates cross-feature learning. Improves efficiency for sparse data.</td> <td>Limited scalability and expressiveness as complexity grows with depth.</td> <td>Display advertising, e-commerce</td> <td>Ranking</td> </tr> <tr> <td>DCN V2 (2020)</td> <td>Enhances DCN with low-rank approximations and Mixture-of-Experts. Supports stacked/parallel structures.</td> <td>More scalable and expressive. Models higher-order interactions effectively.</td> <td>Complexity and additional computational cost.</td> <td>Large-scale ranking systems</td> <td>Ranking</td> </tr> <tr> <td>AutoInt (2019)</td> <td>Uses multi-head self-attention for feature interaction modeling.</td> <td>Selectively focuses on relevant feature interactions, improving efficiency and reducing overfitting.</td> <td>Requires significant resources for training self-attention mechanisms.</td> <td>CTR prediction, movie recommendations</td> <td>Ranking</td> </tr> <tr> <td>DLRM (2019)</td> <td>Focuses solely on feature interaction via dot products, with MLPs for capacity.</td> <td>Simple and computationally efficient. Optimized for hardware scalability.</td> <td>Limited to second-order (pairwise) interactions.</td> <td>Web-scale personalization</td> <td>Ranking, Candidate Generation</td> </tr> <tr> <td>DHEN (2022)</td> <td>Builds hierarchical feature interaction using diverse modules (e.g., self-attention, convolution).</td> <td>Captures higher-order feature interactions. Strong performance gains in large-scale systems.</td> <td>High computational and implementation complexity.</td> <td>Online advertising</td> <td>Ranking, Candidate Generation</td> </tr> <tr> <td>GDCN (2023)</td> <td>Adds gated mechanisms to cross networks for fine-grained interaction control. Supports dimension optimization.</td> <td>Efficient parameter usage, interpretable results, captures deeper high-order interactions.</td> <td>Requires careful tuning of gates and dimensions.</td> <td>CTR prediction</td> <td>Ranking, Final Ranking</td> </tr> <tr> <td>Graph Neural Networks (GNN)</td> <td>Propagates information in user-item interaction graphs.</td> <td>Effectively models complex relational data. Captures dependencies among users and items.</td> <td>Computationally intensive. Requires graph-based data.</td> <td>Social recommendations, collaborative filtering</td> <td>Candidate Generation, Ranking</td> </tr> <tr> <td>Two Towers (2019)</td> <td>Separate user and item towers generate embeddings, combined via dot product or cosine similarity.</td> <td>Simplifies user-item representation learning. Efficient inference through caching.</td> <td>May struggle with learning complex interactions due to separation of towers.</td> <td>Personalized search, e-commerce</td> <td>Candidate Generation, Ranking</td> </tr> <tr> <td>Split Network</td> <td>Generalization of Two Towers using neural networks to combine user and item features.</td> <td>Flexible and scalable. Suitable for large-scale systems.</td> <td>Requires efficient synchronization between split components.</td> <td>Large-scale recommendations</td> <td>Candidate Generation, Ranking</td> </tr> </tbody> </table> <h2 id="references">References</h2> <ul> <li>Samuel Flender’s <a href="https://mlfrontiers.substack.com/p/a-tour-of-the-recommender-system" rel="external nofollow noopener" target="_blank">ML Frontiers</a> </li> <li><a href="https://medium.com/better-ml/recsys-model-serving-model-architectures-serving-1b5f038848bd" rel="external nofollow noopener" target="_blank">RecSys model architectures and serving paridigms</a></li> <li><a href="https://blog.research.google/2016/06/wide-deep-learning-better-together-with.html" rel="external nofollow noopener" target="_blank">Wide &amp; Deep Learning: Better Together with TensorFlow</a></li> <li><a href="https://www.tensorflow.org/recommenders/examples/dcn" rel="external nofollow noopener" target="_blank">Deep &amp; Cross Network (DCN)</a></li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/how-to-write-a-good-scientific-review/">How to write a good scientific review?</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/habits/">Habits</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/regulate-your-blood-sugarnourish-to-flourish-harnessing-glycogen-for-peak-performance-at-work/">Regulate your blood sugar! — Nourish to Flourish: Harnessing Glycogen for Peak Performance at Work</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/how-to-lead-when-you-are-not-in-charge/">How to lead when you are not in charge?</a> </li> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>let giscusTheme=determineComputedTheme(),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"lorenz-peter/lorenz-peter.github.io","data-repo-id":"","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Peter Lorenz. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?06cae41083477f121be8cd9797ad8e2f"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"publications by categories in reversed chronological order. generated by jekyll-scholar.",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-projects",title:"projects",description:"A growing collection of your cool projects.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-repositories",title:"repositories",description:"",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-cv",title:"cv",description:"",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-recommender-systems",title:"Recommender Systems",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/recommender-systems/"}},{id:"post-imbalanced-data",title:"Imbalanced Data",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/imbalanced-data/"}},{id:"post-mlsd",title:"MLSD",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/MLSD/"}},{id:"post-dice",title:"DICE",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/dice/"}},{id:"post-standard-ai-libraries-alternatives",title:"Standard AI Libraries Alternatives",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/standard-ai-libraries-alternatives-6190640a9425?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-deepseek-primer",title:"DeepSeek Primer",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/deepseek-primer/"}},{id:"post-adversarial-attacks-on-llms",title:"Adversarial Attacks on LLMs",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/llm-adversarial-attacks/"}},{id:"post-adamsi-fgm",title:"AdaMSI-FGM",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/adaptive-mi-fgsm/"}},{id:"post-a-complete-list-of-all-arxiv-model-stealing-papers-under-construction",title:"A complete list of all (arXiv) model stealing papers (under construction)",description:"shows latest related work",section:"Posts",handler:()=>{window.location.href="/blog/2024/rw_ms/"}},{id:"post-autoattack",title:"AutoAttack",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/autoattack/"}},{id:"post-clear-thinking-turning-ordinary-moments-into-extraordinary-results",title:"Clear Thinking: Turning Ordinary Moments into Extraordinary Results",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/clear-thinking-turning-ordinary-moments-into-extraordinary-results-d2f4dd65c4b7?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-confidence-in-public-speaking-and-presenting",title:"Confidence in public speaking and presenting",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/confidence-in-public-speaking-and-presenting-a9f5fbf34e8a?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-how-to-lead-when-you-are-not-in-charge",title:"How to lead when you are not in charge?",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/how-to-lead-when-you-are-not-in-charge-175e7d9351dd?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-parse-the-paper-list",title:"Parse the Paper List",description:"Parse the json file",section:"Posts",handler:()=>{window.location.href="/blog/2024/load-json/"}},{id:"post-research-trends",title:"Research Trends",description:"an example of how to use Bootstrap Tables",section:"Posts",handler:()=>{window.location.href="/blog/2024/research_trends/"}},{id:"post-regulate-your-blood-sugar-nourish-to-flourish-harnessing-glycogen-for-peak-performance-at-work",title:"Regulate your blood sugar!\u200a\u2014\u200aNourish to Flourish: Harnessing Glycogen for Peak Performance at Work",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/regulate-your-blood-sugar-nourish-to-flourish-harnessing-glycogen-for-peak-performance-at-work-3e711a24fc47?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-a-complete-list-of-all-arxiv-adversarial-examples-adex-papers-under-construction",title:"A complete list of all (arXiv) adversarial examples (AdEx) papers (under construction)",description:"shows latest related work",section:"Posts",handler:()=>{window.location.href="/blog/2024/rw_adex/"}},{id:"post-analysis-of-adversarial-examples-phd-thesis",title:"Analysis of Adversarial Examples (PhD Thesis)",description:"research",section:"Posts",handler:()=>{window.location.href="/blog/2024/phdthesis/"}},{id:"post-habits",title:"Habits",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/habits-07c3bfeba3b1?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-how-to-write-a-good-scientific-review",title:"How to write a good scientific review?",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/how-to-write-a-good-scientific-review-c6c5a5a66847?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-find-the-right-conference",title:"Find the right conference!",description:"conference",section:"Posts",handler:()=>{window.location.href="/blog/2024/findconference/"}},{id:"post-google-gemini-updates-flash-1-5-gemma-2-and-project-astra",title:"Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra",description:"We\u2019re sharing updates across our Gemini family of models and a glimpse of Project Astra, our vision for the future of AI assistants.",section:"Posts",handler:()=>{window.open("https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/","_blank")}},{id:"post-how-do-you-make-your-own-illustrations-for-your-paper",title:"How do you make your own illustrations for your paper?",description:"conference",section:"Posts",handler:()=>{window.location.href="/blog/2024/create-teaser-figure/"}},{id:"post-writeup-gandalf-from-lakera",title:"Writeup Gandalf from Lakera",description:"LLM hacking",section:"Posts",handler:()=>{window.location.href="/blog/2023/gandalf/"}},{id:"news-best-reviewer-award-at-aistats-39-25-https-aistats-org-aistats2025-awards-html",title:"[Best reviewer award at AISTATS&#39;25](https://aistats.org/aistats2025/awards.html)!",description:"",section:"News"},{id:"news-check-out-my-continuously-updated-reading-list-about-model-stealing-https-lorenz-peter-github-io-blog-2024-rw-ms",title:"Check out my continuously updated [reading list about model stealing](https://lorenz-peter.github.io/blog/2024/rw_ms)!",description:"",section:"News"},{id:"news-i-am-happy-to-announce-that-i-am-a-reviewer-at-the-cvpr-workshop-robustness-of-foundation-models-https-cvpr24-advml-github-io",title:"I am happy to announce that I am a reviewer at the [CVPR Workshop Robustness of Foundation Models](https://cvpr24-advml.github.io) \ud83c\udf89",description:"",section:"News"},{id:"news-i-am-accepted-for-the-oxford-summer-school-representation-learning-https-www-oxfordml-school-replearning",title:"I am accepted for the [Oxford Summer School - Representation Learning](https://www.oxfordml.school/replearning)",description:"",section:"News"},{id:"news-i-am-happy-to-announce-that-i-am-reviewer-at-icassp-on-the-topics-federated-split-learning-and-quantum-privacy",title:"I am happy to announce that I am reviewer at ICASSP on the topics federated / split learning and quantum privacy \ud83d\ude04",description:"",section:"News"},{id:"news-check-out-my-writeups-https-lorenz-peter-github-io-blog-2023-gandalf-from-the-lakera-gandalf-hackathon",title:"Check out my [writeups](https://lorenz-peter.github.io/blog/2023/gandalf) from the Lakera Gandalf hackathon.",description:"",section:"News"},{id:"projects-cat-image",title:"Cat image",description:"the famous cat image for adversarial perturbation",section:"Projects",handler:()=>{window.location.href="/projects/cat_image/"}},{id:"projects-cvpr-hackathon-2022",title:"CVPR Hackathon 2022",description:"robust model towards open-world classifications",section:"Projects",handler:()=>{window.location.href="/projects/cvpr_hackathon/"}},{id:"projects-tuglatextemplates",title:"TUGLatexTemplates",description:"A collection of diverse university-related templates.",section:"Projects",handler:()=>{window.location.href="/projects/latex_templates/"}},{id:"projects-oxford-ml-summer-school",title:"Oxford ML Summer School",description:"Attendance certificates",section:"Projects",handler:()=>{window.location.href="/projects/oxford_summers_school/"}},{id:"projects-multimodality-model-slang-visualization",title:"MultiModality Model Slang Visualization",description:"Visualize your slang!",section:"Projects",handler:()=>{window.location.href="/projects/slang_multimodal/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%70%65%74%65%72.%6C%6F%72%65%6E%7A.%77%6F%72%6B@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=sb4hPQMAAAAJ","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/jS5t3r","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/peter-lorenz-06918169","_blank")}},{id:"socials-x",title:"X",description:"Twitter",section:"Socials",handler:()=>{window.open("https://twitter.com/cs_peter_lorenz","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js"></script> </body> </html>