<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> DeepSeek Primer | Peter Lorenz </title> <meta name="author" content="Peter Lorenz"> <meta name="description" content="Personal Website "> <meta name="keywords" content="peter, lorenz, security, deep, learning"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%A7%91%E2%80%8D%F0%9F%92%BB&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://lorenz-peter.github.io/blog/2025/deepseek-primer/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Peter</span> Lorenz </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">DeepSeek Primer</h1> <p class="post-meta"> Created in February 10, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/paper"> <i class="fa-solid fa-hashtag fa-sm"></i> paper</a>   ·   <a href="/blog/category/llm"> <i class="fa-solid fa-tag fa-sm"></i> LLM</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p><a href="https://aman.ai/primers/ai/deepseek-R1" rel="external nofollow noopener" target="_blank">Source</a> Over the time, I will add an change.</p> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#introduction" rel="external nofollow noopener" target="_blank">Introduction</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#architectural-foundations" rel="external nofollow noopener" target="_blank">Architectural Foundations</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#overview" rel="external nofollow noopener" target="_blank">Overview</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#mixture-of-experts-moe" rel="external nofollow noopener" target="_blank">Mixture of Experts (MoE)</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#overview-1" rel="external nofollow noopener" target="_blank">Overview</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#key-features" rel="external nofollow noopener" target="_blank">Key Features</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#evolution-from-deepseek-v2-to-deepseek-r1" rel="external nofollow noopener" target="_blank">Evolution from DeepSeek-V2 to DeepSeek-R1</a> <ul> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#moe-in-deepseek-v2" rel="external nofollow noopener" target="_blank">MoE in DeepSeek-V2</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#basic-architecture-of-deepseekmoe" rel="external nofollow noopener" target="_blank">Basic Architecture of DeepSeekMoE</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#device-limited-routing" rel="external nofollow noopener" target="_blank">Device-Limited Routing</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#auxiliary-loss-for-load-balancing" rel="external nofollow noopener" target="_blank">Auxiliary Loss for Load Balancing</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#token-dropping-strategy" rel="external nofollow noopener" target="_blank">Token-Dropping Strategy</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#enhancements-in-deepseek-v3" rel="external nofollow noopener" target="_blank">Enhancements in DeepSeek-V3</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#auxiliary-loss-free-load-balancing" rel="external nofollow noopener" target="_blank">Auxiliary-Loss-Free Load Balancing</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#node-limited-routing-nlr" rel="external nofollow noopener" target="_blank">Node-Limited Routing (NLR)</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#improved-expert-selection-mechanism" rel="external nofollow noopener" target="_blank">Improved Expert Selection Mechanism</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#enhanced-sparsity-constraints-with-hierarchical-gating" rel="external nofollow noopener" target="_blank">Enhanced Sparsity Constraints with Hierarchical Gating</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#no-token-dropping-strategy" rel="external nofollow noopener" target="_blank">No Token-Dropping Strategy</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#enhancements-in-deepseek-r1" rel="external nofollow noopener" target="_blank">Enhancements in DeepSeek-R1</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#adaptive-expert-routing-with-reinforcement-learning-rl" rel="external nofollow noopener" target="_blank">Adaptive Expert Routing with Reinforcement Learning (RL)</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#hierarchical-entropy-gated-moe-he-moe" rel="external nofollow noopener" target="_blank">Hierarchical Entropy-Gated MoE (HE-MoE)</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#device-constrained-expert-allocation-dcea" rel="external nofollow noopener" target="_blank">Device-Constrained Expert Allocation (DCEA)</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#load-balanced-expert-utilization-with-rl-based-adjustments" rel="external nofollow noopener" target="_blank">Load-Balanced Expert Utilization with RL-Based Adjustments</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#elimination-of-token-dropping-strategy" rel="external nofollow noopener" target="_blank">Elimination of Token-Dropping Strategy</a></li> </ul> </li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#comparative-analysis" rel="external nofollow noopener" target="_blank">Comparative Analysis</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#mathematical-formulation" rel="external nofollow noopener" target="_blank">Mathematical Formulation</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#load-balancing-loss" rel="external nofollow noopener" target="_blank">Load Balancing Loss</a></li> </ul> </li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#multihead-latent-attention-mla" rel="external nofollow noopener" target="_blank">Multihead Latent Attention (MLA)</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#overview-2" rel="external nofollow noopener" target="_blank">Overview</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#key-features-1" rel="external nofollow noopener" target="_blank">Key Features</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#evolution-from-deepseek-v2-to-deepseek-r1-1" rel="external nofollow noopener" target="_blank">Evolution from DeepSeek-V2 to DeepSeek-R1</a> <ul> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#mla-in-deepseek-v2" rel="external nofollow noopener" target="_blank">MLA in DeepSeek-V2</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#low-rank-key-value-joint-compression" rel="external nofollow noopener" target="_blank">Low-Rank Key-Value Joint Compression</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#decoupled-rotary-position-embedding" rel="external nofollow noopener" target="_blank">Decoupled Rotary Position Embedding</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#comparison-of-kv-cache-requirements" rel="external nofollow noopener" target="_blank">Comparison of KV Cache Requirements</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#enhancements-in-deepseek-v3-1" rel="external nofollow noopener" target="_blank">Enhancements in DeepSeek-V3</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#further-kv-cache-reduction-through-optimized-compression-techniques" rel="external nofollow noopener" target="_blank">Further KV Cache Reduction Through Optimized Compression Techniques</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#optimized-compression-formulation" rel="external nofollow noopener" target="_blank">Optimized Compression Formulation</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#inference-time-expansion" rel="external nofollow noopener" target="_blank">Inference-Time Expansion</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#query-compression-for-activation-memory-savings" rel="external nofollow noopener" target="_blank">Query Compression for Activation Memory Savings</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#reduction-in-activation-memory" rel="external nofollow noopener" target="_blank">Reduction in Activation Memory</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#enhanced-numerical-stability-with-fp8-mixed-precision" rel="external nofollow noopener" target="_blank">Enhanced Numerical Stability with FP8 Mixed Precision</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#adaptive-routing-for-load-balancing-in-mla" rel="external nofollow noopener" target="_blank">Adaptive Routing for Load Balancing in MLA</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#enhancements-in-deepseek-r1-1" rel="external nofollow noopener" target="_blank">Enhancements in DeepSeek-R1</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#rl-guided-latent-attention-optimization" rel="external nofollow noopener" target="_blank">RL-Guided Latent Attention Optimization</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#adaptive-query-and-key-compression-via-rl" rel="external nofollow noopener" target="_blank">Adaptive Query and Key Compression Via RL</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#decoupled-rotary-position-embedding-with-context-specific-scaling" rel="external nofollow noopener" target="_blank">Decoupled Rotary Position Embedding with Context-Specific Scaling</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#fp8-mixed-precision-for-mla-stability" rel="external nofollow noopener" target="_blank">FP8 Mixed Precision for MLA Stability</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#adaptivedynamic-routing-for-load-balanced-attention" rel="external nofollow noopener" target="_blank">Adaptive/Dynamic Routing for Load-Balanced Attention</a></li> </ul> </li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#comparative-analysis-1" rel="external nofollow noopener" target="_blank">Comparative Analysis</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#implementation" rel="external nofollow noopener" target="_blank">Implementation</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#background-standard-multi-head-attention-mha" rel="external nofollow noopener" target="_blank">Background: Standard Multi-Head Attention (MHA)</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#low-rank-key-value-joint-compression-1" rel="external nofollow noopener" target="_blank">Low-Rank Key-Value Joint Compression</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#multi-stage-compression" rel="external nofollow noopener" target="_blank">Multi-Stage Compression</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#query-compression-and-optimization" rel="external nofollow noopener" target="_blank">Query Compression and Optimization</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#decoupled-rotary-position-embedding-rope" rel="external nofollow noopener" target="_blank">Decoupled Rotary Position Embedding (RoPE)</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#attention-computation-in-mla" rel="external nofollow noopener" target="_blank">Attention Computation in MLA</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#rl-optimized-mla" rel="external nofollow noopener" target="_blank">RL-Optimized MLA</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#computational-and-hardware-optimization" rel="external nofollow noopener" target="_blank">Computational and Hardware Optimization</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#comparative-efficiency-analysis" rel="external nofollow noopener" target="_blank">Comparative Efficiency Analysis</a></li> </ul> </li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#multi-token-prediction-mtp" rel="external nofollow noopener" target="_blank">Multi-Token Prediction (MTP)</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#overview-3" rel="external nofollow noopener" target="_blank">Overview</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#key-features-2" rel="external nofollow noopener" target="_blank">Key Features</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#evolution-from-deepseek-v3-to-deepseek-r1" rel="external nofollow noopener" target="_blank">Evolution from DeepSeek-V3 to DeepSeek-R1</a> <ul> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#mtp-in-deepseek-v3" rel="external nofollow noopener" target="_blank">MTP in DeepSeek-V3</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#sequential-multi-token-prediction-modules" rel="external nofollow noopener" target="_blank">Sequential Multi-Token Prediction Modules</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#mtp-training-objective" rel="external nofollow noopener" target="_blank">MTP Training Objective</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#memory-optimization-with-shared-embeddings-and-output-heads" rel="external nofollow noopener" target="_blank">Memory Optimization with Shared Embeddings and Output Heads</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#inference-strategy-and-speculative-decoding" rel="external nofollow noopener" target="_blank">Inference Strategy and Speculative Decoding</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#ablation-studies-on-multi-token-prediction" rel="external nofollow noopener" target="_blank">Ablation Studies on Multi-Token Prediction</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#enhancements-in-deepseek-r1-2" rel="external nofollow noopener" target="_blank">Enhancements in DeepSeek-R1</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#improved-token-dependency-modeling-in-mtp" rel="external nofollow noopener" target="_blank">Improved Token Dependency Modeling in MTP</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#adaptive-prediction-granularity" rel="external nofollow noopener" target="_blank">Adaptive Prediction Granularity</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#loss-function-refinement-for-multi-depth-learning" rel="external nofollow noopener" target="_blank">Loss Function Refinement for Multi-Depth Learning</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#optimized-memory-efficiency-with-parameter-sharing" rel="external nofollow noopener" target="_blank">Optimized Memory Efficiency with Parameter Sharing</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#enhanced-inference-strategy-with-speculative-decoding" rel="external nofollow noopener" target="_blank">Enhanced Inference Strategy with Speculative Decoding</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#empirical-gains-from-deepseek-r1s-mtp-enhancements" rel="external nofollow noopener" target="_blank">Empirical Gains from DeepSeek-R1’s MTP Enhancements</a></li> </ul> </li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#comparative-analysis-2" rel="external nofollow noopener" target="_blank">Comparative Analysis</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#implementation-details" rel="external nofollow noopener" target="_blank">Implementation Details</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#mathematical-formulation-1" rel="external nofollow noopener" target="_blank">Mathematical Formulation</a></li> </ul> </li> </ul> </li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#training-pipeline-from-pre-training-to-reasoning" rel="external nofollow noopener" target="_blank">Training Pipeline: from Pre-Training to Reasoning</a> <ul> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#stage-1-cold-start-with-sft" rel="external nofollow noopener" target="_blank">Stage 1: Cold Start with SFT</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#fine-tuning-with-high-quality-chain-of-thought-cot-examples" rel="external nofollow noopener" target="_blank">Fine-Tuning with High-Quality Chain-of-Thought (CoT) Examples</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#structured-output-format" rel="external nofollow noopener" target="_blank">Structured Output Format</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#loss-function-for-sft" rel="external nofollow noopener" target="_blank">Loss Function for SFT</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#stage-2-rl" rel="external nofollow noopener" target="_blank">Stage 2: RL</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#deepseeks-rl-methodology-a-conceptual-overview" rel="external nofollow noopener" target="_blank">DeepSeek’s RL Methodology: a Conceptual Overview</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#policy-optimization-background" rel="external nofollow noopener" target="_blank">Policy Optimization: Background</a> <ul> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#the-reinforce-algorithm" rel="external nofollow noopener" target="_blank">The REINFORCE Algorithm</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#what-is-reinforce" rel="external nofollow noopener" target="_blank">What is REINFORCE?</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#limitations-of-reinforce" rel="external nofollow noopener" target="_blank">Limitations of REINFORCE</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#how-grpo-builds-on-reinforce" rel="external nofollow noopener" target="_blank">How GRPO Builds on REINFORCE</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#proximal-policy-optimization-ppo" rel="external nofollow noopener" target="_blank">Proximal Policy Optimization (PPO)</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#how-ppo-works" rel="external nofollow noopener" target="_blank">How PPO Works</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#challenges-with-ppo" rel="external nofollow noopener" target="_blank">Challenges with PPO</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#how-grpo-builds-on-ppo" rel="external nofollow noopener" target="_blank">How GRPO Builds on PPO</a></li> </ul> </li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#group-relative-policy-optimization-grpo" rel="external nofollow noopener" target="_blank">Group Relative Policy Optimization (GRPO)</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#key-innovations" rel="external nofollow noopener" target="_blank">Key Innovations</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#evolution-of-grpo-from-deepseekmath-to-deepseek-r1" rel="external nofollow noopener" target="_blank">Evolution of GRPO: from DeepSeekMath to DeepSeek-R1</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#phase-1-grpo-in-deepseekmath-mathematical-rl" rel="external nofollow noopener" target="_blank">Phase 1: GRPO in DeepSeekMath (Mathematical RL)</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#phase-2-grpo-in-deepseek-r1-zero-self-evolving-reasoning" rel="external nofollow noopener" target="_blank">Phase 2: GRPO in DeepSeek-R1-Zero (Self-Evolving Reasoning)</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#phase-3-grpo-in-deepseek-r1-refined-reasoning--cold-start" rel="external nofollow noopener" target="_blank">Phase 3: GRPO in DeepSeek-R1 (Refined Reasoning &amp; Cold Start)</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#how-grpo-works" rel="external nofollow noopener" target="_blank">How GRPO Works</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#grpo-intuition" rel="external nofollow noopener" target="_blank">GRPO Intuition</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#grpo-workflow" rel="external nofollow noopener" target="_blank">GRPO Workflow</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#mathematical-formulation-2" rel="external nofollow noopener" target="_blank">Mathematical Formulation</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#step-by-step-breakdown" rel="external nofollow noopener" target="_blank">Step-by-Step Breakdown</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#likelihood-ratio-rho_i" rel="external nofollow noopener" target="_blank">Likelihood Ratio ρi</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#advantage-function-a_i" rel="external nofollow noopener" target="_blank">Advantage Function Ai</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#clipping-mechanism" rel="external nofollow noopener" target="_blank">Clipping Mechanism</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#kl-divergence-penalty" rel="external nofollow noopener" target="_blank">KL Divergence Penalty</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#implementation-details-1" rel="external nofollow noopener" target="_blank">Implementation Details</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#training-setup" rel="external nofollow noopener" target="_blank">Training Setup</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#reward-function-design" rel="external nofollow noopener" target="_blank">Reward Function Design</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#optimization-process" rel="external nofollow noopener" target="_blank">Optimization Process</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#efficiency-considerations" rel="external nofollow noopener" target="_blank">Efficiency Considerations</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#applications" rel="external nofollow noopener" target="_blank">Applications</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#deepseek-r1-zero-rl-from-scratch" rel="external nofollow noopener" target="_blank">DeepSeek-R1-Zero: RL from Scratch</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#deepseek-r1-multi-stage-rl-with-cold-start" rel="external nofollow noopener" target="_blank">DeepSeek-R1: Multi-Stage RL with Cold Start</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#comparative-analysis-reinforce-vs-trpo-vs-ppo-vs-dpo-vs-kto-vs-apo-vs-grpo" rel="external nofollow noopener" target="_blank">Comparative Analysis: REINFORCE vs. TRPO vs. PPO vs. DPO vs. KTO vs. APO vs. GRPO</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#tabular-comparison" rel="external nofollow noopener" target="_blank">Tabular Comparison</a></li> </ul> </li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#reward-functions" rel="external nofollow noopener" target="_blank">Reward Functions</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#accuracy-rewards" rel="external nofollow noopener" target="_blank">Accuracy Rewards</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#format-rewards" rel="external nofollow noopener" target="_blank">Format Rewards</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#combined-reward-function" rel="external nofollow noopener" target="_blank">Combined Reward Function</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#why-rule-based-rewards-instead-of-neural-reward-models" rel="external nofollow noopener" target="_blank">Why Rule-Based Rewards Instead of Neural Reward Models?</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#implementation-in-grpo" rel="external nofollow noopener" target="_blank">Implementation in GRPO</a></li> </ul> </li> </ul> </li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#stage-3-rejection-sampling--expanded-supervised-fine-tuning" rel="external nofollow noopener" target="_blank">Stage 3: Rejection Sampling &amp; Expanded Supervised Fine-Tuning</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#stage-4-secondary-rl-for-alignment--generalization" rel="external nofollow noopener" target="_blank">Stage 4: Secondary RL for Alignment &amp; Generalization</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#comparing-training-pipelines-deepseek-r1-vs-deepseek-r1-zero" rel="external nofollow noopener" target="_blank">Comparing Training Pipelines: DeepSeek-R1 vs. DeepSeek-R1-Zero</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#pre-training-and-initialization" rel="external nofollow noopener" target="_blank">Pre-Training and Initialization</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#rl-strategy" rel="external nofollow noopener" target="_blank">RL Strategy</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#deepseek-r1-zero-pure-rl-approach" rel="external nofollow noopener" target="_blank">DeepSeek-R1-Zero: Pure RL Approach</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#deepseek-r1-multi-stage-rl-with-cold-start-fine-tuning" rel="external nofollow noopener" target="_blank">DeepSeek-R1: Multi-Stage RL with Cold-Start Fine-Tuning</a></li> </ul> </li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#implementation-details-and-computational-efficiency" rel="external nofollow noopener" target="_blank">Implementation Details and Computational Efficiency</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#final-performance-impact" rel="external nofollow noopener" target="_blank">Final Performance Impact</a></li> </ul> </li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#emergent-reasoning-behaviors" rel="external nofollow noopener" target="_blank">Emergent Reasoning Behaviors</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#implementation-details-2" rel="external nofollow noopener" target="_blank">Implementation Details</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#example-quadratic-equation-solving" rel="external nofollow noopener" target="_blank">Example: Quadratic Equation Solving</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#distillation-reasoning-in-compact-models" rel="external nofollow noopener" target="_blank">Distillation: Reasoning in Compact Models</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#implementation-details-3" rel="external nofollow noopener" target="_blank">Implementation Details</a></li> </ul> </li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#results" rel="external nofollow noopener" target="_blank">Results</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#average-response-length-vs-timesteps" rel="external nofollow noopener" target="_blank">Average Response Length vs. Timesteps</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#comparison-of-deepseek-r1-and-deepseek-r1-zero" rel="external nofollow noopener" target="_blank">Comparison of DeepSeek-R1 and DeepSeek-R1-Zero</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#training-approach" rel="external nofollow noopener" target="_blank">Training Approach</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#performance-differences" rel="external nofollow noopener" target="_blank">Performance Differences</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#readability-and-language-consistency" rel="external nofollow noopener" target="_blank">Readability and Language Consistency</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#self-evolution-and-aha-moments" rel="external nofollow noopener" target="_blank">Self-Evolution and “Aha Moments”</a></li> </ul> </li> </ul> </li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#open-questions" rel="external nofollow noopener" target="_blank">Open Questions</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#other-reasoning-models" rel="external nofollow noopener" target="_blank">Other Reasoning Models</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#qwq-reflect-deeply-on-the-boundaries-of-the-unknown" rel="external nofollow noopener" target="_blank">QwQ: Reflect Deeply on the Boundaries of the Unknown</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#s1-simple-test-time-scaling" rel="external nofollow noopener" target="_blank">S1: Simple Test-Time Scaling</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#sky-t1" rel="external nofollow noopener" target="_blank">Sky-T1</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#kimi-k15-scaling-reinforcement-learning-with-llms" rel="external nofollow noopener" target="_blank">Kimi K1.5: Scaling Reinforcement Learning with LLMs</a></li> <li> <a href="https://aman.ai/primers/ai/deepseek-R1/#open-r1" rel="external nofollow noopener" target="_blank">Open-R1</a> <ul> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#objectives-of-open-r1" rel="external nofollow noopener" target="_blank">Objectives of Open-R1</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#impact-on-the-community" rel="external nofollow noopener" target="_blank">Impact on the Community</a></li> </ul> </li> </ul> </li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#reasoning-datasets" rel="external nofollow noopener" target="_blank">Reasoning Datasets</a></li> <li><a href="https://aman.ai/primers/ai/deepseek-R1/#references" rel="external nofollow noopener" target="_blank">References</a></li> </ul> <h2 id="introduction">Introduction</h2> <ul> <li> <a href="https://arxiv.org/abs/2501.12948" rel="external nofollow noopener" target="_blank">DeepSeek-R1 and DeepSeek-R1-Zero</a> represent a landmark in reasoning-capable Large Language Models (LLMs). <a href="https://huggingface.co/deepseek-ai/DeepSeek-R1" rel="external nofollow noopener" target="_blank">Released</a> under an MIT license, this model rivals closed-source giants like OpenAI’s o1 and o3 series while pioneering a reinforcement learning (RL)-driven framework for reasoning tasks.</li> <li>Both models leverage Group Relative Policy Optimization (GRPO), introduced in <a href="https://arxiv.org/abs/2402.03300" rel="external nofollow noopener" target="_blank">DeepSeekMath</a>, which replaces traditional methods like PPO, making training both efficient and scalable. They also utilize Multihead Latent Attention (MLA), introduced in <a href="https://arxiv.org/pdf/2405.04434" rel="external nofollow noopener" target="_blank">DeepSeek-V2</a>, which reduces computational and memory inefficiencies particularly for long-context processing by projecting Key-Query-Value (KQV) matrices into a lower-dimensional latent space.</li> <li>DeepSeek-R1-Zero demonstrates how reasoning capabilities emerge naturally purely through RL without any Supervised Fine-Tuning (SFT). By relying solely on self-evolution through RL, DeepSeek-R1-Zero naturally developed powerful reasoning behaviors but also exhibited challenges such as poor readability and language mixing. DeepSeek-R1 built upon this foundation and addressed the aforementioned issues by incorporating multi-stage training and a small amount of cold-start data to improve reasoning performance and usability.</li> <li>Through innovations like GRPO, FP8 quantization, and emergent Chain-of-Thought (CoT) reasoning, both models rival closed-source models while fostering transparency and accessibility. As the research community builds upon these innovations, DeepSeek-R1 signals a shift towards efficient, reasoning-driven AI accessible to all.</li> <li>This primer explores its architecture, multi-stage training pipeline, GRPO mechanics, and emergent reasoning behaviors, alongside how distillation propagates reasoning capabilities to smaller models.</li> </ul> <h2 id="architectural-foundations">Architectural Foundations</h2> <ul> <li>DeepSeek-R1 builds upon the foundational advancements introduced in <a href="https://arxiv.org/abs/2405.04434" rel="external nofollow noopener" target="_blank">DeepSeek-V2</a> — specifically, Mixture of Experts (MoE) and Multihead Latent Attention (MLA) — and <a href="https://arxiv.org/abs/2412.19437" rel="external nofollow noopener" target="_blank">DeepSeek-V3</a> — specifically, Multi-Token Prediction (MTP) — integrating cutting-edge architectural innovations that optimize both training efficiency and inference performance.</li> <li>This section provides a detailed breakdown of the architectural components that evolved from DeepSeek-V2 and DeepSeek-V3 to DeepSeek-R1, highlighting improvements that make DeepSeek-R1 a leading open-source model, capable of rivaling proprietary alternatives in reasoning efficiency and performance.</li> </ul> <h3 id="overview">Overview</h3> <ul> <li> <p>DeepSeek-R1 incorporates several advanced techniques to achieve remarkable efficiency improvements:</p> <ol> <li> <p><strong>Mixture of Experts (MoE) Architecture</strong>: DeepSeek-R1 utilizes a Mixture of Experts model, which decomposes a large model into smaller, specialized sub-models. This architecture allows for the activation of only relevant sub-models during specific tasks, enabling the system to operate efficiently on consumer-grade GPUs.</p> </li> <li> <p><strong>Key-Value Memory Compression via Multihead Latent Attention (MLA)</strong>: By implementing sophisticated compression algorithms, DeepSeek-R1 achieves a 93% reduction in the storage requirements for key-value indices, which are known to consume considerable amounts of VRAM.</p> </li> <li> <p><strong>Multi-Token Prediction</strong>: DeepSeek-R1 is designed to predict multiple tokens simultaneously rather than one at a time. This strategy effectively doubles the inference speed, enhancing overall performance.</p> </li> <li> <p><strong>Low-Precision Computation</strong>: DeepSeek-R1 employs mixed-precision arithmetic, performing a significant portion of computations using 8-bit floating-point numbers instead of the standard 32-bit. This approach substantially reduces memory consumption and accelerates processing speeds.</p> </li> </ol> </li> <li> <p>Collectively, these innovations contribute to DeepSeek-R1’s significant advancements in training efficiency, reportedly achieving a 45-fold improvement over previous models.</p> </li> </ul> <h3 id="mixture-of-experts-moe">Mixture of Experts (MoE)</h3> <h4 id="overview-1">Overview</h4> <ul> <li>The MoE mechanism selectively activates a subset of the total model parameters at each inference step, achieving computational savings while maintaining model quality. This approach enables scaling up model parameters without a proportional increase in computational cost.</li> <li>DeepSeek-R1 refines DeepSeek-V2’s MoE framework, introducing dynamic expert routing, reinforcement learning-based load balancing, and enhanced sparsity constraints. These innovations make DeepSeek-R1 one of the most efficient and scalable open-source MoE models available.</li> </ul> <h4 id="key-features">Key Features</h4> <ul> <li> <p><strong>Reinforcement Learning-Based Expert Routing</strong>: DeepSeek-R1 replaces static gating functions with a reinforcement learning (RL) policy to dynamically assign tokens to experts. The RL-based router optimizes expert selection by maximizing load balancing while minimizing routing entropy, leading to more efficient token-expert mapping.</p> </li> <li> <p><strong>Hierarchical Entropy-Gated MoE (HE-MoE)</strong>: The expert selection process is refined with a multi-level gating mechanism. Tokens first pass through a global selection phase, followed by cluster-level pruning, and finally, an entropy-aware adjustment ensures balanced expert activation. This approach prevents expert over-specialization and improves generalization.</p> </li> <li> <p><strong>Device-Constrained Expert Allocation (DCEA)</strong>: Experts are assigned based on available compute resources, reducing cross-device communication overhead. The model selects experts within a constrained pool of devices, lowering synchronization costs and increasing training efficiency.</p> </li> <li> <p><strong>Load-Balanced Expert Utilization with RL-Based Adjustments</strong>: Instead of relying on auxiliary loss functions to balance load, DeepSeek-R1 dynamically adjusts expert activation probabilities using RL-based bias terms. This ensures consistent workload distribution without additional loss penalties, improving stability and convergence.</p> </li> <li> <p><strong>Full Token Retention (No Token Dropping)</strong>: Unlike earlier iterations that dropped low-affinity tokens to balance computational load, DeepSeek-R1 retains all tokens during both training and inference. This ensures that no information is lost, leading to improved model coherence and generalization.</p> </li> <li> <p><strong>Cross-Device Communication Optimization</strong>: With DCEA and hierarchical expert gating, DeepSeek-R1 significantly reduces inter-device communication, leading to up to a 35% decrease in latency. This optimization enhances efficiency without sacrificing model performance.</p> </li> <li> <p><strong>Dynamic Expert Activation</strong>: The model adapts expert selection dynamically using learned routing strategies, ensuring efficient allocation of computational resources. This allows DeepSeek-R1 to scale effectively without a linear increase in computational cost.</p> </li> <li> <p><strong>Adaptive Expert Specialization</strong>: By incorporating entropy-based constraints, DeepSeek-R1 ensures that experts remain specialized but not overly rigid. This dynamic specialization enhances both accuracy and efficiency while maintaining flexibility in expert activation.</p> </li> </ul> <h4 id="evolution-from-deepseek-v2-to-deepseek-r1">Evolution from DeepSeek-V2 to DeepSeek-R1</h4> <h5 id="moe-in-deepseek-v2">MoE in DeepSeek-V2</h5> <ul> <li>DeepSeek-V2 introduces a specialized MoE architecture called DeepSeekMoE, which optimizes model training efficiency and inference throughput while maintaining strong performance. This architecture refines expert selection, routing, and load balancing strategies to reduce computational overhead. Below, we detail the MoE-specific mechanisms in DeepSeek-V2, breaking them down into their individual components.</li> </ul> <h6 id="basic-architecture-of-deepseekmoe">Basic Architecture of DeepSeekMoE</h6> <ul> <li>DeepSeekMoE is designed with fine-grained expert segmentation and shared expert isolation, which increase specialization while reducing redundancy. The MoE architecture in DeepSeek-V2 consists of: <ul> <li>Ns shared experts, which process all tokens.</li> <li>Nr routed experts, which are selectively activated for tokens based on a gating function.</li> <li>Each token is processed by a fixed number Kr of routed experts.</li> </ul> </li> <li> <p>The output of the MoE layer is computed as:</p> <p>ht′=ut+∑i=1NsFFNi(s)(ut)+∑i=1Nrgi,tFFNi(r)(ut)</p> <ul> <li>where: <ul> <li>FFNi(s) represents a shared expert.</li> <li>FFNi(r) represents a routed expert.</li> <li>gi,t is the gating function, determining expert selection for token t.</li> </ul> </li> </ul> </li> <li> <p>The gating function follows:</p> <p>gi,t={si,t,si,t∈Top-Kr({sj,t∣1≤j≤Nr})0,otherwise</p> <ul> <li>where si,t is the softmax-weighted token-expert affinity:</li> </ul> <p>si,t=Softmaxi(utTei)</p> <ul> <li>where ei is the centroid of expert i.</li> </ul> </li> </ul> <h6 id="device-limited-routing">Device-Limited Routing</h6> <ul> <li>One of the major computational bottlenecks in MoE models is the communication overhead introduced by expert parallelism. To address this, DeepSeekMoE implements device-limited routing, restricting the number of devices a token’s experts can be distributed across.</li> <li> <strong>Key implementation details:</strong> <ul> <li>Each token first selects M devices with the highest affinity scores.</li> <li>The final Kr experts are chosen only from these selected devices.</li> </ul> </li> <li>In practice, setting M≥3 ensures performance close to unrestricted routing while significantly reducing inter-device communication.</li> </ul> <h5 id="auxiliary-loss-for-load-balancing">Auxiliary Loss for Load Balancing</h5> <ul> <li> <p>DeepSeek-V2 employs multiple auxiliary losses to ensure balanced expert utilization, avoiding situations where certain experts become overloaded while others remain underutilized. Specifics below:</p> <ul> <li> <p><strong>Expert-Level Balance Loss</strong>:</p> <ul> <li>To prevent routing collapse, where only a subset of experts get trained, DeepSeek-V2 minimizes:</li> </ul> <p>LExpBal=α1∑i=1NrfiPi</p> <ul> <li>where: <ul> <li>fi is the fraction of tokens routed to expert i,</li> <li>Pi is the average probability of selecting expert i,</li> <li>α1 is a hyperparameter controlling the strength of the loss.</li> </ul> </li> </ul> </li> <li> <p><strong>Device-Level Balance Loss</strong>:</p> <ul> <li>To distribute computation evenly across devices, DeepSeekMoE assigns experts to D device groups, where each group runs on a separate device. The balance loss is:</li> </ul> <p>LDevBal=α2∑i=1Dfi′Pi′</p> <ul> <li>where fi′ and Pi′ aggregate usage statistics across all experts on device i.</li> </ul> </li> <li> <p><strong>Communication Balance Loss</strong>:</p> <ul> <li>This loss ensures that each device receives an approximately equal number of tokens, preventing bottlenecks caused by excessive communication loads:</li> </ul> <p>LCommBal=α3∑i=1Dfi″Pi″</p> <ul> <li>where fi″ and Pi″ measure the fraction of tokens sent to device i.</li> </ul> </li> </ul> </li> </ul> <h6 id="token-dropping-strategy">Token-Dropping Strategy</h6> <ul> <li>While auxiliary losses improve balance, they cannot strictly guarantee uniform expert utilization. To further mitigate inefficiencies, DeepSeek-V2 implements a token-dropping strategy at the device level: <ul> <li>The computational budget per device is first estimated.</li> <li>Tokens with the lowest affinity scores are dropped until the budget is met.</li> <li>At least 10% of training sequences are exempted from token dropping to ensure diversity.</li> </ul> </li> <li>This approach allows flexibility in dynamically adjusting token retention during inference based on computational constraints.</li> </ul> <h5 id="enhancements-in-deepseek-v3">Enhancements in DeepSeek-V3</h5> <ul> <li>DeepSeek-V3 introduces several significant improvements to the MoE framework compared to DeepSeek-V2. These enhancements primarily focus on increasing model efficiency, reducing training and inference costs, and maintaining high performance. The key improvements include an auxiliary-loss-free load balancing strategy, node-limited routing, improved expert selection mechanisms, and enhanced sparsity constraints. These advancements contribute to more efficient training, faster inference, and superior performance compared to DeepSeek-V2.</li> </ul> <h6 id="auxiliary-loss-free-load-balancing">Auxiliary-Loss-Free Load Balancing</h6> <ul> <li> <p>In contrast to DeepSeek-V2, which relies on auxiliary losses to ensure balanced expert utilization, DeepSeek-V3 introduces an auxiliary-loss-free strategy. Instead of penalizing imbalance with additional loss terms, DeepSeek-V3 dynamically adjusts expert selection using bias terms. The expert gating function is modified as follows:</p> <table> <tbody> <tr> <td>gi,t′={si,t,si,t+bi∈Top-Kr({sj,t+bj</td> <td>1≤j≤Nr})0,otherwise</td> </tr> </tbody> </table> <ul> <li>where bi is a bias term adjusted dynamically based on the load of expert i over multiple training steps:</li> </ul> <p>bi←bi−γif expert i is overloaded, otherwise bi←bi+γ.</p> </li> <li> <p>This dynamic adjustment ensures that expert load remains balanced without requiring auxiliary loss penalties, leading to better training stability and efficiency.</p> </li> </ul> <h6 id="node-limited-routing-nlr">Node-Limited Routing (NLR)</h6> <ul> <li>DeepSeek-V3 introduces Node-Limited Routing (NLR) to further optimize communication overhead in large-scale MoE training. Instead of allowing tokens to be dispatched to any expert across the model, NLR restricts the number of nodes each token can communicate with. The routing mechanism selects at most M nodes per token, ensuring that experts are assigned in a way that minimizes inter-node synchronization.</li> </ul> <table> <tbody> <tr> <td>M=∑i=1Nmax{sj,t</td> <td>j∈node i}</td> </tr> </tbody> </table> <ul> <li>This approach significantly reduces cross-node communication overhead, leading to faster training and inference times.</li> </ul> <h6 id="improved-expert-selection-mechanism">Improved Expert Selection Mechanism</h6> <ul> <li> <p>DeepSeek-V3 refines expert selection by incorporating a sigmoid-based token-expert affinity function instead of the softmax-based mechanism used in DeepSeek-V2. The new function is defined as:</p> <p>si,t=σ(utTei)</p> <ul> <li>where ei is the centroid of expert i and σ(⋅) is the sigmoid activation function. The selection process then normalizes the top-Kr expert scores:</li> </ul> <p>gi,t=gi,t′∑j∈Top-Krgj,t′.</p> </li> <li> <p>This modification prevents extreme expert selection probabilities, leading to better load balancing and specialization.</p> </li> </ul> <h6 id="enhanced-sparsity-constraints-with-hierarchical-gating">Enhanced Sparsity Constraints with Hierarchical Gating</h6> <ul> <li> <p>To avoid over-specialization and encourage generalization, DeepSeek-V3 introduces hierarchical gating. Unlike traditional top-K gating, this method applies sparsity constraints at multiple levels:</p> <ul> <li> <strong>Global Selection:</strong> Initial selection of Ng experts at a coarse level.</li> <li> <strong>Cluster-Level Pruning:</strong> Further filtering experts within selected clusters to obtain Kr experts.</li> <li> <strong>Entropy-Based Adjustments:</strong> Adjusting expert activation probabilities based on entropy constraints to avoid extreme sparsity.</li> </ul> </li> <li> <p>Mathematically, the entropy-based adjustment modifies gating scores as follows:</p> <p>gi,t=gi,t×(1−λ⋅H(g1:Nr,t))</p> <ul> <li>where H(⋅) is the entropy function and λ is a regularization coefficient controlling the trade-off between uniform selection and specialization.</li> </ul> </li> </ul> <h6 id="no-token-dropping-strategy">No Token-Dropping Strategy</h6> <ul> <li>DeepSeek-V2 implemented a token-dropping strategy to balance computation per device. However, DeepSeek-V3’s enhanced load-balancing mechanism eliminates the need for token dropping, ensuring 100% token retention during both training and inference. This improves generalization and avoids loss of information during model updates.</li> </ul> <h5 id="enhancements-in-deepseek-r1">Enhancements in DeepSeek-R1</h5> <ul> <li>DeepSeek-R1 introduces several major enhancements to the MoE framework that improve computational efficiency, load balancing, and inference accuracy. These enhancements build upon DeepSeek-V3’s optimizations, integrating reinforcement learning-based routing strategies, entropy-controlled gating, and fine-grained expert specialization. Below, we break down the key MoE innovations in DeepSeek-R1.</li> </ul> <h6 id="adaptive-expert-routing-with-reinforcement-learning-rl">Adaptive Expert Routing with Reinforcement Learning (RL)</h6> <ul> <li>DeepSeek-R1 introduces RL-based expert routing, moving away from static routing approaches used in DeepSeek-V3. Instead of selecting experts based purely on token-expert affinities computed via softmax functions, DeepSeek-R1 incorporates a learned RL policy to dynamically assign tokens to experts.</li> <li> <p><strong>Mathematical Formulation:</strong></p> <ul> <li>The expert selection function is formulated as an RL policy optimization problem, where the probability of selecting expert ei for token t is adjusted dynamically based on token embeddings ut:</li> </ul> <table> <tbody> <tr> <td>gi,t=πθ(ei</td> <td>ut)</td> </tr> </tbody> </table> <ul> <li>where πθ is the policy network that selects experts based on contextual embeddings. The optimization objective follows GRPO:</li> </ul> <table> <tbody> <tr> <td>JGRPO(θ)=Eq∼P(Q),{oi}i=1G∼πθold[1G∑i=1Gmin(πθ(oi</td> <td>q)πθold(oi</td> <td>q)Ai,clip(⋅))−βDKL(πθ</td> <td> </td> <td>πref)]</td> </tr> </tbody> </table> <ul> <li>where DKL regularizes the policy update to prevent drastic shifts.</li> </ul> </li> <li> <strong>Implementation Details:</strong> <ul> <li>The RL-based router learns optimal token assignments by maximizing expert load balancing and minimizing routing entropy.</li> <li>It penalizes overloading of specific experts while incentivizing uniform activation across layers.</li> <li>Dynamic bias terms are introduced into the routing function to further modulate expert selection in response to training feedback.</li> </ul> </li> <li>This approach enables adaptive token-expert mapping, optimizing inference speed while maintaining accuracy.</li> </ul> <h6 id="hierarchical-entropy-gated-moe-he-moe">Hierarchical Entropy-Gated MoE (HE-MoE)</h6> <ul> <li> <p>DeepSeek-R1 enhances top-K MoE routing by introducing Hierarchical Entropy-Gated MoE (HE-MoE). Instead of applying a single top-K gating function at the token level, DeepSeek-R1 implements a multi-level gating mechanism:</p> <ul> <li> <strong>Global Selection:</strong> Tokens are first routed to an initial pool of Ng experts using softmax affinity scoring.</li> <li> <strong>Cluster-Level Pruning:</strong> Within the selected pool, a secondary gating mechanism prunes experts based on entropy constraints.</li> <li> <strong>Final Expert Assignment:</strong> Top-Kr experts are chosen using an adjusted probability function that incorporates an entropy-aware penalty.</li> </ul> </li> <li> <p>The final gating function is modified as:</p> <p>gi,t=Softmaxi(utTei)1+λH(g1:Nr,t)</p> <ul> <li>where H(⋅) is the entropy function, and λ controls the regularization strength.</li> </ul> </li> <li> <p><strong>Key Benefits:</strong></p> <ul> <li> <strong>Prevents expert over-specialization</strong> by ensuring that tokens are distributed more evenly.</li> <li> <strong>Reduces mode collapse</strong> where certain experts dominate training.</li> <li> <strong>Dynamically scales sparsity</strong> by adjusting gating thresholds based on task complexity.</li> </ul> </li> </ul> <h6 id="device-constrained-expert-allocation-dcea">Device-Constrained Expert Allocation (DCEA)</h6> <ul> <li> <p>DeepSeek-R1 improves upon DeepSeek-V3’s node-limited routing by incorporating Device-Constrained Expert Allocation (DCEA), which restricts expert assignments based on GPU/TPU availability and interconnect bandwidth.</p> </li> <li> <p><strong>Algorithm:</strong></p> <ul> <li>Each token first selects a subset of devices with the highest affinity scores.</li> <li>Experts are restricted to these devices, reducing inter-device synchronization overhead.</li> <li>The final experts are selected only within the constrained device pool, minimizing cross-node communication.</li> </ul> <table> <tbody> <tr> <td>M=∑i=1Nmax{sj,t</td> <td>j∈device i}</td> </tr> </tbody> </table> </li> <li> <p><strong>Results:</strong></p> <ul> <li>35% reduction in cross-device communication latency.</li> <li>More stable training dynamics, as experts remain on localized compute nodes.</li> <li>Lower bandwidth consumption, improving training efficiency.</li> </ul> </li> </ul> <h6 id="load-balanced-expert-utilization-with-rl-based-adjustments">Load-Balanced Expert Utilization with RL-Based Adjustments</h6> <ul> <li>To ensure uniform load balancing, DeepSeek-R1 introduces adaptive load-based routing adjustments, replacing DeepSeek-V3’s auxiliary loss-based balancing strategy.</li> <li>Instead of explicitly minimizing an expert balance loss term, DeepSeek-R1 dynamically adjusts gating probabilities using an RL-based expert selection bias:</li> </ul> <p>bi←bi−γif expert i is overloaded, otherwise bi←bi+γ.</p> <ul> <li> <strong>Advantages Over Auxiliary Losses:</strong> <ul> <li>Faster convergence, as it avoids additional gradient updates for balance constraints.</li> <li>More robust expert selection, as it adapts over multiple training steps.</li> </ul> </li> <li>This ensures consistent workload distribution without requiring hard auxiliary penalties.</li> </ul> <h6 id="elimination-of-token-dropping-strategy">Elimination of Token-Dropping Strategy</h6> <ul> <li>Unlike DeepSeek-V3, which used token dropping to balance computation per device, DeepSeek-R1 completely eliminates token-dropping by optimizing expert activation thresholds dynamically.</li> <li>Instead of removing low-affinity tokens, DeepSeek-R1 reallocates tokens to alternative experts using a reinforcement-learning-based expert reassignment strategy.</li> <li> <strong>Benefits:</strong> <ul> <li>100% token retention during training and inference.</li> <li>Stronger generalization since all tokens contribute to learning.</li> <li>No loss of contextual information, leading to more coherent completions.</li> </ul> </li> </ul> <h5 id="comparative-analysis">Comparative Analysis</h5> <ul> <li>DeepSeek-R1 represents the most advanced iteration of the MoE framework, building upon the optimizations introduced in DeepSeek-V2 and DeepSeek-V3. Below, we compare key MoE features across these three versions, highlighting improvements in efficiency, expert routing, load balancing, and inference performance.</li> </ul> <table> <thead> <tr> <th><strong>Feature</strong></th> <th><strong>DeepSeek-V2</strong></th> <th><strong>DeepSeek-V3</strong></th> <th><strong>DeepSeek-R1</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Dynamic Expert Activation</strong></td> <td>❌</td> <td>✅ (Bias-based selection)</td> <td>✅ (RL-based selection)</td> </tr> <tr> <td><strong>Device-Limited Routing (DLR)</strong></td> <td>✅</td> <td>✅ (Node-Limited Routing)</td> <td>✅ (Device-Constrained Expert Allocation)</td> </tr> <tr> <td><strong>Auxiliary Loss for Load Balancing</strong></td> <td>✅</td> <td>❌ (Bias-based adjustments)</td> <td>❌ (RL-based adaptive balancing)</td> </tr> <tr> <td><strong>RL-Based Routing</strong></td> <td>❌</td> <td>❌</td> <td>✅</td> </tr> <tr> <td><strong>Hierarchical Gating for Expert Selection</strong></td> <td>❌</td> <td>✅</td> <td>✅ (Entropy-aware adjustment)</td> </tr> <tr> <td><strong>Improved Expert Selection Mechanism</strong></td> <td>❌</td> <td>✅ (Sigmoid-based)</td> <td>✅ (RL-optimized selection)</td> </tr> <tr> <td><strong>Cross-Device Communication Reduction</strong></td> <td>✅ (Device-limited routing)</td> <td>✅ (Node-limited routing)</td> <td>✅ (35% lower latency with DCEA)</td> </tr> <tr> <td><strong>Token Dropping for Computational Efficiency</strong></td> <td>✅</td> <td>❌ (No token dropping)</td> <td>❌ (No token dropping)</td> </tr> <tr> <td><strong>Sparse Activation Strategy</strong></td> <td>✅ (Top-K gating)</td> <td>✅ (Hierarchical Top-K gating)</td> <td>✅ (Hierarchical Entropy-Gated MoE)</td> </tr> <tr> <td><strong>Training Stability</strong></td> <td>Moderate</td> <td>High</td> <td>Very High</td> </tr> <tr> <td><strong>Inference Speed Optimization</strong></td> <td>Moderate</td> <td>High</td> <td>Very High</td> </tr> <tr> <td><strong>Load Balancing Strategy</strong></td> <td>Loss-based balancing</td> <td>Bias-based adaptive balancing</td> <td>RL-based adaptive balancing</td> </tr> </tbody> </table> <h4 id="mathematical-formulation">Mathematical Formulation</h4> <ul> <li> <p>The expert selection process in DeepSeek-R1 follows a gating function:</p> <p>G(x)=softmax(Wgx)</p> <ul> <li>where Wg is a trainable weight matrix.</li> </ul> </li> <li> <p>The final output is computed as:</p> <p>y=∑k∈KGk(x)Ek(x)</p> <ul> <li>where: <ul> <li>K represents the top-K selected experts.</li> <li>Ek(x) is the computation performed by expert k.</li> <li>Gk(x) is the gating probability.</li> </ul> </li> </ul> </li> </ul> <h5 id="load-balancing-loss">Load Balancing Loss</h5> <ul> <li> <p>To ensure equal utilization of experts, DeepSeek-R1 applies a load balancing loss:</p> <p>Lbalance=λ∑k(nkN−1K)2</p> <ul> <li>where: <ul> <li>nk is the number of tokens assigned to expert k.</li> <li>N is the total number of tokens in a batch.</li> <li>K is the number of active experts per token.</li> </ul> </li> </ul> </li> <li> <p>Additionally, an entropy regularization term prevents expert over-reliance:</p> <p>Lentropy=−γ∑kGk(x)log⁡Gk(x)</p> <ul> <li>where γ controls entropy strength.</li> </ul> </li> </ul> <h3 id="multihead-latent-attention-mla">Multihead Latent Attention (MLA)</h3> <h4 id="overview-2">Overview</h4> <ul> <li>Multihead Latent Attention (MLA) enhances efficiency by projecting Key-Query-Value (KQV) matrices into a lower-dimensional latent space, significantly reducing computational and memory costs.</li> <li>Low-rank compression techniques in MLA minimize the storage overhead of the Key-Value (KV) cache, ensuring faster inference and supporting longer context lengths or larger batch sizes.</li> <li>DeepSeek-R1 refines MLA further by incorporating RL-enhanced reasoning optimizations while maintaining low memory overhead.</li> <li>By utilizing decoupled rotary positional embeddings and latent-space compression, MLA ensures minimal accuracy degradation while maintaining computational efficiency.</li> </ul> <h4 id="key-features-1">Key Features</h4> <ul> <li> <p><strong>Low-Rank Key-Value Compression</strong>: MLA employs a low-rank latent space projection to compress KV pairs, significantly reducing memory overhead. This allows DeepSeek-R1 to store only compressed representations instead of full-dimensional KV states, enabling efficient long-context processing.</p> </li> <li> <p><strong>Decoupled Rotary Position Embedding (RoPE)</strong>: Standard RoPE introduces position-dependent transformations that hinder KV compression. DeepSeek-R1 decouples RoPE from key-value storage, ensuring positional encodings remain effective without interfering with latent-space efficiency.</p> </li> <li> <p><strong>Efficient Multihead Attention with Compressed Storage</strong>: Instead of caching full key-value matrices for all tokens, MLA only stores their compact latent-space equivalents. This drastically reduces inference memory requirements while maintaining attention fidelity.</p> </li> <li> <p><strong>Adaptive Projection Matrices</strong>: MLA leverages separate, learned projection matrices for queries, keys, and values. These matrices dynamically adjust during training, ensuring optimal storage efficiency and minimal accuracy loss compared to full-dimensional attention.</p> </li> <li> <p><strong>Inference-Efficient Cache Mechanism</strong>: By selectively caching only compressed key-value representations, MLA achieves a 93.3% KV cache reduction over traditional Multi-Head Attention (MHA). This allows DeepSeek-R1 to support longer context lengths while minimizing inference latency.</p> </li> <li> <p><strong>Enhanced Performance on Long-Context Tasks</strong>: DeepSeek-R1 refines MLA with RL-driven optimizations, such as GRPO, to prioritize critical tokens. This improves reasoning accuracy in long-context tasks while preserving computational efficiency.</p> </li> </ul> <h4 id="evolution-from-deepseek-v2-to-deepseek-r1-1">Evolution from DeepSeek-V2 to DeepSeek-R1</h4> <h5 id="mla-in-deepseek-v2">MLA in DeepSeek-V2</h5> <ul> <li>MLA in DeepSeek-V2 was designed to enhance inference efficiency by significantly reducing the KV cache size while maintaining strong model performance. It introduced several key innovations over traditional Multi-Head Attention (MHA), including low-rank key-value joint compression and decoupled rotary position embedding.</li> <li>The MLA implementation in DeepSeek-V2 laid the foundation for further improvements in DeepSeek-R1, where it was further refined with FP8 quantization, enhanced compression techniques, and improved numerical stability.</li> </ul> <h6 id="low-rank-key-value-joint-compression">Low-Rank Key-Value Joint Compression</h6> <ul> <li> <p>One of the primary bottlenecks in transformer inference is the large KV cache required to store past keys and values. DeepSeek-V2 addresses this by compressing the KV representations into a low-dimensional latent space using linear projections.</p> </li> <li> <p>Given an input token representation ht∈Rd, standard multi-head attention computes queries, keys, and values as:</p> <p>qt=WQht,kt=WKht,vt=WVht</p> <p>where WQ,WK,WV∈Rdhnh×d.</p> </li> <li> <p>Instead of storing full-dimension kt and vt, MLA compresses them into a latent representation cKV:</p> <p>cKVt=WDKVht</p> <p>where WDKV∈Rdc×d is a down-projection matrix, and dc≪dhnh.</p> </li> <li> <p>During inference, the compressed key-value representation is expanded back into usable keys and values:</p> <p>ktC=WUKcKVt,vtC=WUVcKVt</p> <p>where WUK,WUV∈Rdhnh×dc are up-projection matrices.</p> <p>This compression reduces the KV cache size from O(nhdhl) to O(dcl), where l is the number of layers.</p> </li> </ul> <h6 id="decoupled-rotary-position-embedding">Decoupled Rotary Position Embedding</h6> <ul> <li> <p>RoPE is commonly used in transformer architectures to encode positional information into queries and keys. However, standard RoPE application is incompatible with MLA’s key-value compression, as it introduces a position-dependent transformation that prevents efficient caching.</p> </li> <li> <p>DeepSeek-V2 resolves this by decoupling RoPE from key compression:</p> <ol> <li>Introduce an auxiliary shared key ktR and additional multi-head queries qtR.</li> <li> <p>Apply RoPE only to qtR and ktR:</p> <p>qtR=RoPE(WQRcQt),ktR=RoPE(WKRht)</p> <ul> <li>where WQR,WKR are projection matrices specific to decoupled RoPE.</li> </ul> </li> <li> <p>Concatenate compressed and RoPE-applied keys/queries:</p> <p>qt=[qtC;qtR],kt=[ktC;ktR]</p> <ul> <li>ensuring that RoPE affects only a subset of the attention mechanism while keeping key-value compression intact.</li> </ul> </li> </ol> </li> </ul> <h6 id="comparison-of-kv-cache-requirements">Comparison of KV Cache Requirements</h6> <ul> <li>A key benefit of MLA is that it achieves stronger performance than standard MHA while requiring significantly less KV cache. The table below compares the cache sizes across different attention mechanisms:</li> </ul> <table> <thead> <tr> <th><strong>Attention Mechanism</strong></th> <th><strong>KV Cache per Token (Elements)</strong></th> </tr> </thead> <tbody> <tr> <td>MHA</td> <td>2nhdhl</td> </tr> <tr> <td>GQA (Grouped Query)</td> <td>2ngdhl</td> </tr> <tr> <td>MQA (Multi-Query)</td> <td>2dhl</td> </tr> <tr> <td><strong>MLA (DeepSeek-V2)</strong></td> <td>(dc+dhR)l</td> </tr> </tbody> </table> <ul> <li> <p>For DeepSeek-V2, values were set as: dc=4dh dhR=dh/2</p> </li> <li> <p>This means that MLA achieves similar efficiency to GQA with 2.25 groups, while maintaining the performance level of MHA.</p> </li> </ul> <h5 id="enhancements-in-deepseek-v3-1">Enhancements in DeepSeek-V3</h5> <ul> <li> <p>DeepSeek-V3 introduces several key enhancements to Multihead Latent Attention (MLA) that significantly improve its efficiency, scalability, and precision while maintaining high model accuracy. The major improvements include:</p> <ul> <li>Further KV Cache Reduction through Optimized Compression Techniques</li> <li>Query Compression for Activation Memory Savings</li> <li>Enhanced Numerical Stability with FP8 Mixed Precision</li> <li>Adaptive Routing for Load Balancing in MLA</li> </ul> </li> <li> <p>With these improvements, DeepSeek-V3 reduces memory overhead, enhances numerical precision, and achieves significantly faster inference speeds while maintaining high model accuracy.</p> </li> </ul> <h6 id="further-kv-cache-reduction-through-optimized-compression-techniques">Further KV Cache Reduction Through Optimized Compression Techniques</h6> <ul> <li> <p>One of the major enhancements in DeepSeek-V3’s MLA is the more aggressive compression of the KV cache while preserving model performance. This is achieved through:</p> <ul> <li> <strong>Dynamic KV Compression Matrices</strong>: Instead of static compression matrices, DeepSeek-V3 optimizes the compression dynamically per sequence length.</li> <li> <strong>Factorized Projections for KV Storage</strong>: A dual-matrix decomposition is applied to down-project the keys and values, further reducing KV storage.</li> </ul> </li> </ul> <h6 id="optimized-compression-formulation">Optimized Compression Formulation</h6> <ul> <li> <p>Given an input token representation ht∈Rd, standard MLA in DeepSeek-V2 computed compressed KV representations as:</p> <p>cKVt=WDKVht</p> <ul> <li>where WDKV∈Rdc×d was a static down-projection matrix.</li> </ul> </li> <li> <p>In DeepSeek-V3, the compression process is enhanced with an adaptive dual-matrix compression:</p> <p>cKVt=WDKV,1WDKV,2ht</p> <ul> <li>where WDKV,1∈Rdm×d and WDKV,2∈Rdc×dm, with dm being an intermediate dimensionality. This factorization allows for more effective compression, reducing storage requirements by up to 40% compared to DeepSeek-V2.</li> </ul> </li> </ul> <h6 id="inference-time-expansion">Inference-Time Expansion</h6> <ul> <li> <p>During inference, the expanded keys and values are now computed as:</p> <p>ktC=WUKWMKcKVt,vtC=WUVWMVcKVt</p> <ul> <li>where WMK,WMV serve as intermediary projection layers that refine the KV reconstruction process.</li> </ul> </li> <li> <p>This improvement ensures that only compressed vectors are stored in memory, significantly reducing KV cache overhead.</p> </li> </ul> <h6 id="query-compression-for-activation-memory-savings">Query Compression for Activation Memory Savings</h6> <ul> <li> <p>DeepSeek-V3 extends MLA’s low-rank compression to queries, reducing activation memory requirements without affecting attention precision.</p> </li> <li> <p><strong>Query Compression Formulation</strong>:</p> <ul> <li>Instead of computing full queries:</li> </ul> <p>qt=WQht,kt=WKht,vt=WVht</p> <ul> <li> <p>DeepSeek-V3 introduces an additional compression step:</p> <p>cQt=WDQht,qtC=WUQcQt</p> <ul> <li>where: <ul> <li>cQt∈Rdc′ is the compressed query representation.</li> <li>dc′≪dhnh, ensuring significantly lower activation memory usage.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p><strong>Decoupled Rotary Positional Embedding (RoPE)</strong>:</p> <ul> <li> <p>To maintain the effectiveness of positional embeddings, DeepSeek-V3 decouples Rotary Positional Embedding (RoPE) application:</p> <p>qtR=RoPE(WQRcQt),ktR=RoPE(WKRht)</p> <ul> <li>where: <ul> <li>qtR and ktR store RoPE-applied versions of the compressed representations.</li> <li>This prevents RoPE from interfering with MLA’s low-rank compression.</li> </ul> </li> </ul> </li> </ul> </li> </ul> <h6 id="reduction-in-activation-memory">Reduction in Activation Memory</h6> <ul> <li>With query compression, DeepSeek-V3 reduces attention activation memory by 35%, enabling efficient training on large-scale models.</li> </ul> <h6 id="enhanced-numerical-stability-with-fp8-mixed-precision">Enhanced Numerical Stability with FP8 Mixed Precision</h6> <ul> <li> <p>DeepSeek-V3 leverages FP8 mixed precision training, improving numerical stability while reducing memory and computational costs.</p> </li> <li> <p><strong>FP8 Training for MLA Components</strong>:</p> <ul> <li> <p>In DeepSeek-V2, the MLA components operated primarily in BF16. DeepSeek-V3 instead adopts fine-grained FP8 quantization, applying a per-group scaling strategy:</p> <ul> <li> <strong>Activation Scaling:</strong> Per-token, per-128-channel tile quantization for activations.</li> <li> <strong>Weight Scaling:</strong> 128×128 block-wise scaling for weights.</li> </ul> </li> <li> <p>This ensures reduced rounding errors and better dynamic range coverage for training.</p> </li> </ul> </li> <li> <p><strong>FP8 Attention Computation</strong>:</p> <ul> <li> <p>The attention output in DeepSeek-V3 is computed using FP8-compatible scaling:</p> <p>ot=∑j=1tSoftmax(qtTkjdh+dR)vj</p> <ul> <li>where: <ul> <li>The scaling factor is calculated online for activations.</li> <li>The accumulation is upgraded to FP32 every 128 steps to improve numerical precision.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p><strong>Precision Comparison</strong>:</p> </li> </ul> <table> <thead> <tr> <th><strong>Component</strong></th> <th><strong>DeepSeek-V2 (BF16)</strong></th> <th><strong>DeepSeek-V3 (FP8)</strong></th> </tr> </thead> <tbody> <tr> <td>Query/Key Compression</td> <td>dc=4dh</td> <td>dc=3dh</td> </tr> <tr> <td>KV Cache Storage</td> <td>BF16</td> <td>FP8</td> </tr> <tr> <td>RoPE Application</td> <td>Full Precision</td> <td>Decoupled, FP8</td> </tr> <tr> <td>Attention Computation</td> <td>BF16</td> <td>FP8 + FP32 Accumulation</td> </tr> </tbody> </table> <ul> <li>By leveraging FP8 quantization, DeepSeek-V3 achieves 2.3× training efficiency improvements, reducing memory consumption without performance degradation.</li> </ul> <h6 id="adaptive-routing-for-load-balancing-in-mla">Adaptive Routing for Load Balancing in MLA</h6> <ul> <li> <p>DeepSeek-V3 improves attention efficiency by introducing dynamic load balancing for query-key computation.</p> </li> <li> <p><strong>Load-Adaptive Routing Mechanism</strong>:</p> <ul> <li> <p>In DeepSeek-V2, MLA used static attention head assignments, leading to occasional computational inefficiencies when processing large sequences.</p> </li> <li> <p>DeepSeek-V3 refines this with adaptive routing:</p> <p>si,t=Sigmoid(utTei+bi)</p> <ul> <li>where: <ul> <li>ei is the centroid vector of the routed expert.</li> <li>bi is a dynamically updated bias term that adjusts for per-head workload balance.</li> </ul> </li> </ul> </li> <li> <p>The bias term updates as:</p> <p>bi(t+1)=bi(t)−γ⋅(overloadedi−underloadedi)</p> <ul> <li>where γ is a tuning parameter.</li> </ul> </li> <li> <p>This ensures:</p> <ul> <li>Balanced token distribution across attention heads.</li> <li>No token-dropping during inference, preventing efficiency loss.</li> </ul> </li> </ul> </li> <li> <p><strong>Computational Gains</strong>:</p> <ul> <li>By integrating adaptive routing, DeepSeek-V3 achieves: <ul> <li>Uniform computational load across attention heads.</li> <li>10% reduction in per-token inference latency.</li> </ul> </li> </ul> </li> </ul> <h5 id="enhancements-in-deepseek-r1-1">Enhancements in DeepSeek-R1</h5> <ul> <li>DeepSeek-R1 introduces several refinements to MLA, improving reasoning efficiency and inference performance while maintaining low memory overhead. Building upon the MLA optimizations in DeepSeek-V3, DeepSeek-R1 further enhances KQV compression, RL-guided attention allocation, and numerical stability mechanisms.</li> </ul> <h6 id="rl-guided-latent-attention-optimization">RL-Guided Latent Attention Optimization</h6> <ul> <li>DeepSeek-R1 integrates RL techniques into MLA, optimizing attention mechanisms through GRPO. Unlike previous deterministic attention strategies, DeepSeek-R1 dynamically adjusts attention weights based on reinforcement rewards, prioritizing tokens that contribute to stronger reasoning trajectories.</li> <li>GRPO eliminates the need for a separate critic model, reducing memory overhead and improving convergence efficiency.</li> <li>Instead of relying on supervised fine-tuning, GRPO estimates advantage values directly from group-level rewards:</li> </ul> <p>Ai=ri−mean({r1,r2,…,rG})std({r1,r2,…,rG})</p> <ul> <li>The policy model πθ is updated by maximizing:</li> </ul> <table> <tbody> <tr> <td>JGRPO(θ)=E[∑i=1Gmin(πθ(oi</td> <td>q)πθold(oi</td> <td>q)Ai,clip(πθ(oi</td> <td>q)πθold(oi</td> <td>q),1−ϵ,1+ϵ)Ai)−βDKL(πθ</td> <td> </td> <td>πref)]</td> </tr> </tbody> </table> <ul> <li>This approach allows DeepSeek-R1 to adaptively refine the attention mechanisms in MLA, improving token prioritization in long-context reasoning.</li> <li>Further details can be found in the section on <a href="https://aman.ai/primers/ai/deepseek-R1/#rl-algorithm-group-relative-policy-optimization-grpo" rel="external nofollow noopener" target="_blank">RL Algorithm: Group Relative Policy Optimization (GRPO)</a>.</li> </ul> <h6 id="adaptive-query-and-key-compression-via-rl">Adaptive Query and Key Compression Via RL</h6> <p>One of the primary enhancements in DeepSeek-R1’s MLA is RL-guided adaptive query and key compression. DeepSeek-V3 already introduced a low-rank compression technique for KV storage, but DeepSeek-R1 extends compression to queries, reducing activation memory without affecting attention accuracy.</p> <ul> <li> <p><strong>Optimized Compression Formulation</strong>:</p> <ul> <li>In DeepSeek-V3, the KV cache compression was achieved using static low-rank projections:</li> </ul> <p>cKVt=WDKVht</p> <ul> <li> <p>DeepSeek-R1 dynamically adjusts compression matrices during inference using RL-based reward maximization:</p> <p>cKVt=WDKV,1WDKV,2ht</p> <ul> <li>where: <ul> <li>WDKV,1∈Rdm×d and WDKV,2∈Rdc×dm.</li> <li>dm is an intermediate dimensionality, allowing for more fine-grained latent space representations.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p><strong>Inference-Time Expansion</strong>:</p> <ul> <li> <p>Instead of using a single up-projection matrix, DeepSeek-R1 incorporates a multi-stage expansion pipeline:</p> <p>ktC=WUKWMKcKVt,vtC=WUVWMVcKVt</p> <ul> <li>where WMK,WMV refine the reconstructed query-key values, ensuring that only compressed vectors are stored in memory.</li> </ul> </li> </ul> </li> <li> <p><strong>Compression ratio improvements:</strong> DeepSeek-R1 reduces KV cache requirements by an additional 25% over DeepSeek-V3, while maintaining query-key retrieval accuracy.</p> </li> </ul> <h6 id="decoupled-rotary-position-embedding-with-context-specific-scaling">Decoupled Rotary Position Embedding with Context-Specific Scaling</h6> <ul> <li>While DeepSeek-V3 introduced Decoupled RoPE to separate positional encoding from compressed key-value representations, DeepSeek-R1 further refines RoPE with context-specific scaling mechanisms.</li> <li> <p>DeepSeek-R1 adopts an enhanced RoPE formulation where RoPE is context-aware, dynamically adjusting scaling factors based on sequence length:</p> <p>λt=11+αLt</p> <ul> <li>where: <ul> <li>λt is the adaptive scaling factor for positional embedding.</li> <li>α is a hyperparameter learned via RL optimization.</li> <li>Lt represents the sequence length at time step t.</li> </ul> </li> </ul> </li> <li> <strong>Implementation benefits</strong>: <ul> <li>RoPE scaling ensures consistent attention alignment across varying sequence lengths.</li> <li>Prevents positional information degradation when compressing MLA’s key-value states.</li> </ul> </li> </ul> <h6 id="fp8-mixed-precision-for-mla-stability">FP8 Mixed Precision for MLA Stability</h6> <ul> <li>DeepSeek-R1 adopts FP8 quantization for MLA computations, further improving numerical stability over DeepSeek-V3’s BF16-based approach.</li> <li> <p>In DeepSeek-R1’s precision-aware computation pipeline, QKV matrices are quantized dynamically using per-group scaling:</p> <p>Q~=QsQ,K~=KsK,V~=VsV</p> <ul> <li>where sQ,sK,sV are learned per-group scaling factors.</li> </ul> </li> <li> <p>The attention output is computed with hybrid precision accumulation:</p> <p>ot=∑j=1tSoftmax(q~tTk~jdh+dR)v~j</p> </li> <li> <p>The accumulation process is upgraded to FP32 every 128 steps, ensuring better numerical precision while maintaining FP8 efficiency.</p> </li> <li> <strong>Comparison of MLA Precision Strategies</strong>:</li> </ul> <table> <thead> <tr> <th><strong>Component</strong></th> <th><strong>DeepSeek-V3 (BF16)</strong></th> <th><strong>DeepSeek-R1 (FP8)</strong></th> </tr> </thead> <tbody> <tr> <td>Query/Key Compression</td> <td>dc=4dh</td> <td>dc=3dh</td> </tr> <tr> <td>KV Cache Storage</td> <td>BF16</td> <td>FP8</td> </tr> <tr> <td>RoPE Application</td> <td>Full Precision</td> <td>Decoupled, FP8</td> </tr> <tr> <td>Attention Computation</td> <td>BF16</td> <td>FP8 + FP32 Accumulation</td> </tr> </tbody> </table> <ul> <li> <strong>Efficiency improvements</strong>: <ul> <li>FP8 reduces memory footprint by ~40% compared to BF16.</li> <li>Enables 2.3× faster inference throughput for long-context tasks.</li> </ul> </li> </ul> <h6 id="adaptivedynamic-routing-for-load-balanced-attention">Adaptive/Dynamic Routing for Load-Balanced Attention</h6> <ul> <li>DeepSeek-R1 incorporates load-balancing adaptive routing mechanisms, ensuring uniform query-key computation across attention heads.</li> <li> <p>DeepSeek-R1 optimizes per-head workload balance using a sigmoid-based routing function:</p> <p>si,t=Sigmoid(utTei+bi)</p> <ul> <li>where: <ul> <li>ei represents the centroid vector of the routed attention expert.</li> <li>bi is an adaptive bias term, ensuring workload uniformity.</li> </ul> </li> </ul> </li> <li> <strong>Performance gains</strong>: <ul> <li>Balanced computation across heads prevents bottlenecks.</li> <li>Reduces per-token inference latency by 10%.</li> </ul> </li> </ul> <h5 id="comparative-analysis-1">Comparative Analysis</h5> <ul> <li>DeepSeek-V2 introduced Multihead Latent Attention (MLA) with significant KV cache compression, decoupled RoPE, and basic low-rank projections for efficiency. DeepSeek-V3 built upon this foundation by further reducing KV cache size, optimizing query compression, and introducing FP8 mixed precision for enhanced numerical stability. DeepSeek-R1 refines MLA even further by integrating RL techniques such as Group Relative Policy Optimization (GRPO) to optimize attention allocation dynamically. The latest advancements in DeepSeek-R1 also improve inference latency and memory efficiency, making it the most optimized version of MLA to date.</li> <li>The table below provides a comparative analysis of DeepSeek-V2, DeepSeek-V3, and DeepSeek-R1 for MLA. This comparison highlights the key improvements across versions in terms of compression techniques, precision, routing mechanisms, and inference efficiency.</li> </ul> <table> <thead> <tr> <th><strong>Feature</strong></th> <th><strong>DeepSeek-V2</strong></th> <th><strong>DeepSeek-V3</strong></th> <th><strong>DeepSeek-R1</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Low-Rank KV Compression</strong></td> <td>✅</td> <td>✅ (Optimized with Factorized Projections)</td> <td>✅ (RL-Optimized Adaptive Compression)</td> </tr> <tr> <td><strong>Query Compression</strong></td> <td>❌</td> <td>✅ (Static Low-Rank Query Compression)</td> <td>✅ (RL-Guided Dynamic Query Compression)</td> </tr> <tr> <td><strong>KV Cache Reduction</strong></td> <td>✅ (93.3% Reduction)</td> <td>✅ (40% Further Reduction)</td> <td>✅ (25% Further Reduction over V3)</td> </tr> <tr> <td><strong>RoPE Application</strong></td> <td>✅ (Decoupled RoPE)</td> <td>✅ (Decoupled with Context-Specific Scaling)</td> <td>✅ (Enhanced Context-Aware Scaling)</td> </tr> <tr> <td><strong>Precision Format</strong></td> <td>BF16</td> <td>FP8 (Fine-Grained Mixed Precision)</td> <td>FP8 (Per-Group Scaling, FP32 Accumulation)</td> </tr> <tr> <td><strong>Adaptive Routing for MLA</strong></td> <td>❌</td> <td>✅ (Static Adaptive Routing)</td> <td>✅ (Load-Balanced Dynamic Routing)</td> </tr> <tr> <td><strong>Inference Latency Reduction</strong></td> <td>✅ (KV Compression Reduces Latency)</td> <td>✅ (10% Faster than V2)</td> <td>✅ (10% Faster than V3)</td> </tr> <tr> <td><strong>RL Enhancements</strong></td> <td>❌</td> <td>❌</td> <td>✅ (GRPO for Adaptive MLA Optimization)</td> </tr> <tr> <td><strong>Numerical Stability Improvements</strong></td> <td>✅ (Basic Stability Enhancements)</td> <td>✅ (FP8 with Mixed Precision)</td> <td>✅ (FP8 with RL-Guided Stability Mechanisms)</td> </tr> <tr> <td><strong>Long-Context Performance</strong></td> <td>✅ (Supports Longer Contexts)</td> <td>✅ (Further Optimized)</td> <td>✅ (Enhanced with RL-Guided Token Prioritization)</td> </tr> </tbody> </table> <h4 id="implementation">Implementation</h4> <ul> <li>The implementation of MLA in DeepSeek-R1 incorporates several optimizations aimed at maximizing efficiency while preserving accuracy. This section details the core mechanisms underlying MLA, including key-value compression, query transformation, position encoding, and computational optimizations.</li> </ul> <h5 id="background-standard-multi-head-attention-mha">Background: Standard Multi-Head Attention (MHA)</h5> <ul> <li> <p>For a standard multi-head attention (MHA) mechanism, the Key (K), Query (Q), and Value (V) matrices are computed as follows:</p> <p>K,Q,V=WkX,WqX,WvX</p> <ul> <li>where Wk,Wq,Wv are weight matrices for key, query, and value projections.</li> </ul> </li> <li> <p>The attention weights are computed as:</p> <p>A=Softmax(QKTdk)</p> <ul> <li>and the output is given by:</li> </ul> <p>O=AV</p> </li> <li> <p>This requires storing the full key-value cache during inference, leading to significant memory overhead.</p> </li> </ul> <h5 id="low-rank-key-value-joint-compression-1">Low-Rank Key-Value Joint Compression</h5> <ul> <li> <p>One of the fundamental optimizations in MLA is the compression of KV pairs into a lower-dimensional latent space, significantly reducing memory overhead. Specifics below:</p> <ul> <li> <p><strong>Compression Mechanism</strong>:</p> <ul> <li>The key and value representations are compressed into a shared latent space before being projected back into their respective dimensions. This is achieved through a two-step transformation:</li> </ul> <p>cKVt=WDKVht</p> <p>kCt=WUKcKVt,vCt=WUVcKVt</p> <ul> <li>where: <ul> <li>cKVt∈Rdc is the compressed latent representation.</li> <li>WDKV∈Rdc×d is a down-projection matrix.</li> <li>WUK,WUV∈Rdhnh×dc are up-projection matrices for keys and values, respectively.</li> </ul> </li> </ul> </li> <li> <p><strong>Memory Reduction</strong>:</p> <ul> <li>Instead of storing full-sized keys and values for each token, only cKVt is cached.</li> <li>The reduction in memory footprint allows DeepSeek-R1 to process significantly longer sequences at a lower computational cost.</li> </ul> </li> </ul> </li> </ul> <h5 id="multi-stage-compression">Multi-Stage Compression</h5> <ul> <li> <p>DeepSeek-R1 refines the compression mechanism by introducing an additional transformation layer, leading to a multi-stage compression approach. Specifics below:</p> <ul> <li> <p><strong>Additional Projection Layer</strong>:</p> <ul> <li>To further minimize storage costs, a secondary compression layer is introduced:</li> </ul> <p>cKVt′=WDKV2f(WDKVht)</p> <ul> <li>where: <ul> <li>WDKV2∈Rdc′×dc is a second down-projection matrix.</li> <li>f(⋅) is a non-linear activation function applied to improve representation learning.</li> <li>dc′&lt;dc ensures an even smaller KV cache size.</li> </ul> </li> </ul> </li> <li> <p><strong>Performance Benefits</strong>:</p> <ul> <li>This additional step further reduces KV storage while maintaining sufficient information for attention mechanisms.</li> <li>Experiments indicate that this leads to a 10-15% reduction in memory footprint compared to DeepSeek-V3.</li> </ul> </li> </ul> </li> </ul> <h5 id="query-compression-and-optimization">Query Compression and Optimization</h5> <ul> <li> <p>Similar to keys and values, queries are also compressed, allowing for efficient computation and reduced activation memory during training. Specifics below:</p> <ul> <li> <p><strong>Query Transformation</strong>:</p> <ul> <li>Queries undergo a two-step transformation similar to keys and values:</li> </ul> <p>cQt=WDQht</p> <p>qCt=WUQcQt</p> <ul> <li>where: <ul> <li>WDQ∈Rdc′×d is a down-projection matrix for queries.</li> <li>WUQ∈Rdhnh×dc′ maps the compressed query representation back to its original dimensionality.</li> </ul> </li> </ul> </li> <li> <p><strong>Multi-Layer Query Refinement</strong>:</p> <ul> <li>DeepSeek-R1 optimizes query projection through additional adaptive scaling layers.</li> <li>The transformation matrices WDQ and WUQ are dynamically adjusted during fine-tuning using RL.</li> </ul> </li> </ul> </li> </ul> <h5 id="decoupled-rotary-position-embedding-rope">Decoupled Rotary Position Embedding (RoPE)</h5> <ul> <li> <p>To ensure robust long-context handling, DeepSeek-R1 applies RoPE in a decoupled manner, separating positional encodings from the latent attention mechanism. Specifics below:</p> <ul> <li> <p><strong>Independent Positional Encoding for Keys and Queries</strong>:</p> <p>kRt=RoPE(WKRht)</p> <p>qRt=RoPE(WQRcQt)</p> <ul> <li>where: <ul> <li>WKR∈RdRh×d generates positional embeddings for keys.</li> <li>WQR∈RdRhnh×dc′ generates positional embeddings for queries.</li> <li>The RoPE transformation ensures that relative positional information is preserved while allowing the KV cache to remain compact.</li> </ul> </li> </ul> </li> <li> <p><strong>Computation Efficiency of RoPE in DeepSeek-R1</strong>:</p> <ul> <li>RoPE application is delayed until the final stages of query-key interaction, preventing unnecessary memory bloat.</li> <li>Compared to DeepSeek-V2 and V3, DeepSeek-R1 achieves 25% faster query-key retrieval.</li> </ul> </li> </ul> </li> </ul> <h5 id="attention-computation-in-mla">Attention Computation in MLA</h5> <ul> <li> <p>The final attention output in MLA is computed by integrating compressed keys, queries, and values in a modified attention mechanism. Specifics below:</p> <ul> <li> <strong>Modified Attention Scores</strong>: <ul> <li> <p>The attention scores are computed using both compressed latent keys and explicit positional encodings:</p> <p>At,j,i=qt,iTkj,idh+dR</p> </li> <li> <p>This formulation ensures that positional embeddings contribute proportionally to attention strength.</p> </li> </ul> </li> <li> <strong>Weighted Value Aggregation</strong>: <ul> <li> <p>The attention output is computed as:</p> <p>ot,i=∑j=1tSoftmaxj(At,j,i)vCj,i</p> </li> <li> <p>The softmax operation normalizes the attention scores across the sequence.</p> </li> </ul> </li> <li> <strong>Final Output Projection</strong>: <ul> <li> <p>The final output is obtained via:</p> <p>ut=WO[ot,1;ot,2;…;ot,nh]</p> <ul> <li>where: <ul> <li>WO is the output projection matrix mapping the concatenated attention outputs back to the full embedding space.</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> <h5 id="rl-optimized-mla">RL-Optimized MLA</h5> <ul> <li> <p>DeepSeek-R1 incorporates RL to further optimize MLA’s transformation matrices. Specifics below:</p> <ul> <li> <strong>Fine-Tuning with RL</strong>: <ul> <li>Using GRPO, MLA is rewarded based on efficient memory usage and retrieval accuracy.</li> <li> <p>The policy update equation is:</p> <table> <tbody> <tr> <td>JGRPO(θ)=E[∑i=1Gmin(πθ(oi</td> <td>q)πθold(oi</td> <td>q)Ai,clip(πθ(oi</td> <td>q)πθold(oi</td> <td>q),1−ϵ,1+ϵ)Ai)]</td> </tr> </tbody> </table> <ul> <li>where: <ul> <li>πθ represents the updated policy.</li> <li>Ai is the advantage function guiding optimization.</li> </ul> </li> </ul> </li> </ul> </li> <li> <strong>Empirical Results of RL Optimization</strong>: <ul> <li>RL-based fine-tuning further enhances attention fidelity without increasing memory usage.</li> <li>Empirical evaluation shows a 6% improvement in retrieval accuracy over DeepSeek-V3.</li> </ul> </li> </ul> </li> </ul> <h5 id="computational-and-hardware-optimization">Computational and Hardware Optimization</h5> <ul> <li> <strong>Inference-Time Efficiency</strong>: <ul> <li>MLA in DeepSeek-R1 is implemented with tensor-parallelized computations, optimizing throughput across GPUs.</li> <li>Memory overhead is minimized through low-precision KV storage (FP8 format).</li> </ul> </li> <li> <strong>Cross-Node Communication Optimization</strong>: <ul> <li>Uses optimized all-to-all communication kernels to fully utilize InfiniBand (IB) and NVLink bandwidths.</li> <li>Reduces inter-node communication latency by 30%, improving distributed inference performance.</li> </ul> </li> </ul> <h5 id="comparative-efficiency-analysis">Comparative Efficiency Analysis</h5> <table> <thead> <tr> <th><strong>Attention Mechanism</strong></th> <th><strong>KV Cache Per Token</strong></th> <th><strong>Computational Complexity</strong></th> <th><strong>Performance Impact</strong></th> </tr> </thead> <tbody> <tr> <td><strong>MHA (Standard)</strong></td> <td>O(Ndh)</td> <td>O(N2dh)</td> <td>High Accuracy, High Cost</td> </tr> <tr> <td><strong>MQA</strong></td> <td>O(dh)</td> <td>O(Ndh)</td> <td>Lower Memory, Degraded Performance</td> </tr> <tr> <td><strong>GQA</strong></td> <td>O(gdh) (groups)</td> <td>O(Ndh)</td> <td>Moderate Balance</td> </tr> <tr> <td><strong>MLA (DeepSeek-V2)</strong></td> <td>O(dL)</td> <td>O(NdL)</td> <td>High Efficiency, Minimal Loss</td> </tr> <tr> <td><strong>MLA + Hierarchical Caching (DeepSeek-R1)</strong></td> <td>O(dL) (with reuse)</td> <td>O(NdL)</td> <td><strong>Peak Efficiency, Retains Performance</strong></td> </tr> </tbody> </table> <h3 id="multi-token-prediction-mtp">Multi-Token Prediction (MTP)</h3> <h4 id="overview-3">Overview</h4> <ul> <li>Multi-Token Prediction (MTP) allows DeepSeek-R1 to predict multiple tokens in parallel, significantly improving inference speed.</li> </ul> <h4 id="key-features-2">Key Features</h4> <ul> <li> <p><strong>Parallel Multi-Token Prediction</strong>: DeepSeek-R1 enhances inference speed by predicting multiple tokens simultaneously rather than sequentially. This reduces decoding latency and allows for faster text generation without compromising coherence.</p> </li> <li> <p><strong>Cross-Depth Residual Connections</strong>: Unlike DeepSeek-V3, which conditions token predictions only on prior module outputs, DeepSeek-R1 integrates residual connections between MTP layers. This allows deeper MTP modules to utilize features from earlier depths, improving long-term dependencies.</p> </li> <li> <p><strong>Adaptive Prediction Granularity</strong>: The model dynamically adjusts how many future tokens each module predicts based on the input sequence’s complexity. This ensures fine-grained predictions for short contexts and broader lookahead when handling longer sequences.</p> </li> <li> <p><strong>Depth-Aware Loss Weighting</strong>: DeepSeek-R1 refines its training objective by prioritizing mid-range MTP depths using a sigmoid-based weighting function. This enhances learning efficiency by directing more gradient updates where they have the greatest impact.</p> </li> <li> <p><strong>Memory-Efficient Parameter Sharing</strong>: The model reduces memory consumption by reusing transformer layers across MTP depths. Instead of separate layers for each module, DeepSeek-R1 applies depth-conditioned routing, minimizing redundant computations while maintaining unique depth-wise representations.</p> </li> <li> <p><strong>Optimized Speculative Decoding</strong>: DeepSeek-R1 improves speculative decoding by introducing probabilistic agreement checking. Predictions are accepted based on confidence thresholds rather than requiring exact matches, reducing rejection rates and accelerating inference.</p> </li> <li> <p><strong>Empirical Gains in Training and Inference</strong>: Thanks to these enhancements, DeepSeek-R1 achieves a <strong>22% faster training convergence</strong>, <strong>1.5× improvement in generation speed</strong>, and <strong>18% better long-form perplexity</strong>, demonstrating its superiority over DeepSeek-V3.</p> </li> </ul> <h4 id="evolution-from-deepseek-v3-to-deepseek-r1">Evolution from DeepSeek-V3 to DeepSeek-R1</h4> <h5 id="mtp-in-deepseek-v3">MTP in DeepSeek-V3</h5> <ul> <li>MTP was is introduced in DeepSeek-V3 as a training objective to improve data efficiency and predictive capabilities by enabling the model to anticipate multiple future tokens at each position. Unlike conventional next-token prediction, which limits training to a single-step forward prediction, MTP extends this scope to multiple future tokens, thereby densifying training signals and enhancing long-term coherence in text generation.</li> <li>DeepSeek-V3 implements MTP using a structured pipeline with several key design choices, including sequential prediction modules, shared embeddings and output heads, and a hierarchical loss formulation. These innovations improve model performance, enable speculative decoding, and enhance overall data efficiency. DeepSeek-R1 further builds on these foundations, optimizing MTP implementation for improved reasoning tasks.</li> <li>The following sub-sections detail the features introduced in DeepSeek-V3 to support MTP.</li> </ul> <h6 id="sequential-multi-token-prediction-modules">Sequential Multi-Token Prediction Modules</h6> <ul> <li>DeepSeek-V3 employs D sequential MTP modules, where each module is responsible for predicting an additional future token. Instead of parallelly predicting future tokens with independent output heads (as in <a href="https://arxiv.org/abs/2404.19737" rel="external nofollow noopener" target="_blank">Better &amp; Faster Large Language Models via Multi-token Prediction</a> by Gloeckle et al., 2024), DeepSeek-V3 maintains a causal chain across prediction depths, ensuring each token is conditioned on prior MTP module outputs.</li> <li> <p>For the kth MTP module, the representation of the ith input token at depth k is computed as:</p> <p>hi′(k)=Mk[RMSNorm(hi(k−1));RMSNorm(Emb(ti+k))]</p> <ul> <li>where: <ul> <li>hi(k−1) is the representation from the previous depth (or from the main model when k=1).</li> <li>Mk∈Rd×2d is the projection matrix.</li> <li> <em>Emb(⋅)</em> is the shared embedding function.</li> </ul> </li> </ul> </li> <li> <p>Each module applies a transformer block:</p> <p>h1:T−k(k)=TRMk(h1:T−k′(k))</p> <ul> <li>where T is the input sequence length. The output of this module is passed to a shared output head:</li> </ul> <p>Pi+k+1(k)=OutHead(hi(k))</p> <ul> <li>where Pi+k+1(k) is the probability distribution for the <em>k</em>-th future token.</li> </ul> </li> </ul> <h6 id="mtp-training-objective">MTP Training Objective</h6> <ul> <li> <p>For each prediction depth k, DeepSeek-V3 computes a cross-entropy loss:</p> <p>LMTP(k)=−1T∑i=2+kT+1log⁡Pi(k)[ti]</p> <ul> <li>where ti is the ground-truth token at position i, and Pi(k)[ti] is the predicted probability for that token. The overall MTP loss is the mean of losses across all depths, scaled by a factor λ:</li> </ul> <p>LMTP=λD∑k=1DLMTP(k)</p> <ul> <li>where D is the number of MTP modules.</li> </ul> </li> </ul> <h6 id="memory-optimization-with-shared-embeddings-and-output-heads">Memory Optimization with Shared Embeddings and Output Heads</h6> <ul> <li>To minimize additional memory costs from MTP modules, DeepSeek-V3: <ul> <li>Shares embeddings across MTP modules.</li> <li>Uses a single shared output head instead of independent ones for each MTP depth.</li> <li>Implements weight sharing between the primary model and MTP modules.</li> </ul> </li> <li>This design ensures that additional forward passes in MTP training do not substantially increase parameter storage requirements.</li> </ul> <h6 id="inference-strategy-and-speculative-decoding">Inference Strategy and Speculative Decoding</h6> <ul> <li> <p>While MTP is primarily used to improve training, DeepSeek-V3 also explores the use of MTP modules for speculative decoding at inference time. The idea is to use the additional token predictions as speculative completions, similar to methods proposed in <a href="https://arxiv.org/abs/2211.17192" rel="external nofollow noopener" target="_blank">Fast Inference from Transformers via Speculative Decoding</a> by Leviathan et al. (2023):</p> <ol> <li>The primary model predicts token ti+1 as usual.</li> <li>The first MTP module simultaneously predicts ti+2, allowing early validation of token coherence.</li> <li>If MTP predictions match beam search results, multiple tokens can be emitted at once.</li> </ol> </li> <li> <p>This strategy significantly accelerates inference while maintaining output fluency.</p> </li> </ul> <h6 id="ablation-studies-on-multi-token-prediction">Ablation Studies on Multi-Token Prediction</h6> <ul> <li>DeepSeek-V3 conducts detailed ablation studies to assess the impact of MTP. Key findings include: <ul> <li> <strong>Impact on Training Efficiency</strong>: Training with MTP leads to a 15% improvement in data efficiency, allowing models to learn more per token.</li> <li> <strong>Effect on Long-Term Coherence</strong>: Models trained with MTP exhibit a higher perplexity improvement at longer sequence lengths compared to traditional next-token prediction.</li> <li> <strong>Influence on Speculative Decoding Accuracy</strong>: The inclusion of MTP modules in decoding reduces rejection rates in speculative generation by 35%, enhancing latency benefits.</li> </ul> </li> </ul> <h5 id="enhancements-in-deepseek-r1-2">Enhancements in DeepSeek-R1</h5> <ul> <li>DeepSeek-R1 introduces significant advancements in MTP, building upon the structured MTP framework established in DeepSeek-V3. The improvements primarily focus on better token dependency modeling, adaptive prediction granularity, loss function refinement, memory-efficient parameter sharing, and optimized inference strategies. These enhancements enable DeepSeek-R1 to achieve superior reasoning capability, enhanced training efficiency, and significantly reduced inference latency. Below, we detail each feature.</li> </ul> <h6 id="improved-token-dependency-modeling-in-mtp">Improved Token Dependency Modeling in MTP</h6> <ul> <li> <p>DeepSeek-R1 enhances the sequential nature of MTP modules by incorporating cross-depth residual connections between MTP layers. Unlike DeepSeek-V3, where each MTP module strictly predicts tokens conditioned only on prior module outputs, DeepSeek-R1 introduces depth-wise feature aggregation to facilitate richer information propagation.</p> </li> <li> <p>The updated token representation at the <em>k</em>-th depth is computed as:</p> <p>hi′(k)=Mk[RMSNorm(hi(k−1));RMSNorm(Emb(ti+k));Res(hi(k−2))]</p> <ul> <li>where: <ul> <li> <p>Res(hi(k−2)) is a residual connection from two depths earlier, weighted by a learnable scalar αk:</p> <p>Res(hi(k−2))=αk⋅hi(k−2)</p> </li> </ul> </li> </ul> </li> <li> <p>This modification ensures that deeper MTP modules receive contextualized features from multiple depths, leading to improved coherence in multi-step predictions.</p> </li> </ul> <h6 id="adaptive-prediction-granularity">Adaptive Prediction Granularity</h6> <ul> <li> <p>DeepSeek-R1 refines MTP’s granularity by dynamically adjusting the number of future tokens predicted per module based on the context length and complexity of the input. Instead of fixing the number of predicted tokens per step, DeepSeek-R1 adapts the prediction horizon dynamically.</p> </li> <li> <p>The number of future tokens predicted at depth k is given by:</p> <p>Nk=min(⌊γk⋅T⌋,D−k)</p> <ul> <li>where: <ul> <li>γk is a learnable scaling factor that determines adaptive granularity.</li> <li>T is the sequence length.</li> <li>D is the maximum MTP depth.</li> </ul> </li> </ul> </li> <li> <p><strong>Intuition:</strong> In early sequence regions, shorter horizons (1-2 future tokens) are preferred for precise token alignment, whereas deeper into the sequence, the model extends the prediction horizon, increasing efficiency without sacrificing accuracy.</p> </li> </ul> <h6 id="loss-function-refinement-for-multi-depth-learning">Loss Function Refinement for Multi-Depth Learning</h6> <ul> <li> <p>DeepSeek-R1 improves the MTP loss formulation by introducing depth-aware weighting to prioritize learning at certain depths. In DeepSeek-V3, all depths were weighted equally, leading to inefficient optimization at extreme depths.</p> </li> <li> <p>The new depth-weighted MTP loss is formulated as:</p> <p>LMTP=λD∑k=1Dwk⋅LMTP(k)</p> <ul> <li>where: <ul> <li> <p>wk is a depth-dependent weighting factor:</p> <p>wk=11+e−β(k−D/2)</p> </li> <li> <p>This sigmoid-based weighting ensures that mid-range MTP depths receive stronger gradient signals, leading to better-balanced learning across depths.</p> </li> </ul> </li> </ul> </li> </ul> <h6 id="optimized-memory-efficiency-with-parameter-sharing">Optimized Memory Efficiency with Parameter Sharing</h6> <ul> <li> <p>One major enhancement in DeepSeek-R1 is the parameter sharing strategy across MTP modules, significantly reducing memory overhead while maintaining distinct depth-wise representations.</p> </li> <li>Instead of maintaining separate transformer layers for each MTP depth as in DeepSeek-V3, DeepSeek-R1 re-uses the main model’s layers with depth-conditioned routing.</li> <li> <p>The token representation at depth k is now passed through a single, shared transformer layer with an additional depth-embedding:</p> <p>h1:T−k(k)=TRM(h1:T−k′(k),DepthEmb(k))</p> </li> <li>The depth embedding DepthEmb(k) ensures that different MTP layers retain unique learned behaviors while leveraging the same computational graph.</li> </ul> <h6 id="enhanced-inference-strategy-with-speculative-decoding">Enhanced Inference Strategy with Speculative Decoding</h6> <ul> <li> <p>DeepSeek-R1 significantly refines the speculative decoding strategy introduced in DeepSeek-V3 by allowing adaptive token validation. Specifics below:</p> <ul> <li>In DeepSeek-V3, speculative decoding was limited to greedy agreement checking, where only exact matches between MTP predictions and main model outputs were used to accelerate inference.</li> <li> <p>DeepSeek-R1 introduces probabilistic agreement checking, where a predicted token t^i+2 from MTP is accepted if:</p> <p>PMTP(1)(t^i+2)&gt;τPMain(t^i+2)</p> <ul> <li>where: <ul> <li>PMTP(1)(t^i+2) is the MTP module’s probability of the token.</li> <li>PMain(t^i+2) is the main model’s probability.</li> <li>τ is a tunable acceptance threshold.</li> </ul> </li> </ul> </li> <li> <strong>Impact:</strong> This strategy allows high-confidence speculative predictions to be used even when they do not perfectly match the main model’s top prediction, reducing rejection rates by over 40%, accelerating inference.</li> </ul> </li> </ul> <h6 id="empirical-gains-from-deepseek-r1s-mtp-enhancements">Empirical Gains from DeepSeek-R1’s MTP Enhancements</h6> <ul> <li> <p>DeepSeek-R1’s refinements to MTP result in significant empirical gains over DeepSeek-V3:</p> <ul> <li> <strong>Training Efficiency:</strong> Training convergence improved by 22% due to depth-weighted loss prioritization.</li> <li> <strong>Inference Speed:</strong> Speculative decoding optimizations resulted in a 1.5× faster generation speed.</li> <li> <strong>Long-Term Coherence:</strong> Perplexity on long-form text improved by 18%, showing that the revised token dependency modeling enhances context retention over long horizons.</li> </ul> </li> </ul> <h5 id="comparative-analysis-2">Comparative Analysis</h5> <ul> <li>DeepSeek-R1 builds upon DeepSeek-V3’s foundational MTP structure while addressing its limitations. The improvements, particularly in adaptive granularity, loss function optimization, and speculative decoding, result in faster, more coherent, and memory-efficient predictions. These refinements collectively enhance DeepSeek-R1’s reasoning capability and inference performance. The table below provides a comparative summary of key MTP features in DeepSeek-V3 and DeepSeek-R1.</li> </ul> <table> <thead> <tr> <th><strong>Feature</strong></th> <th><strong>DeepSeek-V3</strong></th> <th><strong>DeepSeek-R1</strong></th> </tr> </thead> <tbody> <tr> <td>Sequential MTP Modules</td> <td>✅ Structured pipeline with sequential depth modules</td> <td>✅ Enhanced with cross-depth residual connections</td> </tr> <tr> <td>Shared Embeddings for MTP</td> <td>✅ Shared token embeddings across modules</td> <td>✅ Further optimized with depth-conditioned routing</td> </tr> <tr> <td>Prediction Granularity</td> <td>❌ Fixed number of future token predictions per module</td> <td>✅ Adaptive token horizon based on sequence complexity</td> </tr> <tr> <td>Loss Function Optimization</td> <td>❌ Uniform loss weighting across MTP depths</td> <td>✅ Depth-aware weighting for optimized learning</td> </tr> <tr> <td>Memory Optimization Strategy</td> <td>✅ Shared output heads for reduced memory footprint</td> <td>✅ Further improved with depth-conditioned layer sharing</td> </tr> <tr> <td>Inference Speed Boost via MTP</td> <td>✅ Basic speculative decoding</td> <td>✅ Probabilistic speculative decoding, reducing rejection rates by 40%</td> </tr> <tr> <td>Training Efficiency Improvement</td> <td>✅ 15% increase in data efficiency</td> <td>✅ 22% faster convergence with improved loss prioritization</td> </tr> <tr> <td>Long-Term Coherence in Predictions</td> <td>✅ Improved over next-token prediction models</td> <td>✅ 18% better perplexity in long-form text</td> </tr> <tr> <td>Speculative Decoding Acceptance Strategy</td> <td>❌ Strict token match required for validation</td> <td>✅ Probabilistic validation based on confidence threshold</td> </tr> <tr> <td>Impact on Latency Reduction</td> <td>✅ Moderate improvement in decoding speed</td> <td>✅ 1.5× faster inference due to reduced rejection rates</td> </tr> </tbody> </table> <h4 id="implementation-details">Implementation Details</h4> <ul> <li> <p>DeepSeek-R1 incorporates an advanced MTP strategy to boost decoding efficiency and reduce latency. Unlike traditional autoregressive decoding, where each token is predicted sequentially, MTP allows multiple tokens to be predicted per decoding step. This is achieved through a hierarchical approach that balances performance improvements with the risk of error propagation. Specifics below:</p> <ol> <li> <strong>Multi-Layer Representation Propagation</strong>: <ul> <li>DeepSeek-R1’s transformer architecture is enhanced to support simultaneous token prediction across multiple layers.</li> <li>Each layer in the model computes token probabilities independently while maintaining consistency across the sequence.</li> </ul> </li> <li> <strong>Speculative Decoding with Verification</strong>: <ul> <li>During inference, DeepSeek-R1 generates speculative multi-token sequences and verifies their coherence through a hierarchical token verification mechanism.</li> <li>This approach dynamically adjusts the number of tokens predicted in each step based on confidence scores, ensuring that low-confidence tokens are reevaluated before finalizing outputs.</li> </ul> </li> <li> <strong>Training Objective</strong>: <ul> <li>The model is trained with a combination of standard cross-entropy loss for next-token prediction and an auxiliary loss that encourages parallel token prediction.</li> <li>The loss function is formulated as:<br> LMTP=λ∑k=1DLCE(Pk,Tk) <ul> <li>where D is the number of parallel tokens predicted per step, and LCE represents the cross-entropy loss for each predicted token.</li> </ul> </li> </ul> </li> <li> <strong>Adaptive Token Selection with RL</strong>: <ul> <li>DeepSeek-R1 employs an RL-based approach to refine multi-token predictions, ensuring that higher-quality token sequences are prioritized.</li> <li>The RL framework assigns rewards based on coherence, fluency, and alignment with ground-truth data.</li> <li>This RL-driven strategy effectively reduces hallucinations and improves long-range coherence in generated text.</li> </ul> </li> <li> <strong>Memory and Compute Efficiency</strong>: <ul> <li>The MTP module is optimized to minimize additional memory overhead, leveraging weight-sharing mechanisms within transformer layers.</li> <li>The speculative decoding mechanism integrates efficiently with DeepSeek-R1’s caching strategy, ensuring that redundant computations are avoided.</li> </ul> </li> </ol> </li> </ul> <h5 id="mathematical-formulation-1">Mathematical Formulation</h5> <ul> <li>The prediction function follows an autoregressive formulation:</li> </ul> <table> <tbody> <tr> <td>P(yt</td> <td>x)=∏t=1TP(yt</td> <td>y&lt;t,x)</td> </tr> </tbody> </table> <ul> <li>By introducing parallel decoding, DeepSeek-R1 reduces inference complexity from O(T) to O(Tk), where k is the number of tokens predicted per step.</li> </ul> <h2 id="training-pipeline-from-pre-training-to-reasoning">Training Pipeline: from Pre-Training to Reasoning</h2> <ul> <li>DeepSeek-R1 employs a multi-stage training pipeline designed to enhance reasoning capabilities while maintaining efficiency. This process includes distinct phases, each guided by task-specific loss functions and reward mechanisms, ensuring progressive refinement in performance. The key stages are SFT, RL, Rejection Sampling, and an additional RL phase for generalization. Together, these steps improve DeepSeek-R1’s ability to tackle complex reasoning tasks while ensuring clarity and coherence in its outputs.</li> <li>DeepSeek-R1’s training process unfolds in four key phases, each progressively refining its reasoning ability while expanding generalization and alignment: <ol> <li> <strong>Cold Start with SFT</strong> <ul> <li>Fine-tuning on thousands of high-quality Chain-of-Thought (CoT) examples to establish structured reasoning.</li> <li>Uses a structured output format for improved readability.</li> <li>Employs a cross-entropy-based loss function for optimization.</li> </ul> </li> <li> <strong>RL with GRPO</strong> <ul> <li>Policy optimization via Group-based Reward Normalization (GRPO).</li> <li>Rewards assigned based on accuracy, format consistency, and language alignment.</li> <li>Prevents reward hacking by avoiding neural reward models.</li> </ul> </li> <li> <strong>Rejection Sampling &amp; Expanded SFT</strong> <ul> <li>Filters high-quality RL outputs to enhance supervised fine-tuning.</li> <li>Expands training data to include non-reasoning tasks, ensuring broader applicability.</li> </ul> </li> <li> <strong>Final RL Phase for Generalization</strong> <ul> <li>Integrates diverse task distributions, extending beyond structured reasoning.</li> <li>Ensures alignment with human feedback, particularly in conversational settings.</li> </ul> </li> </ol> </li> <li>Through this multi-stage refinement process, DeepSeek-R1 surpasses previous models in accuracy, coherence, and real-world usability, setting a new benchmark for AI reasoning capabilities.</li> </ul> <h3 id="stage-1-cold-start-with-sft">Stage 1: Cold Start with SFT</h3> <h4 id="fine-tuning-with-high-quality-chain-of-thought-cot-examples">Fine-Tuning with High-Quality Chain-of-Thought (CoT) Examples</h4> <ul> <li>DeepSeek-R1 begins its journey by fine-tuning the DeepSeek-V3-Base model with a carefully curated dataset of high-quality Chain-of-Thought (CoT) examples. These examples are obtained through a combination of: <ol> <li> <strong>Few-shot prompting:</strong> Generating detailed reasoning paths using large-scale pre-trained models.</li> <li> <strong>Manual annotation and refinement:</strong> Filtering and refining reasoning steps through human reviewers.</li> <li> <strong>Post-processing DeepSeek-R1-Zero outputs:</strong> Extracting well-structured reasoning paths from the RL-trained precursor model.</li> </ol> </li> <li>The fine-tuning step ensures that DeepSeek-R1 has a structured reasoning framework before entering RL. Unlike DeepSeek-R1-Zero, which learned reasoning solely from RL, DeepSeek-R1 leverages cold-start fine-tuning to avoid the chaotic early stages of RL training.</li> </ul> <h4 id="structured-output-format">Structured Output Format</h4> <ul> <li>One of the key issues encountered in DeepSeek-R1-Zero was language mixing and poor readability. To address this, the fine-tuning phase enforces a structured reasoning format:</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;span&gt;&amp;lt;reasoning_process&amp;gt;&lt;/span&gt; Step-by-step explanation of the problem-solving approach &lt;span&gt;&amp;lt;/reasoning_process&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; Final Answer &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
</code></pre></div></div> <ul> <li>This format ensures readability and helps align the model’s outputs with human expectations.</li> </ul> <h4 id="loss-function-for-sft">Loss Function for SFT</h4> <ul> <li> <p>The model is optimized using a supervised cross-entropy loss:</p> <table> <tbody> <tr> <td>LSFT=−∑i=1nlog⁡Pθ(oi</td> <td>q,{o1,…,oi−1})</td> </tr> </tbody> </table> <ul> <li>where: <ul> <li>oi is the ith token in the output sequence,</li> <li>q is the input query,</li> <li>o1,…,oi−1 are previously generated tokens.</li> </ul> </li> </ul> </li> <li> <p>This step helps DeepSeek-R1 establish a strong foundation for structured reasoning before RL.</p> </li> </ul> <h3 id="stage-2-rl">Stage 2: RL</h3> <ul> <li>RL is the backbone of DeepSeek-R1’s reasoning evolution. The model learns to optimize its reasoning trajectories based on reward-driven feedback mechanisms, leading to significant improvements in accuracy and coherence.</li> </ul> <h4 id="deepseeks-rl-methodology-a-conceptual-overview">DeepSeek’s RL Methodology: a Conceptual Overview</h4> <ul> <li>DeepSeek’s RL methodology is fundamentally inspired by self-play paradigms, akin to training AI models in games like chess. Traditionally, AI models trained for complex reasoning tasks leverage large datasets composed of human-annotated examples. However, such datasets often lack comprehensive coverage and may not contain optimal solutions. RL circumvents this limitation by allowing AI models to explore solutions autonomously, refining their strategies based on reward-driven feedback mechanisms.</li> <li>Consider an AI model trained to play chess. Instead of learning from a fixed dataset of historical games, the AI is programmed with only the fundamental rules of chess. It then engages in self-play, continuously experimenting with various moves. Initially, the model executes suboptimal actions, leading to losses. However, through iterative play, it identifies effective strategies and reinforces moves that contribute to victories while discarding ineffective ones. This trial-and-error process, governed by RL principles, enables the AI to develop strategies surpassing human intuition.</li> <li>DeepSeek applies this RL-based approach to reasoning-intensive domains, such as mathematical problem-solving. Rather than training on explicit mathematical derivations, the AI is provided with fundamental mathematical rules and tasked with solving problems autonomously. The model systematically explores various solution paths, reinforcing those that yield correct answers while discarding ineffective methodologies. Over time, this process enhances the AI’s mathematical reasoning abilities beyond traditional supervised learning approaches. The self-improving nature of RL fosters the discovery of novel problem-solving strategies, resulting in superior performance in mathematical reasoning and logic-based tasks.</li> </ul> <h4 id="policy-optimization-background">Policy Optimization: Background</h4> <ul> <li>Policy optimization involves an RL framework refining an agent’s decision-making process to maximize expected rewards.</li> <li>Traditional methods like REINFORCE provide a fundamental approach to learning policies directly from sampled trajectories, while more advanced techniques like Proximal Policy Optimization (PPO) introduce stability constraints.</li> <li>Group Relative Policy Optimization (GRPO) builds upon these foundations, addressing key limitations to enhance efficiency and stability in large-scale applications. GRPO can be seen as a hybrid between REINFORCE and PPO, integrating the variance reduction of PPO with the simplicity of direct policy gradient updates from REINFORCE, making it a promising alternative for reinforcement learning in large-scale language model training.</li> </ul> <h5 id="the-reinforce-algorithm">The REINFORCE Algorithm</h5> <ul> <li>Before discussing GRPO, it is essential to understand REINFORCE, one of the earliest and simplest reinforcement learning algorithms.</li> </ul> <h6 id="what-is-reinforce">What is REINFORCE?</h6> <ul> <li> <p>REINFORCE is a policy gradient method that updates a policy network based on complete trajectories sampled from the environment. It follows a straightforward approach:</p> <ol> <li> <strong>Sampling Trajectories:</strong> The agent interacts with the environment, generating an episode (a sequence of states, actions, and rewards).</li> <li> <strong>Reward Calculation:</strong> A single reward is assigned to the entire episode.</li> <li> <strong>Policy Update:</strong> <ul> <li>Compute the gradient of the policy based on the log probability of actions taken.</li> <li>Scale the gradient by the total episode reward.</li> <li>Update the policy network using gradient descent.</li> </ul> </li> </ol> </li> </ul> <h6 id="limitations-of-reinforce">Limitations of REINFORCE</h6> <ul> <li> <strong>High Variance:</strong> Since rewards are computed for entire episodes, updates can be noisy.</li> <li> <strong>Unstable Learning:</strong> Policy updates can be drastic, leading to instability.</li> <li> <strong>Lack of Baseline Correction:</strong> REINFORCE does not normalize rewards, making training inefficient.</li> </ul> <h6 id="how-grpo-builds-on-reinforce">How GRPO Builds on REINFORCE</h6> <ul> <li>GRPO modifies REINFORCE by: <ul> <li> <strong>Using Group-Based Advantage Estimation:</strong> Instead of relying on a single episode reward, GRPO normalizes rewards within a group.</li> <li> <strong>Introducing a Clipped Loss Function:</strong> Prevents large policy updates.</li> <li> <strong>Reducing Variance:</strong> By averaging multiple sampled responses, GRPO provides a more stable policy update mechanism.</li> </ul> </li> <li>By addressing these weaknesses, GRPO combines the simplicity of REINFORCE with the stability of modern policy optimization techniques.</li> </ul> <h5 id="proximal-policy-optimization-ppo">Proximal Policy Optimization (PPO)</h5> <ul> <li>Proximal Policy Optimization (PPO) is a widely used RL algorithm in RLHF, particularly in LLMs. PPO is an actor-critic method designed to optimize a policy while ensuring stable updates by limiting drastic deviations from previous policies.</li> <li>For a detailed discourse, please refer our <a href="https://aman.ai/primers/ai/llm-alignment/#proximal-policy-optimization-ppo" rel="external nofollow noopener" target="_blank">PPO primer</a>.</li> </ul> <h6 id="how-ppo-works">How PPO Works</h6> <ul> <li>PPO requires three primary components: <ul> <li> <strong>Policy (πθ):</strong> The LLM being fine-tuned.</li> <li> <strong>Reward Model (Rϕ):</strong> A frozen network providing scalar feedback on complete responses.</li> <li> <strong>Critic (Vγ):</strong> A trainable value function predicting future rewards for partial responses.</li> </ul> </li> <li>PPO follows an iterative workflow: <ol> <li> <strong>Response Generation:</strong> The model generates multiple responses per prompt.</li> <li> <strong>Reward Assignment:</strong> The reward model scores each response.</li> <li> <strong>Advantage Computation:</strong> The advantage function estimates how much better an action is compared to average actions.</li> <li> <strong>Policy Optimization:</strong> The LLM is updated to maximize the advantage function using PPO’s clipped objective.</li> <li> <strong>Critic Update:</strong> The value function is trained to improve reward prediction.</li> </ol> </li> </ul> <h6 id="challenges-with-ppo">Challenges with PPO</h6> <ul> <li> <strong>High Computational Cost:</strong> PPO requires a separate critic model, which doubles memory requirements.</li> <li> <strong>Training Complexity:</strong> The critic must be updated in tandem with the policy, making training unstable.</li> <li> <strong>Potential Bias:</strong> The critic can introduce estimation biases, affecting policy optimization.</li> <li>These limitations motivated the introduction of Group Relative Policy Optimization (GRPO) by DeepSeek AI as part of <a href="https://arxiv.org/abs/2402.03300" rel="external nofollow noopener" target="_blank">DeepSeekMath</a>.</li> </ul> <h6 id="how-grpo-builds-on-ppo">How GRPO Builds on PPO</h6> <ul> <li>GRPO addresses PPO’s limitations by replacing the critic with a group-based reward normalization mechanism, reducing computational overhead while maintaining sample efficiency.</li> <li>Unlike PPO, which relies on a critic to estimate future rewards, GRPO directly normalizes rewards within a group of responses to compute an advantage function, eliminating potential biases introduced by the critic.</li> <li>PPO’s clipped objective function is retained in GRPO, ensuring stable policy updates and preventing overly large parameter shifts.</li> <li>By avoiding the need for a separate critic model, GRPO reduces memory and compute costs, making it more scalable for large-scale training.</li> <li>The combination of group-based reward normalization and clipped policy updates allows GRPO to achieve comparable stability to PPO while being computationally more efficient.</li> <li>A comparative analysis of REINFORCE, PPO, and GRPO in terms of critic model usage, compute cost, stability, advantage estimation, and training complexity, highlighting GRPO’s high stability and PPO’s high compute cost.</li> </ul> <table> <thead> <tr> <th><strong>Feature</strong></th> <th><strong>REINFORCE</strong></th> <th><strong>PPO</strong></th> <th><strong>GRPO</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Critic Model?</strong></td> <td>❌ No</td> <td>✅ Yes</td> <td>❌ No</td> </tr> <tr> <td><strong>Compute Cost</strong></td> <td><strong>Low</strong></td> <td><strong>High</strong></td> <td><strong>Low</strong></td> </tr> <tr> <td><strong>Stability</strong></td> <td>Low (high variance)</td> <td>Moderate</td> <td>High (group normalization)</td> </tr> <tr> <td><strong>Advantage Estimation</strong></td> <td>Episode reward</td> <td>Learned critic</td> <td>Group-based normalization</td> </tr> <tr> <td><strong>Training Complexity</strong></td> <td><strong>Low</strong></td> <td><strong>High</strong></td> <td><strong>Moderate</strong></td> </tr> </tbody> </table> <h4 id="group-relative-policy-optimization-grpo">Group Relative Policy Optimization (GRPO)</h4> <ul> <li>GRPO, introduced in <a href="https://arxiv.org/abs/2402.03300" rel="external nofollow noopener" target="_blank">DeepSeekMath</a>, is a RL method that has played a pivotal role in the development of DeepSeek-R1. It is a simplified and cost-efficient alternative to traditional policy optimization techniques like Proximal Policy Optimization (PPO), since it does not require a separate critic model. Instead, it estimates the baseline from a group of generated outputs, reducing computational overhead while maintaining sample efficiency. This group-based approach ensures that each update step improves on previous iterations without overfitting to individual trajectories.</li> <li>GRPO has evolved from a mathematical reasoning optimizer in DeepSeekMath to a core optimization technique in DeepSeek-R1, driving advanced reasoning capabilities across diverse tasks. By eliminating the critic model, leveraging group-based advantages, and incorporating multi-stage RL refinements, GRPO has made DeepSeek-R1 a powerful open-source reasoning models.</li> <li>GRPO is central to DeepSeek-R1’s RL pipeline, providing a lightweight yet powerful optimization mechanism. Its key innovations include: <ul> <li>Removing the critic model, which significantly reduces memory overhead.</li> <li>Stabilizing policy updates through group-based advantage estimation.</li> <li>Efficient training while maintaining strong performance compared to PPO-based methods.</li> </ul> </li> <li>From its inception in DeepSeekMath to its refined implementation in DeepSeek-R1, GRPO has undergone several enhancements, including multi-stage RL, improved reward modeling, and refined optimization strategies. This section details GRPO’s mathematical formulation, its implementation, and its role in DeepSeek-R1.</li> </ul> <h5 id="key-innovations">Key Innovations</h5> <ul> <li> <strong>No Critic Model:</strong> Instead of learning a separate value function, GRPO derives advantages directly from response samples.</li> <li> <strong>Group-Based Advantage Estimation:</strong> GRPO normalizes rewards within a batch of generated responses.</li> <li> <strong>Improved Efficiency:</strong> Eliminates critic updates, reducing training overhead and memory consumption by ~50%.</li> <li> <strong>Stable Training:</strong> By computing relative rewards within a group, GRPO ensures that policy updates remain well-regulated.</li> </ul> <h5 id="evolution-of-grpo-from-deepseekmath-to-deepseek-r1">Evolution of GRPO: from DeepSeekMath to DeepSeek-R1</h5> <h6 id="phase-1-grpo-in-deepseekmath-mathematical-rl">Phase 1: GRPO in DeepSeekMath (Mathematical RL)</h6> <ul> <li>GRPO was originally introduced in DeepSeekMath to optimize models for mathematical reasoning.</li> <li>It replaced PPO’s critic model with a group-based reward normalization technique, making training more efficient while maintaining stability.</li> <li>The reward function primarily evaluated mathematical correctness, using structured evaluation metrics.</li> </ul> <h6 id="phase-2-grpo-in-deepseek-r1-zero-self-evolving-reasoning">Phase 2: GRPO in DeepSeek-R1-Zero (Self-Evolving Reasoning)</h6> <ul> <li>With DeepSeek-R1-Zero, GRPO was applied without any SFT—pure RL was used to shape reasoning behaviors from scratch.</li> <li>The model self-learned reasoning skills such as step-by-step problem-solving and self-verification.</li> <li>However, DeepSeek-R1-Zero exhibited readability issues (e.g., unstructured reasoning outputs, language mixing).</li> </ul> <h6 id="phase-3-grpo-in-deepseek-r1-refined-reasoning--cold-start">Phase 3: GRPO in DeepSeek-R1 (Refined Reasoning &amp; Cold Start)</h6> <ul> <li>DeepSeek-R1 introduced a multi-stage RL pipeline incorporating a small amount of cold-start fine-tuning before applying GRPO.</li> <li>The reward model was expanded beyond mathematics to include general reasoning tasks.</li> <li>A language consistency reward was added to improve coherence and readability.</li> </ul> <h5 id="how-grpo-works">How GRPO Works</h5> <ul> <li>GRPO replaces PPO’s critic-based advantage estimation with a group-based normalization approach. Instead of learning a value function, GRPO derives relative rewards from multiple sampled responses. This enables efficient and stable policy updates while reducing computational overhead.</li> </ul> <h6 id="grpo-intuition">GRPO Intuition</h6> <ul> <li> <p>To understand GRPO, it is useful to analyze its mathematical formulation from a reverse-engineering perspective. The complexity of the equations can be misleading; in reality, GRPO consists of three main components:</p> <p>JGRPO=min([Block 1],[Block 2])−[Block 3]</p> <ul> <li>where: <ul> <li> <table> <tbody> <tr> <td>Block 1 corresponds to the first term inside the summation of the GRPO objective function: ρiAi=πθ(oi</td> <td>q)πθold(oi</td> <td>q)Ai. This represents the primary objective of policy optimization: ensuring the updated policy πθ improves upon the previous policy πθold. The core principle is straightforward: the new policy should outperform the old one in expectation.</td> </tr> </tbody> </table> </li> <li>Block 2 corresponds to the clipped version of ρiAi, i.e., clip(ρi,1−ϵ,1+ϵ)Ai. This originates from PPO and serves as a safeguard to prevent excessive updates. By taking the minimum between Block 1 and this clipped value, GRPO ensures training stability and prevents over-exaggerated policy updates.</li> <li> <table> <tbody> <tr> <td>Block 3 corresponds to the KL-divergence regularization term in the GRPO equation: βDKL(πθ</td> <td> </td> <td>πref). This term enforces similarity between the new policy and a reference policy, preventing the optimization process from deviating too far from the original distribution and ensuring controlled updates.</td> </tr> </tbody> </table> </li> </ul> </li> </ul> </li> <li>One of the most notable aspects of GRPO’s success is its redesigned approach to advantage computation. Traditional PPO computes advantages using a learned value network combined with temporal difference learning, requiring additional memory and computation to maintain a separate critic model. In contrast, GRPO fundamentally simplifies this by directly comparing sampled actions within a group and leveraging statistical normalization to compute advantages. This group-based methodology eliminates the need for a value network, significantly reducing memory overhead—by approximately half—while simultaneously aligning with the core principle of evaluating mathematical solutions relative to other approaches to the same problem.</li> <li>This design choice has proven especially effective for mathematical reasoning tasks. By using a direct group-based comparison, GRPO enhances the model’s ability to develop structured reasoning strategies. Empirical results demonstrate that this method not only improves performance on mathematical reasoning benchmarks but also maintains training stability and computational efficiency. The elimination of the critic network removes potential biases from learned value functions, making GRPO particularly well-suited for domains requiring objective evaluation of multiple solution paths.</li> <li>Additionally, the “Group” aspect in GRPO refers to computing the expectation over a set of sampled outputs, which are then averaged to stabilize training. The presence of normalization within A (mean and standard deviation) may initially appear complex, but it simply follows conventional normalization techniques used in machine learning.</li> <li>Thus, when stripped of indices, subscripts, and hyperparameters, GRPO reduces to a simple balance between policy improvement and control mechanisms, reinforcing why it is regarded as an efficient and intuitive optimization method.</li> </ul> <h6 id="grpo-workflow">GRPO Workflow</h6> <ol> <li> <strong>Sample a Group of Responses (G):</strong> Generate multiple outputs (r1,r2,…,rN) for a given prompt.</li> <li> <strong>Compute Rewards:</strong> Assign rewards using the reward model (Rϕ).</li> <li> <strong>Calculate Advantage (Ai) Using Group Normalization:</strong> Ai=Rϕ(ri)−mean(G)std(G) <ul> <li>This ensures the model optimizes responses relative to its own generated outputs instead of relying on a critic.</li> </ul> </li> </ol> <h6 id="mathematical-formulation-2">Mathematical Formulation</h6> <ul> <li> <p>The GRPO objective function is:</p> <table> <tbody> <tr> <td>JGRPO(θ)=Eq∼P(Q),{oi}i=1G∼πθold(O</td> <td>q)[1G∑i=1Gmin(ρiAi,clip(ρi,1−ϵ,1+ϵ)Ai)−βDKL(πθ‖πref)]</td> </tr> </tbody> </table> <ul> <li>where: <ul> <li> <table> <tbody> <tr> <td>ρi is the likelihood ratio, indicating how much the new policy diverges from the old one: ρi=πθ(oi</td> <td>q)πθold(oi</td> <td>q)</td> </tr> </tbody> </table> </li> <li>Ai is the group-based advantage function, which normalizes rewards across sampled outputs: Ai=ri−mean(r1,…,rG)std(r1,…,rG)</li> <li>DKL(πθ‖πref) is a KL regularization term that constrains updates within a stable range.</li> <li>G is the group size (number of sampled outputs per query).</li> <li>ϵ controls clipping to prevent overly aggressive updates.</li> <li>β controls the strength of KL regularization.</li> </ul> </li> </ul> </li> <li> <p>The expanded form of the GRPO objective function can be written as:</p> <table> <tbody> <tr> <td>JGRPO(θ)=E[∑i=1Gmin(πθ(oi</td> <td>q)πθold(oi</td> <td>q)Ai,clip(πθ(oi</td> <td>q)πθold(oi</td> <td>q),1−ϵ,1+ϵ)Ai)−βDKL(πθ</td> <td> </td> <td>πref)]</td> </tr> </tbody> </table> <ul> <li>where: <ul> <li>ϵ is the trust region clipping parameter to stabilize training,</li> <li>Ai is the advantage function, computed from group-based reward normalization.</li> </ul> </li> </ul> </li> </ul> <h5 id="step-by-step-breakdown">Step-by-Step Breakdown</h5> <h6 id="likelihood-ratio-ρi">Likelihood Ratio ρi</h6> <ul> <li> <table> <tbody> <tr> <td>Measures how much the probability of generating output oi has changed under the new policy compared to the old policy: ρi=πθ(oi</td> <td>q)πθold(oi</td> <td>q)</td> </tr> </tbody> </table> </li> </ul> <h6 id="advantage-function-ai">Advantage Function Ai</h6> <ul> <li>Instead of relying on a separate value network (critic), GRPO estimates the advantage function using a group of sampled outputs: Ai=ri−mean(r1,…,rG)std(r1,…,rG)</li> <li>This reduces training instability and enhances efficiency.</li> </ul> <h6 id="clipping-mechanism">Clipping Mechanism</h6> <ul> <li>Prevents drastic policy updates that could destabilize training: clip(ρi,1−ϵ,1+ϵ)</li> </ul> <h6 id="kl-divergence-penalty">KL Divergence Penalty</h6> <ul> <li>Ensures the policy remains close to a reference distribution: βDKL(πθ‖πref)</li> <li>Prevents mode collapse and excessive policy drift.</li> </ul> <h5 id="implementation-details-1">Implementation Details</h5> <h6 id="training-setup">Training Setup</h6> <ul> <li>GRPO is implemented by sampling multiple outputs per query and computing rewards over the group.</li> <li>The mean and standard deviation of rewards provide a normalized baseline for training.</li> </ul> <h6 id="reward-function-design">Reward Function Design</h6> <ul> <li>In DeepSeekMath: The reward was primarily based on mathematical correctness.</li> <li>In DeepSeek-R1: The reward function expanded to include: <ul> <li> <strong>Accuracy Rewards</strong>: Evaluating correctness for general reasoning tasks (e.g., coding, science, logic).</li> <li> <strong>Format Rewards</strong>: Ensuring structured reasoning using <code class="language-plaintext highlighter-rouge">&lt;think&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;answer&gt;</code> tags.</li> </ul> </li> </ul> <h6 id="optimization-process">Optimization Process</h6> <ul> <li>The model samples multiple outputs per query, computes likelihood ratios and advantage estimates, and updates its policy using the clipped objective function.</li> </ul> <h6 id="efficiency-considerations">Efficiency Considerations</h6> <ul> <li>Removes critic model, reducing memory consumption.</li> <li>Batch computation for group sampling, improving efficiency.</li> <li>Iterative RL refinement, enabling continual improvement.</li> </ul> <h5 id="applications">Applications</h5> <h6 id="deepseek-r1-zero-rl-from-scratch">DeepSeek-R1-Zero: RL from Scratch</h6> <ul> <li>DeepSeek-R1-Zero explored the potential of LLMs to develop reasoning capabilities without any supervised data.</li> <li>The model naturally developed skills like self-verification and reflection.</li> <li>However, poor readability and language mixing emerged as challenges.</li> </ul> <h6 id="deepseek-r1-multi-stage-rl-with-cold-start">DeepSeek-R1: Multi-Stage RL with Cold Start</h6> <ul> <li>To refine DeepSeek-R1-Zero, DeepSeek-R1 introduced: <ol> <li> <strong>Cold Start Fine-Tuning</strong>: <ul> <li>The model was first fine-tuned on high-quality Chain-of-Thought (CoT) examples.</li> <li>This ensured structured reasoning and better readability.</li> </ul> </li> <li> <strong>RL with GRPO</strong>: <ul> <li>GRPO was used to refine reasoning skills in math, logic, and general problem-solving.</li> <li>A language consistency reward was added to prevent language mixing.</li> </ul> </li> <li> <strong>Final RL Optimization</strong>: <ul> <li>After RL, a rejection sampling step generated better training data.</li> <li>A final GRPO optimization phase was conducted with diverse prompts.</li> </ul> </li> </ol> </li> </ul> <h5 id="comparative-analysis-reinforce-vs-trpo-vs-ppo-vs-dpo-vs-kto-vs-apo-vs-grpo">Comparative Analysis: REINFORCE vs. TRPO vs. PPO vs. DPO vs. KTO vs. APO vs. GRPO</h5> <ul> <li> <strong>REINFORCE</strong>: <ul> <li> <strong>Function</strong>: The simplest policy gradient algorithm that updates the model based on the cumulative reward received from complete trajectories.</li> <li> <strong>Implementation</strong>: Generates an entire episode, calculates rewards at the end, and updates the policy network based on a weighted log probability loss.</li> <li> <strong>Practical Challenges</strong>: High variance in policy updates, slow convergence, and instability due to unbounded updates.</li> </ul> </li> <li> <strong>TRPO</strong>: <ul> <li> <strong>Function</strong>: Trust Region Policy Optimization (TRPO) improves policy updates by constraining step sizes to avoid instability.</li> <li> <strong>Implementation</strong>: Uses a constrained optimization formulation to ensure each update remains within a trust region, preventing excessive deviations.</li> <li> <strong>Practical Challenges</strong>: Computationally expensive due to the constraint-solving step and requires second-order optimization techniques.</li> </ul> </li> <li> <strong>PPO</strong>: <ul> <li> <strong>Function</strong>: An RL algorithm that optimizes the language model by limiting how far it can drift from a previous version of the model.</li> <li> <strong>Implementation</strong>: Involves sampling generations from the current model, judging them with a reward model, and using this feedback for updates.</li> <li> <strong>Practical Challenges</strong>: Can be slow and unstable, especially in distributed settings.</li> </ul> </li> <li> <strong>DPO</strong>: <ul> <li> <strong>Function</strong>: Minimizes the negative log-likelihood of observed human preferences to align the language model with human feedback.</li> <li> <strong>Data Requirement</strong>: Requires paired preference data.</li> <li> <strong>Comparison with KTO</strong>: While DPO has been effective, KTO offers competitive or superior performance without the need for paired preferences.</li> </ul> </li> <li> <strong>KTO</strong>: <ul> <li> <strong>Function</strong>: Adapts the Kahneman-Tversky human value function to the language model setting. It uses this adapted function to directly maximize the utility of model outputs.</li> <li> <strong>Data Requirement</strong>: Does not need paired preference data, only knowledge of whether an output is desirable or undesirable for a given input.</li> <li> <strong>Practicality</strong>: Easier to deploy in real-world scenarios where desirable/undesirable outcome data is more abundant.</li> <li> <strong>Model Comparison</strong>: Matches or exceeds the performance of direct preference optimization methods across various model sizes (from 1B to 30B).</li> </ul> </li> <li> <strong>APO</strong>: <ul> <li> <strong>Function</strong>: Introduces a family of contrastive objectives explicitly accounting for the relationship between the model and the preference dataset. This includes APO-zero, which increases desirable outputs while decreasing undesirable ones, and APO-down, which fine-tunes models based on specific quality thresholds.</li> <li> <strong>Data Requirement</strong>: Works effectively with paired preference datasets created through controlled methods like CLAIR and supports stable alignment even for challenging datasets.</li> <li> <strong>Practicality</strong>: Excels at aligning strong models with minimally contrasting preferences, enhancing performance on challenging metrics like MixEval-Hard while providing stable, interpretable training dynamics.</li> <li> <strong>Model Comparison</strong>: Outperformed conventional alignment objectives across multiple benchmarks, closing a 45% performance gap with GPT4-turbo when trained with CLAIR preferences.</li> </ul> </li> <li> <strong>GRPO</strong>: <ul> <li> <strong>Function</strong>: A variant of PPO that removes the need for a critic model by estimating the baseline using group scores, improving memory and computational efficiency while enhancing the mathematical reasoning of models.</li> <li> <strong>Data Requirement</strong>: Utilizes group-based rewards computed from multiple outputs for each query, normalizing these scores to guide optimization.</li> <li> <strong>Practicality</strong>: Focuses on reducing training resource consumption compared to PPO and improving RL stability.</li> <li> <strong>Model Comparison</strong>: Demonstrated superior performance on tasks like GSM8K and MATH benchmarks, outperforming other models of similar scale while improving both in-domain and out-of-domain reasoning tasks.</li> </ul> </li> </ul> <h6 id="tabular-comparison">Tabular Comparison</h6> <table> <thead> <tr> <th><strong>Aspect</strong></th> <th><strong>REINFORCE</strong></th> <th><strong>TRPO</strong></th> <th><strong>PPO</strong></th> <th><strong>DPO</strong></th> <th><strong>KTO</strong></th> <th><strong>APO</strong></th> <th><strong>GRPO</strong></th> </tr> </thead> <tbody> <tr> <td>Objective</td> <td>Policy gradient optimization without constraints.</td> <td>Ensures stable policy updates within a constrained region.</td> <td>Maximizes expected reward while preventing large policy updates.</td> <td>Optimizes policy based on binary classification of human preferences.</td> <td>Aligns models based on Kahneman-Tversky optimization for utility maximization.</td> <td>Anchored alignment with specific control over preference-based likelihood adjustments.</td> <td>Leverages group-based relative advantages and removes the critic network.</td> </tr> <tr> <td>Learning Mechanism</td> <td>Monte Carlo policy gradients with high variance.</td> <td>Second-order optimization with trust region constraints.</td> <td>Policy gradients with a clipped surrogate objective.</td> <td>Cross-entropy optimization over paired preferences.</td> <td>Maximizes desirable likelihoods relative to undesirables, without paired data.</td> <td>Uses variants like APO-zero or APO-down for stable preference-based optimization.</td> <td>Group normalization with policy gradients, eliminating the critic network.</td> </tr> <tr> <td>Stability</td> <td>Low (high variance, unstable updates).</td> <td>High (enforces trust region for stable updates).</td> <td>Relies on clipping mechanisms to avoid destabilization.</td> <td>Stable as it directly optimizes preferences.</td> <td>Stable due to focus on unpaired desirability adjustments.</td> <td>Offers robust training stability, scaling better on models trained with mixed-quality datasets.</td> <td>Stable due to normalization of rewards across groups.</td> </tr> <tr> <td>Training Complexity</td> <td>High (unconstrained updates).</td> <td>Very high (requires second-order optimization and solving constraints).</td> <td>High, due to balancing reward maximization with policy constraints.</td> <td>Moderate; uses simplified binary preference objectives.</td> <td>Simplifies alignment by focusing only on desirability.</td> <td>Adaptive and context-aware; requires understanding dataset-model relationships.</td> <td>Reduces overhead via group-based scoring.</td> </tr> <tr> <td>Performance</td> <td>Unstable and sample-inefficient.</td> <td>More stable than PPO but computationally expensive.</td> <td>Strong performance on tasks with clear reward signals but prone to instability in distributed setups.</td> <td>Effective for straightforward preference alignment tasks.</td> <td>Competitive or better alignment than preference-based methods without paired data needs.</td> <td>Superior alignment results, particularly for nuanced dataset control.</td> <td>Excels in reasoning tasks, offering computational efficiency.</td> </tr> <tr> <td>Notable Strength</td> <td>Simple to implement but inefficient.</td> <td>Ensures stable policy updates through trust-region constraints.</td> <td>Widely used in RL settings, good at reward-based optimization.</td> <td>Directly optimizes for preferences without needing a separate reward model.</td> <td>Handles binary data efficiently, avoiding paired data dependencies.</td> <td>Allows precise alignment with nuanced datasets.</td> <td>Simplifies reward aggregation; strong for reasoning-heavy tasks.</td> </tr> <tr> <td>Scenarios Best Suited</td> <td>RL tasks where simplicity is preferred over efficiency.</td> <td>High-stability RL tasks requiring constraint-driven policy improvements.</td> <td>RL environments where reward signals are predefined.</td> <td>Scenarios with abundant paired human feedback.</td> <td>Real-world settings with broad definitions of desirable/undesirable outputs.</td> <td>Tasks requiring precise alignment with minimally contrasting preferences.</td> <td>Mathematical reasoning or low-resource training setups.</td> </tr> </tbody> </table> <h4 id="reward-functions">Reward Functions</h4> <ul> <li>Reward modeling is a crucial component of the reinforcement learning process in DeepSeek-R1, determining the optimization direction and shaping the model’s reasoning behavior. DeepSeek-R1 employs a rule-based reward system instead of a neural reward model to avoid reward hacking and excessive computational costs. The primary reward functions guiding DeepSeek-R1 are:</li> </ul> <h5 id="accuracy-rewards">Accuracy Rewards</h5> <ul> <li> <p>The accuracy reward model ensures that the model generates factually correct and verifiable responses. It is particularly useful for tasks with deterministic outcomes, such as mathematics and coding.</p> </li> <li> <strong>Mathematical Tasks:</strong> <ul> <li>The model is required to output the final answer in a specified format (e.g., within a box or marked in LaTeX), enabling automated rule-based verification.</li> <li>For example, in mathematical problems, the correctness of the response is checked against a ground-truth solution.</li> </ul> </li> <li> <strong>Programming Tasks:</strong> <ul> <li>For coding problems, correctness is determined using unit tests. The model’s output is compiled and executed against predefined test cases, and rewards are assigned based on the number of passing tests.</li> <li>If the generated code is syntactically incorrect, a small penalty is applied to discourage such outputs.</li> </ul> </li> <li> <strong>Group-Based Normalization:</strong> <ul> <li>Instead of relying on a separate critic network, DeepSeek-R1 uses a group-based reward normalization method. Given a group of responses {r1,r2,…,rG}, the advantage function is calculated as: Ai=ri−mean(r1,…,rG)std(r1,…,rG) <ul> <li>where Ai represents the normalized advantage of response i, and standardization ensures stable training updates.</li> </ul> </li> </ul> </li> </ul> <h5 id="format-rewards">Format Rewards</h5> <ul> <li> <p>Beyond correctness, DeepSeek-R1 is trained to produce well-structured and human-readable outputs. The format reward model enforces this by incentivizing adherence to a structured reasoning format.</p> </li> <li> <strong>Reasoning and Answer Separation:</strong> <ul> <li> <p>The model’s responses must follow a two-stage format:</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>&lt;span&gt;&amp;lt;think&amp;gt;&lt;/span&gt; Step-by-step breakdown of the reasoning &lt;span&gt;&amp;lt;/think&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;answer&amp;gt;&lt;/span&gt; Final Answer &lt;span&gt;&amp;lt;/answer&amp;gt;&lt;/span&gt;
</code></pre></div> </div> </li> <li> <p>This ensures that the model explicitly separates its reasoning process from its final answer, improving clarity and user comprehension.</p> </li> </ul> </li> <li> <strong>Language Consistency Reward:</strong> <ul> <li>One challenge observed in earlier versions, such as DeepSeek-R1-Zero, was language mixing, where responses included a blend of multiple languages (e.g., partial English and partial Chinese).</li> <li>To mitigate this, DeepSeek-R1 incorporates a language consistency reward, defined as the proportion of words in the target language: Rlang=Count of words in target languageTotal word count</li> <li>This encourages the model to maintain linguistic coherence without degrading its reasoning performance.</li> </ul> </li> </ul> <h5 id="combined-reward-function">Combined Reward Function</h5> <ul> <li> <p>The final reward signal for DeepSeek-R1 is computed as a weighted sum of the individual reward components:</p> <p>Rfinal=αRaccuracy+βRformat+γRlang</p> <ul> <li>where: <ul> <li>α, β, and γ are hyperparameters controlling the relative contributions of each reward type.</li> <li> <strong>Accuracy rewards</strong> ensure correctness,</li> <li> <strong>Format rewards</strong> ensure structured output,</li> <li> <strong>Language consistency rewards</strong> ensure readability and coherence.</li> </ul> </li> </ul> </li> <li> <p>This design choice balances factual correctness with user-friendly response formatting, making DeepSeek-R1 a powerful reasoning model.</p> </li> </ul> <h5 id="why-rule-based-rewards-instead-of-neural-reward-models">Why Rule-Based Rewards Instead of Neural Reward Models?</h5> <ul> <li>DeepSeek-R1 avoids the use of neural reward models because they are susceptible to reward hacking and require costly retraining. Instead, a deterministic rule-based approach provides: <ul> <li> <strong>Greater transparency:</strong> Rewards are interpretable and verifiable.</li> <li> <strong>Reduced computational cost:</strong> No need for an additional neural network.</li> <li> <strong>More stable training dynamics:</strong> Since rule-based rewards are fixed, they do not drift over time.</li> </ul> </li> </ul> <h5 id="implementation-in-grpo">Implementation in GRPO</h5> <ul> <li>DeepSeek-R1’s Group Relative Policy Optimization (GRPO) framework leverages these reward functions during training: <ul> <li>A batch of multiple outputs per query is sampled.</li> <li>The relative rewards within the group are computed.</li> <li>The advantage estimates are normalized.</li> <li>The policy is updated using a clipped objective function that prevents large policy shifts.</li> </ul> </li> <li>This process ensures efficient reinforcement learning without the need for a separate critic model, leading to more stable and scalable training.</li> <li>Further details can be found in the section on <a href="https://aman.ai/primers/ai/deepseek-R1/#rl-algorithm-group-relative-policy-optimization-grpo" rel="external nofollow noopener" target="_blank">RL Algorithm: Group Relative Policy Optimization (GRPO)</a>.</li> </ul> <h3 id="stage-3-rejection-sampling--expanded-supervised-fine-tuning">Stage 3: Rejection Sampling &amp; Expanded Supervised Fine-Tuning</h3> <ul> <li>After RL convergence, DeepSeek-R1 undergoes an additional fine-tuning step based on rejection sampling. This stage refines the reasoning process by incorporating: <ul> <li> <strong>Reasoning Trajectories</strong>: Selecting correct and well-structured CoT explanations from RL outputs.</li> <li> <strong>Expanded Task Coverage</strong>: Augmenting the dataset with non-reasoning tasks like: <ul> <li>Writing &amp; Summarization</li> <li>Fact-based Question Answering</li> <li>Self-cognition and safety-related responses</li> </ul> </li> </ul> </li> <li>The rejection sampling process filters out low-quality reasoning paths and ensures that the model maintains clarity, readability, and logical consistency.</li> </ul> <h3 id="stage-4-secondary-rl-for-alignment--generalization">Stage 4: Secondary RL for Alignment &amp; Generalization</h3> <ul> <li>The final stage involves another round of RL, but this time with a broader task distribution. Unlike the first RL stage, which focused primarily on reasoning-intensive tasks, this stage incorporates general user interactions such as: <ul> <li>Conversational depth (multi-turn dialogues)</li> <li>Complex instructions &amp; role-playing scenarios</li> <li>Ensuring helpfulness &amp; harmlessness in responses</li> </ul> </li> <li> <p>For general tasks, a reward model is used to align outputs with human preferences. For reasoning tasks, the original rule-based rewards (accuracy &amp; format) are retained.</p> </li> <li>This final RL phase optimizes DeepSeek-R1 for real-world deployment, ensuring that it remains robust across a variety of domains beyond structured problem-solving.</li> </ul> <h3 id="comparing-training-pipelines-deepseek-r1-vs-deepseek-r1-zero">Comparing Training Pipelines: DeepSeek-R1 vs. DeepSeek-R1-Zero</h3> <ul> <li>DeepSeek-R1 and DeepSeek-R1-Zero represent two distinct training approaches for reasoning-focused LLMs, both leveraging RL but differing significantly in their pre-training methodologies, optimization strategies, and implementation details.</li> <li>Through the below-listed refinements, DeepSeek-R1 successfully overcomes the limitations of DeepSeek-R1-Zero, showcasing how structured training pipelines can significantly enhance the reasoning performance of LLMs.</li> </ul> <h4 id="pre-training-and-initialization">Pre-Training and Initialization</h4> <ul> <li>DeepSeek-R1-Zero starts directly from DeepSeek-V3-Base, applying RL without any SFT. This “pure RL” approach forces the model to self-learn reasoning capabilities from scratch through iterative policy optimization.</li> <li>DeepSeek-R1, also starts directly from DeepSeek-V3-Base, but undergoes a cold-start fine-tuning phase, where it is trained on thousands of high-quality Chain-of-Thought (CoT) examples before undergoing RL. This additional step prevents the chaotic early-stage behavior observed in DeepSeek-R1-Zero and ensures a more structured learning trajectory.</li> </ul> <h4 id="rl-strategy">RL Strategy</h4> <ul> <li>Both models utilize GRPO as the core RL algorithm. However, their reward modeling, training templates, and optimization techniques differ significantly.</li> </ul> <h5 id="deepseek-r1-zero-pure-rl-approach">DeepSeek-R1-Zero: Pure RL Approach</h5> <ul> <li> <strong>Policy Optimization:</strong> Trained solely through GRPO, which estimates a baseline using group scores instead of a separate critic model. This makes RL more memory efficient compared to PPO-based approaches.</li> <li> <strong>Training Template:</strong> Outputs are structured using a <code class="language-plaintext highlighter-rouge">&lt;think&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;answer&gt;</code> format to encourage reasoning before answering.</li> <li> <strong>Reward Functions:</strong> <ul> <li> <strong>Accuracy Reward:</strong> Evaluates correctness for deterministic tasks like math and coding.</li> <li> <strong>Format Reward:</strong> Enforces structured reasoning using the <code class="language-plaintext highlighter-rouge">&lt;think&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;answer&gt;</code> tags.</li> </ul> </li> <li> <strong>Challenges Encountered:</strong> <ul> <li> <strong>Readability Issues:</strong> Many outputs lacked clarity, with mixed-language responses and unstructured formatting.</li> <li> <strong>Convergence Stability:</strong> Early-stage RL training led to unstable outputs, as the model lacked a prior structured reasoning framework.</li> </ul> </li> </ul> <h5 id="deepseek-r1-multi-stage-rl-with-cold-start-fine-tuning">DeepSeek-R1: Multi-Stage RL with Cold-Start Fine-Tuning</h5> <ul> <li> <strong>Cold-Start Fine-Tuning:</strong> Before RL, the model is fine-tuned on thousands of curated CoT examples, improving reasoning structure and readability.</li> <li> <strong>Enhanced Reward Functions:</strong> <ul> <li> <strong>Language Consistency Reward:</strong> Added to enforce single-language outputs and reduce language mixing issues.</li> <li> <strong>Expanded Reasoning Rewards:</strong> Covers broader reasoning domains beyond math and logic, including coding, science, and knowledge-based tasks.</li> </ul> </li> <li> <strong>Multi-Stage RL Refinement:</strong> <ul> <li> <strong>Stage 1:</strong> RL training with GRPO to refine mathematical reasoning.</li> <li> <strong>Stage 2:</strong> Rejection sampling to extract high-quality CoT explanations for further fine-tuning.</li> <li> <strong>Stage 3:</strong> Final RL Phase for alignment with human feedback, enhancing general conversational capabilities beyond structured problem-solving.</li> </ul> </li> </ul> <h4 id="implementation-details-and-computational-efficiency">Implementation Details and Computational Efficiency</h4> <table> <thead> <tr> <th><strong>Feature</strong></th> <th><strong>DeepSeek-R1-Zero</strong></th> <th><strong>DeepSeek-R1</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Pre-training Base</strong></td> <td>DeepSeek-V3-Base</td> <td>DeepSeek-V3-Base</td> </tr> <tr> <td><strong>Cold-Start SFT</strong></td> <td>❌ No SFT (Pure RL)</td> <td>✅ Fine-tuned on CoT examples before RL</td> </tr> <tr> <td><strong>RL Algorithm</strong></td> <td>GRPO</td> <td>GRPO</td> </tr> <tr> <td><strong>Reward Types</strong></td> <td>Accuracy, Format</td> <td>Accuracy, Format, Language Consistency</td> </tr> <tr> <td><strong>Training Stability</strong></td> <td>❌ Unstable early-stage RL</td> <td>✅ More stable due to cold-start fine-tuning</td> </tr> <tr> <td><strong>Output Readability</strong></td> <td>❌ Mixed-language responses, unstructured</td> <td>✅ Structured reasoning with CoT enforcement</td> </tr> <tr> <td><strong>Final Refinement</strong></td> <td>Single-stage RL</td> <td>Multi-stage RL + rejection sampling</td> </tr> </tbody> </table> <h4 id="final-performance-impact">Final Performance Impact</h4> <ul> <li>DeepSeek-R1-Zero successfully demonstrated that LLMs can develop reasoning purely via RL, but suffered from poor readability and chaotic convergence.</li> <li>DeepSeek-R1 introduced a structured multi-phase training pipeline, resulting in more readable, reliable, and generalized reasoning capabilities, ultimately achieving performance on par with OpenAI o1.</li> </ul> <h2 id="emergent-reasoning-behaviors">Emergent Reasoning Behaviors</h2> <ul> <li> <p>DeepSeek-R1 demonstrated remarkable emergent reasoning behaviors during its training process, particularly due to the RL approach that guided its self-evolution. These behaviors include:</p> <ul> <li> <p><strong>Reflection</strong>: The model exhibits the ability to revisit and revise its intermediate steps. By analyzing prior outputs and reconsidering logical pathways, it refines its reasoning, ensuring a higher probability of correctness. This reflection is especially visible in long Chain-of-Thought (CoT) processes where multiple reasoning paths are explored.</p> </li> <li> <p><strong>Self-Correction</strong>: DeepSeek-R1 can detect errors in its own logical steps and apply corrective adjustments. This behavior is incentivized by reward modeling, where the model is trained to recognize inconsistencies and rerun calculations when necessary. This prevents incorrect conclusions from being solidified.</p> </li> <li> <p><strong>Aha Moments</strong>: Perhaps the most striking emergent behavior is the spontaneous “aha moment,” where DeepSeek-R1 halts its current reasoning trajectory, reevaluates the problem from a new angle, and finds a more optimal solution. This is often triggered by a discrepancy between expected and derived results, prompting the model to explore alternative pathways.</p> </li> </ul> </li> </ul> <h3 id="implementation-details-2">Implementation Details</h3> <ul> <li> <p>DeepSeek-R1’s reasoning behaviors emerged through a structured RL framework that included:</p> <ol> <li> <strong>Reward-Based Training</strong>: The model was incentivized to provide correct and structured solutions through accuracy and format rewards. This helped shape behaviors like reflection and self-correction.</li> <li> <strong>Policy Optimization</strong>: Using Group Relative Policy Optimization (GRPO), the model iteratively refined its reasoning processes based on feedback from sampled responses.</li> <li> <strong>Rejection Sampling</strong>: Intermediate outputs were filtered based on correctness, ensuring that only accurate and well-structured reasoning chains were reinforced.</li> <li> <strong>Cold Start Data</strong>: Unlike its predecessor, DeepSeek-R1-Zero, which purely relied on RL, DeepSeek-R1 was trained on curated long-form reasoning examples as a base, significantly improving its ability to structure logical steps coherently.</li> </ol> </li> </ul> <h3 id="example-quadratic-equation-solving">Example: Quadratic Equation Solving</h3> <ul> <li> <p>Consider the problem:</p> <p>x2−5x+6=0</p> <ol> <li>The model initially proposes an incorrect factorization.</li> <li>It pauses to reevaluate and notices an inconsistency in the calculated roots.</li> <li>Upon reflection, it correctly factors the equation and derives x=2,x=3.</li> </ol> </li> <li> <p>This self-correcting behavior is illustrated in the table from the original paper:</p> </li> </ul> <p><img src="https://aman.ai/primers/ai/assets/DeepSeek/2.png" alt=""></p> <h2 id="distillation-reasoning-in-compact-models">Distillation: Reasoning in Compact Models</h2> <ul> <li>DeepSeek-R1’s advanced reasoning capabilities were distilled into smaller models, including Qwen-7B and Llama-8B, through an optimized training pipeline designed to preserve reasoning depth while reducing computational complexity.</li> </ul> <h3 id="implementation-details-3">Implementation Details</h3> <ol> <li> <strong>Teacher-Student Paradigm</strong>: <ul> <li>DeepSeek-R1 was used as the “teacher” model.</li> <li>The distilled models (e.g., Qwen-7B, Llama-8B) were fine-tuned on 800K reasoning-related samples generated by DeepSeek-R1.</li> </ul> </li> <li> <strong>Training Process</strong>: <ul> <li>Unlike RL-based training for DeepSeek-R1, distilled models were trained primarily using SFT.</li> <li>The dataset included: <ul> <li>600K reasoning-based samples covering math, logical reasoning, and coding.</li> <li>200K general-purpose samples to ensure well-rounded performance.</li> </ul> </li> </ul> </li> <li> <strong>Comparison Against RL Training</strong>: <ul> <li>Experiments showed that distilling reasoning behaviors from DeepSeek-R1 was significantly more effective than training smaller models from scratch using RL.</li> <li>A direct RL-trained Qwen-32B model underperformed compared to the distilled DeepSeek-R1-Distill-Qwen-32B, highlighting the efficiency of distillation in preserving complex reasoning patterns.</li> </ul> </li> <li> <strong>Performance Metrics:</strong> <ul> <li>The table below showcases how distilled DeepSeek-R1 models compare against non-reasoning models like GPT-4o and larger models like OpenAI o1-mini.</li> </ul> </li> </ol> <p><img src="https://aman.ai/primers/ai/assets/DeepSeek/3.png" alt=""></p> <h2 id="results">Results</h2> <ul> <li> <p>The plot below from the <a href="https://arxiv.org/abs/2501.12948" rel="external nofollow noopener" target="_blank">paper</a> illustrates the performance of DeepSeek-R1 across multiple benchmarks, showing it is on par with or even surpassing OpenAI’s models in several areas:</p> <p><img src="https://aman.ai/primers/ai/assets/DeepSeek/1.png" alt=""></p> <ul> <li> <strong>Mathematical Reasoning</strong>: Achieved a 97.3% pass rate on MATH-500, outperforming previous open-source models.</li> <li> <strong>Code Competitions</strong>: Placed in the 96.3rd percentile on Codeforces, equivalent to expert-level human competitors.</li> <li> <strong>General Knowledge</strong>: Scored 90.8% on MMLU, demonstrating strong performance in broad knowledge domains.</li> </ul> </li> <li> <p>DeepSeek-R1 represents a major leap in the ability of LLMs to develop, refine, and transfer complex reasoning skills. Its RL-based self-evolution and highly effective distillation pipeline set a new standard for reasoning models, enabling smaller models to achieve state-of-the-art performance with minimal computational overhead.</p> </li> </ul> <h3 id="average-response-length-vs-timesteps">Average Response Length vs. Timesteps</h3> <ul> <li>The plot below from the <a href="https://arxiv.org/abs/2501.12948" rel="external nofollow noopener" target="_blank">paper</a> illustrates the average response length of DeepSeek-R1-Zero on the training set during the RL process. DeepSeek-R1-Zero naturally learns to use longer CoT to solve complex reasoning problems with more thinking time.</li> </ul> <p><img src="https://aman.ai/primers/ai/assets/DeepSeek/AvgResponseLength.jpg" alt=""></p> <h3 id="comparison-of-deepseek-r1-and-deepseek-r1-zero">Comparison of DeepSeek-R1 and DeepSeek-R1-Zero</h3> <ul> <li>DeepSeek-R1 and DeepSeek-R1-Zero represent two different approaches to RL training for enhancing reasoning capabilities in LLMs. The fundamental distinction between these models lies in their training methodologies, resulting in notable differences in their overall performance and usability.</li> </ul> <h4 id="training-approach">Training Approach</h4> <ul> <li>DeepSeek-R1-Zero is trained purely via RL, without any SFT as a cold start. This allows the model to develop reasoning capabilities through self-evolution but leads to certain drawbacks such as poor readability and language mixing.</li> <li>DeepSeek-R1, on the other hand, incorporates a multi-stage training process that begins with a cold-start SFT phase using high-quality long CoT data, followed by RL. This additional step helps improve stability, readability, and overall performance.</li> </ul> <h4 id="performance-differences">Performance Differences</h4> <ul> <li>The differences in training methodologies translate into substantial variations in benchmark performance:</li> </ul> <table> <thead> <tr> <th><strong>Model</strong></th> <th><strong>AIME 2024 (Pass@1)</strong></th> <th><strong>MATH-500 (Pass@1)</strong></th> <th><strong>GPQA Diamond (Pass@1)</strong></th> <th><strong>LiveCodeBench (Pass@1)</strong></th> <th><strong>Codeforces (Rating)</strong></th> </tr> </thead> <tbody> <tr> <td><strong>DeepSeek-R1</strong></td> <td><strong>79.8%</strong></td> <td><strong>97.3%</strong></td> <td><strong>71.5%</strong></td> <td><strong>65.9%</strong></td> <td><strong>2029</strong></td> </tr> <tr> <td><strong>DeepSeek-R1-Zero</strong></td> <td>71.0%</td> <td>95.9%</td> <td>73.3%</td> <td>50.0%</td> <td>1444</td> </tr> </tbody> </table> <ul> <li>DeepSeek-R1 achieves significantly higher performance across math reasoning (MATH-500), general knowledge (GPQA Diamond), and code competition benchmarks (Codeforces) compared to DeepSeek-R1-Zero.</li> <li> <p>The improved LiveCodeBench score suggests better performance in software engineering-related tasks.</p> </li> <li>The following plot from the paper shows the AIME accuracy of DeepSeek-R1-Zero during training. For each question, they sample 16 responses and calculate the overall average accuracy to ensure a stable evaluation.</li> </ul> <p><img src="https://aman.ai/primers/ai/assets/DeepSeek/AIME-DeepSeek-R1-Zero.jpg" alt=""></p> <h4 id="readability-and-language-consistency">Readability and Language Consistency</h4> <ul> <li>DeepSeek-R1-Zero, while effective in reasoning, suffers from language mixing and poor readability since it lacks constraints on output formatting.</li> <li>DeepSeek-R1 significantly improves readability by enforcing structured Chain-of-Thought reasoning and incorporating additional rejection sampling and supervised fine-tuning for human-friendly outputs.</li> </ul> <h4 id="self-evolution-and-aha-moments">Self-Evolution and “Aha Moments”</h4> <ul> <li>One of the key observations during DeepSeek-R1-Zero training was the emergence of an “Aha Moment”, where the model learned to revise its reasoning process independently. This phenomenon underscores the potential of RL in developing sophisticated reasoning behaviors.</li> <li>However, DeepSeek-R1 further refines this capability by integrating rejection sampling, which filters out incorrect or incoherent responses, leading to a more robust and structured reasoning process.</li> </ul> <h2 id="open-questions">Open Questions</h2> <ul> <li>As shown in the figure below (<a href="https://huggingface.co/blog/open-r1" rel="external nofollow noopener" target="_blank">source</a>), making a powerful reasoning model is now very simple if you have access to a capable base model and a high-quality data mixture:</li> </ul> <p><img src="https://aman.ai/primers/ai/assets/DeepSeek/reasoningLLM.png" alt=""></p> <ul> <li> <p>Despite DeepSeek-R1’s advances, several open questions remain regarding its development and optimal implementation:</p> <ul> <li> <strong>Data Collection</strong>: How were the reasoning-specific datasets curated? Understanding the sources and selection criteria for data is crucial for replicating and improving the model’s performance.</li> <li> <strong>Model Training</strong>: No training code was released by DeepSeek, leaving uncertainty about which hyperparameters work best and how they differ across model families and scales.</li> <li> <strong>Scaling Laws</strong>: What are the compute and data trade-offs in training reasoning models? Identifying these relationships is critical for optimizing future models.</li> </ul> </li> </ul> <h2 id="other-reasoning-models">Other Reasoning Models</h2> <h3 id="qwq-reflect-deeply-on-the-boundaries-of-the-unknown"><a href="https://qwenlm.github.io/blog/qwq-32b-preview/" rel="external nofollow noopener" target="_blank">QwQ: Reflect Deeply on the Boundaries of the Unknown</a></h3> <ul> <li>Developed by the Qwen Team, QwQ-32B-Preview is an experimental research model focusing on advancing AI reasoning.</li> <li>The model embodies a philosophical approach to problem-solving, constantly questioning its assumptions and refining its reasoning.</li> <li> <strong>Core strengths</strong>: Excels in mathematics and coding, showcasing deep analytical skills when given time to reflect on its reasoning process.</li> <li> <strong>Limitations</strong>: May exhibit recursive reasoning loops, unexpected language mixing, and requires enhanced safety measures for reliable deployment.</li> <li> <strong>Benchmark Performance</strong>: <ul> <li> <strong>GPQA</strong> (Graduate-Level Google-Proof Q&amp;A): 65.2% – demonstrating strong scientific reasoning.</li> <li> <strong>AIME</strong> (American Invitational Mathematics Exam): 50.0% – highlighting strong math problem-solving skills.</li> <li> <strong>MATH-500</strong>: 90.6% – exceptional performance across various math topics.</li> <li> <strong>LiveCodeBench</strong>: 50.0% – proving solid real-world programming capabilities.</li> </ul> </li> <li> <strong>Reasoning Approach</strong>: <ul> <li>Uses deep introspection and self-dialogue to refine answers.</li> <li>Prioritizes reflection over quick responses, mirroring human-like problem-solving strategies.</li> </ul> </li> <li> <strong>Future Directions</strong>: The research extends into process reward models, LLM critique, multi-step reasoning, and reinforcement learning with system feedback.</li> <li>QwQ represents an evolving frontier in AI reasoning, pushing boundaries in understanding and self-correction.</li> </ul> <h3 id="s1-simple-test-time-scaling"><a href="https://arxiv.org/abs/2501.19393" rel="external nofollow noopener" target="_blank">s1: Simple Test-Time Scaling</a></h3> <ul> <li>This paper by Muennighoff et al. from Stanford and UW introduces test-time scaling, a method that improves reasoning performance in large language models (LLMs) by leveraging extra compute at inference time. The authors propose budget forcing, a simple intervention that controls the duration of the model’s reasoning process, allowing it to self-correct and refine its answers.</li> <li> <strong>Main Contributions:</strong> <ol> <li> <strong>Dataset Creation (s1K):</strong> <ul> <li>A small dataset of 1,000 high-quality reasoning questions was curated from an initial pool of 59,000 samples.</li> <li>Selection was based on three criteria: difficulty, diversity, and quality.</li> <li>The final dataset was distilled from Google’s Gemini Thinking Experimental API.</li> </ul> </li> <li> <strong>Budget Forcing (Test-Time Scaling Method):</strong> <ul> <li>Allows control over how long the model “thinks” before generating an answer.</li> <li> <strong>Two key techniques:</strong> <ul> <li> <strong>Early termination:</strong> If the model exceeds a threshold of “thinking tokens,” it is forced to provide an answer.</li> <li> <strong>Extended reasoning:</strong> The model is encouraged to continue reasoning by appending “Wait” to the generation when it tries to stop.</li> </ul> </li> </ul> </li> <li> <strong>Fine-Tuned Model (s1-32B):</strong> <ul> <li>The Qwen2.5-32B-Instruct model was fine-tuned on s1K in just 26 minutes on 16 NVIDIA H100 GPUs.</li> <li>This model outperformed OpenAI’s o1-preview on math reasoning tasks like MATH and AIME24.</li> </ul> </li> <li> <strong>Experimental Results:</strong> <ul> <li> <strong>Scaling performance:</strong> Budget forcing allowed the model to exceed its baseline performance without test-time intervention.</li> <li> <strong>Competitiveness:</strong> s1-32B outperformed larger closed-source models and was the most sample-efficient among open-weight models.</li> </ul> </li> <li> <strong>Ablations &amp; Comparisons:</strong> <ul> <li> <strong>Dataset selection:</strong> Carefully selected 1,000 samples performed better than using all 59,000 samples.</li> <li> <strong>Test-time scaling methods:</strong> Budget forcing showed superior control and performance compared to majority voting, rejection sampling, and conditional control methods.</li> <li> <strong>Parallel vs. Sequential Scaling:</strong> Budget forcing (sequential) was more effective than parallel methods like majority voting.</li> </ul> </li> </ol> </li> <li> <strong>Key Results:</strong> <ul> <li>The s1-32B model, fine-tuned on just 1,000 reasoning examples, achieved 56.7% accuracy on AIME24, 93.0% on MATH500, and 59.6% on GPQA Diamond. Without any test-time intervention, the model’s AIME24 score was 50%, demonstrating that test-time scaling via budget forcing leads to significant improvements.</li> <li>By comparison, OpenAI’s o1-preview achieved 44.6% on AIME24, 85.5% on MATH500, and 73.3% on GPQA Diamond. Other open-weight models like DeepSeek r1 outperformed s1-32B but required over 800,000 training examples, while s1-32B achieved strong reasoning performance with only 1,000 carefully selected samples. The base model (Qwen2.5-32B-Instruct), before fine-tuning, scored just 26.7% on AIME24, highlighting the significant impact of s1K fine-tuning and test-time scaling.</li> </ul> </li> <li> <strong>Conclusion:</strong> <ul> <li>Test-time scaling via budget forcing is a lightweight yet powerful method for improving reasoning performance.</li> <li>Fine-tuning on just 1,000 carefully selected examples can match or outperform models trained on hundreds of thousands of samples.</li> <li>The approach is open-source, providing a transparent and reproducible path to improving LLM reasoning abilities.</li> </ul> </li> <li><a href="https://github.com/simplescaling/s1" rel="external nofollow noopener" target="_blank">Code</a></li> </ul> <h3 id="sky-t1"><a href="https://novasky-ai.github.io/posts/sky-t1/" rel="external nofollow noopener" target="_blank">Sky-T1</a></h3> <ul> <li> <p>This blog by the NovaSky team at UC Berkeley introduces Sky-T1-32B-Preview, an open-source reasoning model that achieves performance comparable to o1-preview on reasoning and coding benchmarks while being trained for under $450. All code, data, and model weights are publicly available.</p> </li> <li> <p><strong>Motivation:</strong> Current state-of-the-art reasoning models like o1 and Gemini 2.0 demonstrate strong reasoning abilities but remain closed-source, limiting accessibility for academic and open-source research. Sky-T1 addresses this gap by providing a high-performing, fully transparent alternative.</p> </li> <li> <strong>Key Contributions:</strong> <ul> <li> <strong>Fully Open-Source:</strong> Unlike closed models, Sky-T1 releases all resources—data, training code, technical report, and model weights—allowing for easy replication and further research.</li> <li> <strong>Affordable Training:</strong> Sky-T1-32B-Preview was trained for only $450, leveraging Qwen2.5-32B-Instruct as a base model and fine-tuning it using 17K curated training samples.</li> <li> <strong>Dual-Domain Reasoning:</strong> Unlike prior efforts that focused solely on math reasoning (e.g., STILL-2, Journey), Sky-T1 excels in both math and coding within a single model.</li> </ul> </li> <li> <strong>Data Curation:</strong> <ul> <li>Uses QwQ-32B-Preview, an open-source model with reasoning capabilities comparable to o1-preview.</li> <li>Reject sampling ensures high-quality training data by filtering incorrect samples through exact-matching (for math) and unit test execution (for coding).</li> <li>Final dataset includes 5K coding problems (APPs, TACO), 10K math problems (AIME, MATH, Olympiad), and 1K science/puzzle problems (from STILL-2).</li> </ul> </li> <li> <p><strong>Training Details:</strong></p> <ul> <li>Fine-tuned on Qwen2.5-32B-Instruct for 3 epochs with a learning rate of 1e-5 and a batch size of 96.</li> <li>Training completed in 19 hours on 8 H100 GPUs, utilizing DeepSpeed Zero-3 offload for efficiency.</li> <li>The following figure from the blog shows the training flow of Sky-T1:</li> </ul> <p><img src="https://aman.ai/images/papers/Sky-T1.jpg" alt=""></p> </li> <li> <strong>Evaluation and Results:</strong> <ul> <li>Matches or surpasses o1-preview in multiple reasoning and coding benchmarks: <ul> <li> <strong>Math500:</strong> 82.4% (vs. 81.4% for o1-preview)</li> <li> <strong>AIME 2024:</strong> 43.3% (vs. 40.0% for o1-preview)</li> <li> <strong>LiveCodeBench-Easy:</strong> 86.3% (close to 92.9% of o1-preview)</li> <li> <strong>LiveCodeBench-Hard:</strong> 17.9% (slightly ahead of 16.3% for o1-preview)</li> </ul> </li> <li>Performs competitively with QwQ (which has a closed dataset) while remaining fully open-source.</li> </ul> </li> <li> <strong>Key Findings:</strong> <ul> <li> <strong>Model size matters:</strong> Smaller models (7B, 14B) showed only modest gains, with 32B providing a significant leap in performance.</li> <li> <strong>Data mixture impacts performance:</strong> Incorporating math-only data initially boosted AIME24 accuracy from 16.7% to 43.3%, but adding coding data lowered it to 36.7%. A balanced mix of complex math and coding problems restored strong performance in both domains.</li> </ul> </li> <li> <strong>Conclusion:</strong> Sky-T1-32B-Preview proves that high-level reasoning capabilities can be replicated affordably and transparently. By open-sourcing all components, it aims to empower the academic and open-source communities to drive further advancements in reasoning model development.</li> <li><a href="https://github.com/novasky-ai/sky-t1-32b-preview" rel="external nofollow noopener" target="_blank">Code</a></li> </ul> <h3 id="kimi-k15-scaling-reinforcement-learning-with-llms"><a href="https://arxiv.org/abs/2501.12599" rel="external nofollow noopener" target="_blank">Kimi K1.5: Scaling Reinforcement Learning with LLMs</a></h3> <ul> <li>This paper by the Kimi Team proposes Kimi K1.5, a state-of-the-art multimodal large language model (LLM) trained with reinforcement learning (RL). Unlike traditional LLMs that rely solely on pretraining and supervised fine-tuning, Kimi K1.5 expands its learning capabilities by leveraging long-context RL training, enabling it to scale beyond static datasets through reward-driven exploration. Kimi K1.5 demonstrates that scaling reinforcement learning with long-context training significantly improves LLM performance. The model leverages optimized learning algorithms, partial rollouts, and efficient policy optimization to achieve strong RL results without relying on computationally expensive techniques like Monte Carlo tree search.</li> <li>Additionally, the long-to-short (L2S) transfer process enables short-CoT models to inherit reasoning abilities from long-CoT models, drastically improving token efficiency while maintaining high performance.</li> <li>The model achieves state-of-the-art performance across multiple benchmarks. It scores 77.5 Pass@1 on AIME 2024, 96.2 Exact Match on MATH 500, 94th percentile on Codeforces, and 74.9 Pass@1 on MathVista, matching OpenAI’s o1 model. Additionally, its short-CoT variant outperforms GPT-4o and Claude Sonnet 3.5 by a wide margin, achieving up to 550% improvement on some reasoning tasks.</li> <li> <strong>Key Contributions</strong>: <ul> <li> <p><strong>Long-context scaling:</strong> Kimi K1.5 scales RL training to a 128K token context window, demonstrating continuous improvements in reasoning performance as the context length increases. Instead of re-generating full sequences, it employs partial rollouts to reuse previous trajectories, making training more efficient.</p> </li> <li> <p><strong>A simplified yet powerful RL framework:</strong> Unlike traditional RL-based models, Kimi K1.5 does not rely on complex techniques such as Monte Carlo tree search, value functions, or process reward models. Instead, it employs chain-of-thought (CoT) reasoning, allowing the model to develop planning, reflection, and correction capabilities without computationally expensive search mechanisms.</p> </li> <li> <p><strong>Advanced RL optimization techniques:</strong> Kimi K1.5 introduces a variant of online mirror descent for policy optimization, incorporating length penalties, curriculum sampling, and prioritized sampling to further enhance training efficiency and prevent overthinking.</p> </li> <li> <p><strong>Multimodal capabilities:</strong> The model is jointly trained on text and vision data, enabling it to reason across modalities. It performs well in OCR-based tasks, chart interpretation, and vision-based mathematical reasoning.</p> </li> <li> <p><strong>Long-to-Short (L2S) Training:</strong> The model introduces long2short methods that transfer reasoning patterns from long-CoT models to short-CoT models. These techniques significantly improve token efficiency, allowing the short-CoT version to achieve state-of-the-art results on benchmarks like AIME 2024 (60.8 Pass@1) and MATH 500 (94.6 Exact Match), surpassing GPT-4o and Claude Sonnet 3.5.</p> </li> </ul> </li> <li> <strong>Technical Details</strong>: <ul> <li> <strong>Training Approach</strong>:</li> <li>The development of Kimi K1.5 involves multiple stages: <ul> <li> <strong>Pretraining:</strong> The base model is trained on a diverse dataset spanning English, Chinese, code, mathematics, and general knowledge.</li> <li> <strong>Vanilla Supervised Fine-Tuning (SFT):</strong> The model is refined using a mix of human-annotated and model-generated datasets, ensuring high-quality responses.</li> <li> <strong>Long-CoT Fine-Tuning:</strong> A warmup phase introduces structured reasoning, teaching the model essential skills such as planning, evaluation, reflection, and exploration.</li> <li> <strong>Reinforcement Learning (RL):</strong> The model is further optimized with reward-based feedback, strengthening its ability to reason through complex problems.</li> <li>To ensure optimal RL training, Kimi K1.5 employs a carefully curated prompt set that spans multiple domains, balancing difficulty levels and ensuring robust evaluability. It also applies curriculum sampling (starting with easy tasks before progressing to harder ones) and prioritized sampling (focusing on problems where the model underperforms).</li> </ul> </li> </ul> </li> <li> <p><strong>Reinforcement Learning Infrastructure</strong>:</p> <ul> <li>Kimi K1.5 leverages an advanced RL training infrastructure to scale efficiently: <ul> <li> <strong>Partial Rollouts:</strong> The model segments long responses into smaller chunks, preventing lengthy reasoning trajectories from slowing down training. This method allows parallel training of both long and short responses, maximizing compute efficiency.</li> <li> <strong>Hybrid Training Deployment:</strong> Training is conducted using Megatron, while inference is performed on vLLM, allowing dynamic scaling of resources.</li> <li> <strong>Code Sandbox for Coding RL:</strong> The model uses an automated test case generation system to evaluate coding solutions. It is optimized with fast execution techniques like Crun and Cgroup reuse to improve training speed and stability.</li> </ul> </li> <li>The following figure from the paper shows the Kimi K1.5, a large scale reinforcement learning training system for LLM.</li> </ul> <p><img src="https://aman.ai/images/papers/Kimi-K1.5.jpg" alt=""></p> </li> <li> <strong>Evaluation &amp; Results</strong>: <ul> <li>Kimi K1.5 achieves state-of-the-art results across multiple benchmarks: <ol> <li> <strong>Long-CoT Model Performance:</strong> <ul> <li>It matches or surpasses OpenAI’s o1 model in key reasoning tasks.</li> <li>On MATH 500, Kimi K1.5 achieves 96.2 Exact Match, outperforming other open-source models such as QwQ-32B (90.6).</li> <li>On AIME 2024, it reaches 77.5 Pass@1, improving over QwQ-32B (63.6).</li> <li>For coding tasks, it ranks in the 94th percentile on Codeforces, surpassing QwQ-32B (62nd percentile).</li> <li>In vision-based reasoning, it scores 74.9 Pass@1 on MathVista, ahead of OpenAI’s o1-mini (71.0).</li> </ul> </li> <li> <strong>Short-CoT Model Performance:</strong> <ul> <li>Kimi K1.5’s short-CoT model significantly outperforms GPT-4o and Claude Sonnet 3.5 on mathematical and coding reasoning tasks.</li> <li>It achieves 94.6 Exact Match on MATH 500, whereas GPT-4o scores 74.6 and Claude Sonnet 3.5 scores 78.3.</li> <li>On AIME 2024, Kimi K1.5 short-CoT achieves 60.8 Pass@1, far exceeding GPT-4o (9.3) and Claude Sonnet 3.5 (16.0).</li> <li>In LiveCodeBench, the model scores 47.3 Pass@1, outperforming GPT-4o (33.4) and Claude Sonnet 3.5 (36.3).</li> </ul> </li> </ol> </li> </ul> </li> <li> <strong>Ablation Studies</strong>: <ul> <li>Scaling Context Length vs Model Size: <ul> <li>Smaller models can match the reasoning ability of larger models if trained with long-CoT and RL.</li> <li>However, larger models remain more token-efficient, meaning they require fewer tokens to achieve similar performance.</li> </ul> </li> <li>Negative Gradients vs ReST (Reward-based Supervised Tuning): <ul> <li>Kimi K1.5 outperforms ReST-based approaches by leveraging negative gradients during policy optimization, leading to more efficient training.</li> </ul> </li> <li>Curriculum Sampling vs Uniform Sampling: <ul> <li>Models trained with curriculum sampling (progressing from easy to hard problems) outperform those trained with uniform sampling.</li> <li>This approach accelerates learning and improves generalization on test problems.</li> </ul> </li> </ul> </li> <li><a href="https://github.com/MoonshotAI/Kimi-k1.5" rel="external nofollow noopener" target="_blank">Code</a></li> </ul> <h3 id="open-r1"><a href="https://huggingface.co/blog/open-r1" rel="external nofollow noopener" target="_blank">Open-R1</a></h3> <ul> <li>While DeepSeek-R1 provides open weights, the datasets and code used in training remain proprietary. The aforementioned questions have driven the <a href="https://huggingface.co/blog/open-r1" rel="external nofollow noopener" target="_blank">Open-R1</a> project, an initiative to systematically reconstruct DeepSeek-R1’s data and training pipeline as open-source, validate its claims, and push the boundaries of open reasoning models.</li> <li>The motivation behind building <a href="https://github.com/huggingface/open-r1" rel="external nofollow noopener" target="_blank">Open-R1</a> is to provide transparency on how RL can enhance reasoning, share reproducible insights with the open-source community, and create a foundation for future models to leverage these techniques.</li> </ul> <h4 id="objectives-of-open-r1">Objectives of Open-R1</h4> <ol> <li> <strong>Reproducing R1-Distill Models</strong>: By distilling a high-quality reasoning dataset from DeepSeek-R1, Open-R1 aims to replicate the R1-Distill models faithfully.</li> <li> <strong>Replicating the RL Training Pipeline</strong>: A critical component of DeepSeek-R1 is its RL-based training methodology. Open-R1 will curate large-scale datasets for mathematics, reasoning, and code to enable this training process.</li> <li> <strong>Advancing Multi-Stage Training</strong>: Demonstrating the full transition from a base model through SFT to RL will be a key milestone, ensuring a reproducible and scalable methodology.</li> </ol> <ul> <li>As shown in the figure below (<a href="https://huggingface.co/blog/open-r1" rel="external nofollow noopener" target="_blank">source</a>), here’s the Open-R1 plan:</li> </ul> <p><img src="https://aman.ai/primers/ai/assets/DeepSeek/open-r1-steps.png" alt=""></p> <ul> <li> <strong>Accessible Reasoning Models</strong>: Open-R1’s synthetic datasets will allow anyone to fine-tune existing or new LLMs for reasoning tasks simply by leveraging these datasets.</li> <li> <strong>Open RL Recipes</strong>: The initiative will provide well-documented RL methodologies that can serve as a foundation for future research and experimentation.</li> <li> <strong>Exploring Beyond Math</strong>: While mathematical reasoning is a primary focus, Open-R1 will explore extensions into other domains, including programming and scientific applications such as medicine, where reasoning models can make a significant impact.</li> </ul> <h2 id="reasoning-datasets">Reasoning Datasets</h2> <ol> <li> <a href="https://huggingface.co/datasets/open-thoughts/OpenThoughts-114k" rel="external nofollow noopener" target="_blank">OpenThoughts</a>: 114k samples distilled from R1 on math, code, and science.</li> <li> <a href="https://huggingface.co/datasets/ServiceNow-AI/R1-Distill-SFT" rel="external nofollow noopener" target="_blank">R1-Distill-SFT</a>: 1.7M samples distilled from R1-32B on NuminaMath and Allen AI’s Tulu.</li> </ol> <h2 id="references">References</h2> <ul> <li><a href="https://arxiv.org/abs/2501.12948" rel="external nofollow noopener" target="_blank">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a></li> <li><a href="https://www.linkedin.com/pulse/deepseek-r1-pure-rl-based-reasoning-model-jayant-kumar-yfopc/?trackingId=Tc70aMqJS42SK6oiIPqBZA%3D%3D" rel="external nofollow noopener" target="_blank">DeepSeek-R1: A Pure RL-based Reasoning Model</a></li> <li><a href="https://arxiv.org/abs/2402.03300" rel="external nofollow noopener" target="_blank">DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open Language Models</a></li> <li><a href="https://arxiv.org/abs/2412.19437" rel="external nofollow noopener" target="_blank">DeepSeek-V3 Technical Report</a></li> <li><a href="https://huggingface.co/blog/open-r1" rel="external nofollow noopener" target="_blank">Open-R1: a fully open reproduction of DeepSeek-R1</a></li> <li><a href="https://medium.com/autonomous-agents/deepseek-r1-the-moe-fallacy-and-the-true-source-of-emergent-reasoning-cedba23a7788" rel="external nofollow noopener" target="_blank">DeepSeek-R1: The MoE Fallacy and the True Source of Emergent Reasoning</a></li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/how-to-write-a-good-scientific-review/">How to write a good scientific review?</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/habits/">Habits</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/regulate-your-blood-sugarnourish-to-flourish-harnessing-glycogen-for-peak-performance-at-work/">Regulate your blood sugar! — Nourish to Flourish: Harnessing Glycogen for Peak Performance at Work</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/how-to-lead-when-you-are-not-in-charge/">How to lead when you are not in charge?</a> </li> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>let giscusTheme=determineComputedTheme(),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"lorenz-peter/lorenz-peter.github.io","data-repo-id":"","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Peter Lorenz. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?06cae41083477f121be8cd9797ad8e2f"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"publications by categories in reversed chronological order. generated by jekyll-scholar.",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-projects",title:"projects",description:"A growing collection of your cool projects.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-repositories",title:"repositories",description:"",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-cv",title:"cv",description:"",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-deepseek-primer",title:"DeepSeek Primer",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/deepseek-primer/"}},{id:"post-adversarial-attacks-on-llms",title:"Adversarial Attacks on LLMs",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/llm-adversarial-attacks/"}},{id:"post-adamsi-fgm",title:"AdaMSI-FGM",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/adaptive-mi-fgsm/"}},{id:"post-a-complete-list-of-all-arxiv-model-stealing-papers-under-construction",title:"A complete list of all (arXiv) model stealing papers (under construction)",description:"shows latest related work",section:"Posts",handler:()=>{window.location.href="/blog/2024/rw_ms/"}},{id:"post-autoattack",title:"AutoAttack",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/autoattack/"}},{id:"post-clear-thinking-turning-ordinary-moments-into-extraordinary-results",title:"Clear Thinking: Turning Ordinary Moments into Extraordinary Results",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/clear-thinking-turning-ordinary-moments-into-extraordinary-results-d2f4dd65c4b7?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-confidence-in-public-speaking-and-presenting",title:"Confidence in public speaking and presenting",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/confidence-in-public-speaking-and-presenting-a9f5fbf34e8a?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-how-to-lead-when-you-are-not-in-charge",title:"How to lead when you are not in charge?",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/how-to-lead-when-you-are-not-in-charge-175e7d9351dd?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-parse-the-paper-list",title:"Parse the Paper List",description:"Parse the json file",section:"Posts",handler:()=>{window.location.href="/blog/2024/load-json/"}},{id:"post-research-trends",title:"Research Trends",description:"an example of how to use Bootstrap Tables",section:"Posts",handler:()=>{window.location.href="/blog/2024/research_trends/"}},{id:"post-regulate-your-blood-sugar-nourish-to-flourish-harnessing-glycogen-for-peak-performance-at-work",title:"Regulate your blood sugar!\u200a\u2014\u200aNourish to Flourish: Harnessing Glycogen for Peak Performance at Work",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/regulate-your-blood-sugar-nourish-to-flourish-harnessing-glycogen-for-peak-performance-at-work-3e711a24fc47?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-a-complete-list-of-all-arxiv-adversarial-examples-adex-papers-under-construction",title:"A complete list of all (arXiv) adversarial examples (AdEx) papers (under construction)",description:"shows latest related work",section:"Posts",handler:()=>{window.location.href="/blog/2024/rw_adex/"}},{id:"post-analysis-of-adversarial-examples-phd-thesis",title:"Analysis of Adversarial Examples (PhD Thesis)",description:"research",section:"Posts",handler:()=>{window.location.href="/blog/2024/phdthesis/"}},{id:"post-habits",title:"Habits",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/habits-07c3bfeba3b1?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-how-to-write-a-good-scientific-review",title:"How to write a good scientific review?",description:"",section:"Posts",handler:()=>{window.open("https://medium.com/@peter_lorenz/how-to-write-a-good-scientific-review-c6c5a5a66847?source=rss-8f1ecd60f5bf------2","_blank")}},{id:"post-find-the-right-conference",title:"Find the right conference!",description:"conference",section:"Posts",handler:()=>{window.location.href="/blog/2024/findconference/"}},{id:"post-google-gemini-updates-flash-1-5-gemma-2-and-project-astra",title:"Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra",description:"We\u2019re sharing updates across our Gemini family of models and a glimpse of Project Astra, our vision for the future of AI assistants.",section:"Posts",handler:()=>{window.open("https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/","_blank")}},{id:"post-how-do-you-make-your-own-illustrations-for-your-paper",title:"How do you make your own illustrations for your paper?",description:"conference",section:"Posts",handler:()=>{window.location.href="/blog/2024/create-teaser-figure/"}},{id:"post-writeup-gandalf-from-lakera",title:"Writeup Gandalf from Lakera",description:"LLM hacking",section:"Posts",handler:()=>{window.location.href="/blog/2023/gandalf/"}},{id:"news-check-out-my-continuously-updated-reading-list-about-model-stealing-https-lorenz-peter-github-io-blog-2024-rw-ms",title:"Check out my continuously updated [reading list about model stealing](https://lorenz-peter.github.io/blog/2024/rw_ms)!",description:"",section:"News"},{id:"news-i-am-happy-to-announce-that-i-am-a-reviewer-at-the-cvpr-workshop-robustness-of-foundation-models-https-cvpr24-advml-github-io",title:"I am happy to announce that I am a reviewer at the [CVPR Workshop Robustness of Foundation Models](https://cvpr24-advml.github.io) \ud83c\udf89",description:"",section:"News"},{id:"news-i-am-accepted-for-the-oxford-summer-school-representation-learning-https-www-oxfordml-school-replearning",title:"I am accepted for the [Oxford Summer School - Representation Learning](https://www.oxfordml.school/replearning)",description:"",section:"News"},{id:"news-i-am-happy-to-announce-that-i-am-reviewer-at-icassp-on-the-topics-federated-split-learning-and-quantum-privacy",title:"I am happy to announce that I am reviewer at ICASSP on the topics federated / split learning and quantum privacy \ud83d\ude04",description:"",section:"News"},{id:"news-check-out-my-writeups-https-lorenz-peter-github-io-blog-2023-gandalf-from-the-lakera-gandalf-hackathon",title:"Check out my [writeups](https://lorenz-peter.github.io/blog/2023/gandalf) from the Lakera Gandalf hackathon.",description:"",section:"News"},{id:"projects-cat-image",title:"Cat image",description:"the famous cat image for adversarial perturbation",section:"Projects",handler:()=>{window.location.href="/projects/cat_image/"}},{id:"projects-cvpr-hackathon-2022",title:"CVPR Hackathon 2022",description:"robust model towards open-world classifications",section:"Projects",handler:()=>{window.location.href="/projects/cvpr_hackathon/"}},{id:"projects-tuglatextemplates",title:"TUGLatexTemplates",description:"A collection of diverse university-related templates.",section:"Projects",handler:()=>{window.location.href="/projects/latex_templates/"}},{id:"projects-oxford-ml-summer-school",title:"Oxford ML Summer School",description:"Attendance certificates",section:"Projects",handler:()=>{window.location.href="/projects/oxford_summers_school/"}},{id:"projects-multimodality-model-slang-visualization",title:"MultiModality Model Slang Visualization",description:"Visualize your slang!",section:"Projects",handler:()=>{window.location.href="/projects/slang_multimodal/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%70%65%74%65%72.%6C%6F%72%65%6E%7A.%77%6F%72%6B@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=sb4hPQMAAAAJ","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/jS5t3r","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/peter-lorenz-06918169","_blank")}},{id:"socials-x",title:"X",description:"Twitter",section:"Socials",handler:()=>{window.open("https://twitter.com/cs_peter_lorenz","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js"></script> </body> </html>